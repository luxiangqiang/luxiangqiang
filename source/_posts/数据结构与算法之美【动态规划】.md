---
title: 数据结构与算法之美【动态规划】
categories:
- 数据结构
tags:
- 数据结构
---

![](/images/动态规划)

小鹿带你走进数据结构与算法之美中的动态规划。

<!--more-->



## 动态规划基础篇

### 一、认识动态规划

> **问题：**“双十一” 购物问题，选择购物车中商品尽最大的能够参与满减活动。



#### 0 - 1 背包问题

**问题：**

背包问题我们进行改进，对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

> 回溯算法可以解决这个问题，但是需要穷举所有的情况，时间复杂度非常高，接下来我们用动态规划来解决此问题。



**回溯算法代码实现：**

```java
// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。
private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中
private int[] weight = {2，2，4，6，3};  // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
public void f(int i, int cw) { // 调用 f(0, 0)
  if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
    if (cw > maxW) maxW = cw;
    return;
  }
  f(i+1, cw); // 选择不装第 i 个物品
  if (cw + weight[i] <= w) {
    f(i+1,cw + weight[i]); // 选择装第 i 个物品
  }
}
```



**递归树实现：**

![](/images/回溯算法递归树.png)



> 递归中存在的问题在这个地方我们可以进行优化，就是重复计算问题。递归树的表现形式（i，w）,i 表示将要决策的第几个物品，w 是背包中已存在物品的总重量。



我们可以对地归树中存在的问题进行改进，通过散列表来存储已经计算过的值，当我们再次计算到该值的时候，我们就直接使用，而不是重复计算，降低效率。

```java
private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中
private int[] weight = {2，2，4，6，3};  // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值 false
public void f(int i, int cw) { // 调用 f(0, 0)
  if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
    if (cw > maxW) maxW = cw;
    return;
  }
  if (mem[i][cw]) return; // 重复状态
  mem[i][cw] = true; // 记录 (i, cw) 这个状态
  f(i+1, cw); // 选择不装第 i 个物品
  if (cw + weight[i] <= w) {
    f(i+1,cw + weight[i]); // 选择装第 i 个物品
  }
}
```



**动态规划解决：**

1、首先，我们将整个过程分解成 n 个阶段，每个阶段决策是否放入背包，每个决策完成之后会有多种情况，也就是对应递归树中不同的结点（不同状态）。

2、我们将每个阶段相同的情况进行合并，只记录一次，可以避免每个阶段情况数量的指数增长。

3、用二维数组来记录每个阶段不同的状态。

4、第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][2]=true 来表示这两种状态。

5、以此类推，我们将做成二维数组图。

![](/images/动态规划决策图1.png)

![](/images/动态规划决策图2.png)

6、代码实现：

```java
weight: 物品重量，n: 物品个数，w: 背包可承载重量
public int knapsack(int[] weight, int n, int w) {
  boolean[][] states = new boolean[n][w+1]; // 默认值 false
  states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
  states[0][weight[0]] = true;
  for (int i = 1; i < n; ++i) { // 动态规划状态转移
    for (int j = 0; j <= w; ++j) {// 不把第 i 个物品放入背包
      if (states[i-1][j] == true) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j <= w-weight[i]; ++j) {// 把第 i 个物品放入背包
      if (states[i-1][j]==true) states[i][j+weight[i]] = true;
    }
  }
  for (int i = w; i >= 0; --i) { // 输出结果
    if (states[n-1][i] == true) return i;
  }
  return 0;
}
```



**动态规划的时间复杂度**

> 回溯算法的时间复杂度为 O(2^n)，可知上述代码，动态时间复杂度为 O(n*w)。 n 表示物品个数，w 表示背包可以承载的总重量。



**动态规划的空间复杂度**

> 尽管执行效率很高，导师我们需要一个空间为 n*w+1 的二维数组，这是一种空间换时间的解**决思路。**



**动态规划空间消耗改进**

```java
public static int knapsack2(int[] items, int n, int w) {
  boolean[] states = new boolean[w+1]; // 默认值 false
  states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
  states[items[0]] = true;
  for (int i = 1; i < n; ++i) { // 动态规划
    for (int j = w-items[i]; j >= 0; --j) {// 把第 i 个物品放入背包
      if (states[j]==true) states[j+items[i]] = true;
    }
  }
  for (int i = w; i >= 0; --i) { // 输出结果
    if (states[i] == true) return i;
  }
  return 0;
}
```

> **补充：**j 是按照从大到小来计算的，如果从小到大计算存在重复，我们可以进行改进。



#### 0—1背包升级问题

> 增加的条件是，在满足以上条件的同时，要使的装入的物品价值最大，应该怎么做？



**实现思路**

> 我们继续画递归树，然后用（i,w+1）来表示，w+1 不能用 boolean 类型了，而是代表最大价值。



**代码实现**

```java
public static int knapsack3(int[] weight, int[] value, int n, int w) {
  int[][] states = new int[n][w+1];
  for (int i = 0; i < n; ++i) { // 初始化 states
    for (int j = 0; j < w+1; ++j) {
      states[i][j] = -1;
    }
  }
  states[0][0] = 0;
  states[0][weight[0]] = value[0];
  for (int i = 1; i < n; ++i) { // 动态规划，状态转移
    for (int j = 0; j <= w; ++j) { // 不选择第 i 个物品
      if (states[i-1][j] >= 0) states[i][j] = states[i-1][j];
    }
    for (int j = 0; j <= w-weight[i]; ++j) { // 选择第 i 个物品
      if (states[i-1][j] >= 0) {
        int v = states[i-1][j] + value[i];
        if (v > states[i][j+weight[i]]) {
          states[i][j+weight[i]] = v;
        }
      }
    }
  }
  // 找出最大值
  int maxvalue = -1;
  for (int j = 0; j <= w; ++j) {
    if (states[n-1][j] > maxvalue) maxvalue = states[n-1][j];
  }
  return maxvalue;
}
```





### 二、思考：双十一凑单购物问题

#### 1、问题

> 淘宝双十一购物，满 200 减 100 ，为了尽最大条件满足减满，怎么选择购物车里的物品呢？



#### 2、问题分析

> 1、如果用回溯算法解决，穷举所有的可能，选择解决200的那套方案，但是效率很低下，时间服阿杜非常高，指数级别。
>
> 2、如果我们采用动态规划去解决，但是并不像 0-1 背包问题，满足最大限度，而是接近最大限度的最小值（超过200最小值）。
>
> 3、求出接近200的最小值之后，然后倒推出我们可以选择哪些购买的商品。



#### 3、解决思路

> 1、购物车中有 n 个商品，针对每个商品进行决策是否购买，每次决策都对应不同的状态集合，我们用一个数组来表示。
>
> 2、我们设定一份最大上限值，比如 1001，我们要找的是大于等于 200（满减条件）的值中最小的。



#### 4、代码实现

```java
// items 商品价格，n 商品个数, w 表示满减条件，比如 200
public static void double11advance(int[] items, int n, int w) {
  // 设置上限为 3 倍
  boolean[][] states = new boolean[n][3*w+1];
  // 第一行的数据要特殊处理（也就是第 0 个物品两种选择）
  states[0][0] = true;  
  states[0][items[0]] = true;
  // 动态规划
  for (int i = 1; i < n; ++i) { 
    // 不购买第 i 个商品（结合二维图表来分析）
    for (int j = 0; j <= 3*w; ++j) {
        //对上一层状态集合改变下一层状态集合
        if (states[i-1][j] == true) {
            //进行标记true
            states[i][j] = states[i-1][j];
        }  
    }
    // 购买第 i 个商品
    for (int j = 0; j <= 3*w-items[i]; ++j) {
      // 商品价格相加
      if (states[i-1][j]==true) states[i][j+items[i]] = true;
    }
  }

  int j;
  for (j = w; j < 3*w+1; ++j) { 
    // 输出结果大于等于 w 的最小值
    if (states[n-1][j] == true) break; 
  }
  // 没有可行解
  if (j == -1) return; 
  // 倒推遍历可购买商品（i 表示二维数组中的行，j 表示列）
  for (int i = n-1; i >= 1; --i) {
    if(j-items[i] >= 0 && states[i-1][j-items[i]] == true) {
      // 购买这个商品的价格
      System.out.print(items[i] + " "); 
      //总价格减去已购买商品的价格
      j = j - items[i];
    } // else 没有购买这个商品，j 不变。
  }
  //如果遍历完成所有的商品价格，不等于大于200的最小值，就输出第一个商品价格
  if (j != 0) System.out.print(items[0]);
}
```

> 所有的商品可购买状态是由上一层决策推导而来的。
>
> 1、如果 states[i-1]\[j] 可达，就说明我们没有买这个商品；
>
> 2、如果 states[i-1]\[j-value[i]] 可达，就说明，我们已购买该商品。
>
> 3、如果两者都可达到，我们就随意选择一种，继续迭代其他商品。





## 动态规划理论篇

### 一、什么样的问题适合用动态规划？

> 一个模型三个特征。



#### 1、一个模型

> **多阶段策略最优解模型：**
>
> ① 一般是用动态规划来解决**最优问题**。
>
> ② 需要经历**多个决策阶段**。每个决策阶段都对应着**一组状态**。
>
> ③ 寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的**最优值**。



#### 2、三个特征

##### ① 最优子结构

> 问题的最优解包含子问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。



##### ② 无后效性

> 1、在推导后边的状态时，只关心前边的状态，不关心前边的状态是怎么推到出来的。
>
> 2、某一决策状态一旦确认，就不受后边阶段的影响。



##### ③ 重复子问题

> 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。



#### 3、实例剖析

■ 问题

> 有一个 n 乘以 n 的矩阵 w[n]\[n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？

![](/images/动态规划实例.png)



■ 一个模型分析 

> 1、从 (0, 0) 走到 (n-1, n-1)，总共要走 2* (n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都对应着向右或者向左走两种决策，每个阶段对应一个状态集合，符合一个模型。
>
> 2、我们把状态定义为 min_dist(i,j) ,其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。

![](/images/动态规划实例分析1.png)



■ 三个特征分析

> **重复子问题**：通过回溯算法画出递归树，所有的情况就会列出，有多种路线，符合重复子问题。
>
> **无后效性：**(i, j)  只能通过 (i-1, j)，(i, j-1) 这两个状态推导而来，之关心这两种状态，并不关心怎么这两种状态怎么达到的。仅仅允许往右往左移动，不能后退，前边的状态不会受到后边状态的改变，符合无后效性。
>
> **最优子结构：**以上两种状态其中一种肯定是最优解，所以每个决策的子问题都对应最优解，符合最优子结构。



![](/images/二维矩阵1.png)

![](/images/二维矩阵2.png)

■ 代码实现

```java
public int minDistDP(int[][] matrix, int n) {
  int[][] states = new int[n][n];
  int sum = 0;
  for (int j = 0; j < n; ++j) { // 初始化 states 的第一行数据
    sum += matrix[0][j];
    states[0][j] = sum;
  }
  sum = 0;
  for (int i = 0; i < n; ++i) { // 初始化 states 的第一列数据
    sum += matrix[i][0];
    states[i][0] = sum;
  }
  for (int i = 1; i < n; ++i) {
    for (int j = 1; j < n; ++j) {
      states[i][j] = matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);
    }
  }
  return states[n-1][n-1];
}

```



### 二、动态规划解题思路

> 两种思路，状态转移表法和状态转移方程法。



#### 1、状态转移法

■ **解决思路**

> ① 动态规划问题一般可以使用回溯算法和暴力搜索解决，定义状态。
>
> ② 画出每个状态的递归树，看是否有子节点问题。
>
> ③ 直接用回溯加 ”忘备录“ 解决重复子问题；状态转移法；



■ **状态转移**

> 画出状态表，根据决策先后过程，找出递归关系，分阶段填写表，然后将填写表这个过程翻译成代码，这就是动态规划代码了。



#### 2、状态转移方程法

> 某个问题通过子问题来递归求解，所谓的最优子结构，写递推公式，也就是**状态转移方程**。两种实现方式：**递归加 “忘备录” 、迭代递归**。



■ 状态转移方程

> **状态转移方程是解决动态规划的关键。**

```java
//状态转移方程
min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
```



■ 代码实现 (?)

```java
private int[][] matrix = {{1，3，5，9}, {2，1，3，4}，{5，2，6，7}，{6，8，4，3}};
private int n = 4;
private int[][] mem = new int[4][4];

// 调用 minDist(n-1, n-1);
public int minDist(int i, int j) { 
  if (i == 0 && j == 0) return matrix[0][0];
  if (mem[i][j] > 0) {
      return mem[i][j];
  }
    
  int minLeft = Integer.MAX_VALUE;
  if (j-1 >= 0) {
    minLeft = minDist(i, j-1);
  }
    
  int minUp = Integer.MAX_VALUE;
  if (i-1 >= 0) {
    minUp = minDist(i-1, j);
  }
  
  int currMinDist = matrix[i][j] + Math.min(minLeft, minUp);
  mem[i][j] = currMinDist;
  return currMinDist;
}

```



### 三、四种算法思想

> 贪心算法、分治算法、回溯算法、动态规划。



#### 1、回溯算法

> ① 能用贪心、动态规划解决的问题都能用回溯算法解决。
>
> ② 回溯穷举所有情况，指数级别的时间复杂度，只能解决小规模数据。



#### 2、动态规划

> ① 不是所有问题都能用动态规划，需要满足三个特征。
>
> ② 在重复子问题上，**动态规划和分治算法 **有区分。



#### 3、贪心算法

> ① 动态规划里边的一种特殊情况。
>
> ② 三个特征，最优子结构、无后效性、贪心选择性。
>
> ③ 每个局部的最优选择，构成全局的最优选择。



#### 4、分治算法

> ① 分割成子问题，不能有重复子问题。
>
> ② 动态规划高效的原因有很多重复子问题。



























