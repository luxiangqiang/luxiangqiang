---
title: 数据结构与算法之美【字符串匹配算法】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
---

小鹿带你走进数据结构与算法中的字符串匹配。

<!--more-->



## 数据结构与算法之字符串匹配算法

#### 1、一串匹配一串：

- 简单的两种字符串匹配算法，BF算法、RK算法。

- 难理解、但是更加高效的算法，BM算法、KMP算法。

#### 2、一串匹配多串：

- Trie 树和 AC 自动机。



## BF 算法和 RK 算法

> RK 算法是 BF 算法的优化。



### 一、BF 算法（Brute Force）

#### 1、定义

> BF（Brute Force） 算法也叫**暴力匹配算法**，也叫做**朴素匹配算法**。



#### 2、优点

> 简单、好懂。



#### 3、缺点

> 性能差。



#### 4、BF 算法思路

- 主串（n）：被查找的字符串。

- 模式串（m）：要查找的字符串。

我们在主串中，从起始位置到 0、1、2、 ... m-n 开始检查能否和长度为 m 的字符串匹配。最多需要比较 `n-m+1 `次。



#### 5、性能分析

> **最坏时间复杂度O(m*n)**：当主串为 `aaa...aaa` 时，模式串为 `aaaaab` 时，每次对比 `m` 个字符串，要比对 `n-m+1` 次。时间复杂度为 **`m*n+m²+1 `。**



#### 6、适用条件

> 虽然 BF 的时间复杂度非常高了，但是在实际开发中经常用到。因为绝大部分情况下，这种字符串匹配算法就够用了。

**① 大部分情况下，模式串和主串的长度不会太长。** 

**② 大多数情况下不会每次全匹配，总体来说算法的效率很高效的。**

**③ 代码简单，不易出错，思想简单，有 bug 容易暴露和修复。在满足性能的条件下，简单是首选，也就是所说的 KISS 原则（KISS 原则是指在设计当中应当注重简约的原则）。**



### 二、RK 算法(Rabin-Karp)

#### 1、由来

> 它是由 Rabin 和 Karp 两位发明者来命名的。



#### 2、BF 算法的不足

> 上边也讲到了，在匹配字符串的时候，需要一个字符一个字符的比较，最坏情况下的时间复杂度为 `O（m*n）`，需要引入哈希算法进行优化。



#### 3、RK 算法思路

**① 实现：**对 `（n-m+1）`个子串求哈希值，让模式串与逐个哈希值比较。

**② 分析：**

> 总体来说时间复杂度没有提高。

- 需要遍历子串计算哈希值（耗时长）；
- 模式串与子串的比较效率高了（耗时短）。

**③ 提高计算子串的哈希值的效率：**

- 要处理的字符串用 K（26） 进制进行表示（如 26 个字母，每个字母对应一个数字）；
- 然后转化为十进制作为哈希值（“cba” = "c" *26\*26 + "b"\*26 + "a"x1）；
- 规律：相邻的两个子串 s[i-1] 和 s[i] 有计算公式的交集，可以通过 s[i-1] 的哈希值计算出 s[i] 哈希值。
- 26^(m-1) 计算的值需要提前存储到数组中。

```javascript
h[i] = (h[i-1]-26^m-1 * (s[i-1]-'a')) * 26 + 26^0 * (s[i+m-1]-'a')
```



#### 4、性能分析

> 性能的分析我们从两部分入手，一部分是计算子串的哈希值，另一部分是与子串的哈希值进行比较。

① 计算子串的哈希值时，需要遍历所有的字符串，时间复杂度为O(n)；

② 子串与模式串进行哈希比较的操作时间复杂度为O(1)，总比较次数为 （n-m+1）,时间复杂度为O(n)；

③ 所以，RK 算法整体的时间复杂度为 O(n)。



#### 5、存在的问题

> 如果模式串很长，计算哈希值的长度超过计算机的存储的整数范围的话，应该怎么解决？计算哈希值存在哈希冲突又该怎么解决呢？



#### 6、问题解决

> 第一种优化方法，我们可以优化一下计算哈希值的算法就可以，如：字符串对应素数一次类推等。第二种优化方法，就让存在哈希冲突，当遇到哈希冲突的时候，再对应模式串和子串的本身进行比较。



#### 7、补充：

> 该方法还是主要取决于哈希算法的设计，我们还是要尽量**将冲突的概率控制的较低**，否则RK 算法的时间复杂度就会推化为 `O(n*m)`。总的来说，RK 算法的时间复杂度相对于 BF 算法效率还是很高的。

























