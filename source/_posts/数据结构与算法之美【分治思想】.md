---
title: 数据结构与算法之美【分治算法】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
---

小鹿带你走进数据结构与算法之美中的10大算法之一分治算法。

<!--more-->

### 一、分治算法

> 分治算法是一种处理问题的思想，递归是一种编程技巧。



#### 1、什么分治算法？

> 分治算法（divide and conquer），分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。



#### 2、每层递归实现的三个操作

- 分解：将原问题分解成一系列的子问题。
- 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
- 合并：将子问题的结果合并成原问题。



#### 3、分治算法满足的条件

- **可分解：**原问题与分解成的小问题具有相同的模式；
- **无关联：**原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别[【链接：动态规划与分治算法的区别】]()。
- **终止条件：**具有分解终止条件；
- **合并不能太复杂：**可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。



### 二、应用一：降低处理数据时间的复杂度

#### 1、问题

> 求 n 个数据的逆序度或有序度的个数。



#### 2、一般解决方法

> 每个数据一一比较，时间复杂度为 O(n²)。



#### 3、利用分治算法改进

> 将数组中的数据分为前后两半 A1、A2，分别计算 A1 、A2 的逆序个数 K1、K2，然后在计算 A1、A2 合起来的逆序个数 K3，那数组逆序个数等于 K1+K2+K3。



#### 4、分治算法合并函数

> 我们会用到归并排序中的一个非常关键的操作，就是将两个有序的数组合并成一个有序数组。在合并的同时计算逆序对个数，把这些计算出来的逆序对个数求和。

![](/images/分治合并函数.png)



#### 5、代码实现

```java

// 全局变量或者成员变量
private int num = 0;

// a 为要求逆序的数组，n 为数组的长度
public int count(int[] a, int n) {
  num = 0;
  //分治求逆序
  mergeSortCounting(a, 0, n-1);
  return num;
}

//分治思想
private void mergeSortCounting(int[] a, int p, int r) {
  if (p >= r) return;
  int q = (p+r)/2;
  //递归
  mergeSortCounting(a, p, q);
  mergeSortCounting(a, q+1, r);
  //合并求逆序数
  merge(a, p, q, r);
}

//合并两个有序的数组
private void merge(int[] a, int p, int q, int r) {
  int i = p, j = q+1, k = 0;
  int[] tmp = new int[r-p+1];
  while (i<=q && j<=r) {
    if (a[i] <= a[j]) {
      tmp[k++] = a[i++];
    } else {
      num += (q-i+1); // 统计 p-q 之间，比 a[j] 大的元素个数
      tmp[k++] = a[j++];
    }
  }
  while (i <= q) { // 处理剩下的
    tmp[k++] = a[i++];
  }
  while (j <= r) { // 处理剩下的
    tmp[k++] = a[j++];
  }
  for (i = 0; i <= r-p; ++i) { // 从 tmp 拷贝回 a
    a[p+i] = tmp[i];
  }
}
```



#### 6、练习题

- 二维平面上有 n 个点，如何快速计算出两个距离最近的点。

>

- 有两个 n* n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？

>



### 三、应用二：在海量数据的中的应用

> 分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。



#### 1、问题

> 给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。



#### 2、解决思路

> 可以利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，**不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度**。



#### 3、解决方案

> 给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。



#### 四、思考：为什么说 MapReduce 的本质就是分治思想？

> 1、实际上，MapReduce 框架只是一个任务调度器，底层依赖 **GFS（Google File System 是谷歌面向大量数据处理的文件分布式系统**）来存储数据，依赖 **Borg（是 Google 面向大规模集群的管理器）** 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。
>
> 2、尽管 MapReduce 的模型非常简单，**但是在 Google 内部应用非常广泛 **。它除了可以用来处理这种数据与数据之间存在关系的任务。比如 MapReduce 的经典例子，统计文件中单词出现的频率。
>
> 3、除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。



## 收获：

> ####  创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的的一个魅力所在。 

