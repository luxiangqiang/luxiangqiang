---
title: 数据结构与算法之美【递归】
categories:
- 数据结构
tags:
- 数据结构
password: digui
---

小鹿整理的递归调用的知识架构体系。

<!--more-->

## 目录

[TOC]

## 一、递归满足的三个条件

> 用一下三个条件来判断是否可以用递归来解决。

- 一个问题可不可以分解为多个问题的解。

- 该问题是否和子问题的求解思路相同。
- 该问题是否有终止条件。



## 二、如何编写递归代码

- 将问题分解为子问题。
- 然后寻找递归终止条件。
- 写出递推公式。
- 最终转化成递归代码。



## 三、怎么理解递归

> 1、如果试图想清楚递归的每个步骤，会让我们陷入思维误区，从而导致我们出现理解障碍。
>
> 2、我们应该这样想：假设问题 A 可以分解为 B、C、D 三个子问题，我们可以假设 B、C、D已经解决了，在此基础上考虑问题 A。我们只需要思考问题 A 和 问题 B、C、D 的关系即可，从而屏蔽掉递归细节。



## 四、递归的特点

### **优点**：

> 递归是一种高效、简洁的编码技巧，只要满足递归的三个条件我们就可以用递归代码来解决。



### 缺点：

#### 1、 问题一：递归警惕堆栈溢出

**■ 具体问题**

> 因为函数的调用是使用栈来保存临时变量的，每调用一个函数，我们就将临时的变量压入栈中，等函数执行完成之后，然后临时变量才出栈。因为我们的系统栈或者虚拟机栈空一般都不会很大，如果我们的递归规模很大，调用层次很深，递归过程中，函数的临时变量一直压入栈，导致堆栈溢出。

```java
Exception in thread "main" java.lang.StackOverflowError
```

**◆ 如何避免堆栈溢出？**

> 我们采用在代码中限制递归深度来解决，比如超过递归深度 1000 我们就不在往下递归，直接返回错误。

不足点：

> 因为允许最大递归深度跟当前线程剩余的栈空间大小有关，事先计算栈的大小。如果实时计算，代码过于复杂，影响代码的可读性。只能说对于比较小的递归深度可以用这种方法。



#### 2、问题二：递归警惕重复计算

**■ 具体问题**

> 如果我们有个递归代码是 f(n) = f(n-1) + f(n-2)，当 n 分别为 4 和 5 的时候，我们都要计算两次 f(3) 值，导致了递归重复计算，从而影响效率。



**◆ 如何解决？**

> 我们可以借助散列表来保存已经求解过的值，当我们递归计算该值的时候，我们先在散列表查找是否已经记录过该值，如果求解过了，我们就从散列表中取值，不需要递归重复计算。

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSovledList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSovledList.put(n, ret);
  return ret;
}
```



#### 3、问题三：递归的高空间复杂度

> 递归代码里有很多的函数带哦用，每次调用都要在栈中保存数据，因为在栈中保存数据都要额外的考虑这部分的开销，比如最简单的递归 f(n) = f(n-1)+1 ,空间辅助度并不是 O(1)，而是 O(n) 。





## 五、递归代码转换为非递归代码

> 递归有缺点也有优点，实际开发中，我们还是需要是否采用递归来实现。



#### ■ 递归：

> 递归是借助系统的栈和虚拟机的栈来实现的，所有的递归代码都可以用非递归代码来表示。



#### ■ 非递归：

> 非递归代码实现递归代码，只不过是用手动模拟入栈、出栈的过程，所以看上去并不是递归代码的样子。

不足：

> 非递归实现并没有解决递归的弊端，徒劳的增加了实现的复杂度。



### 六、递归的掌握程度

#### 1、编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2）

#### 2、编程实现求阶乘 n!

#### 3、编程实现一组数据集合的全排列