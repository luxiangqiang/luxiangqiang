---
title: 数据结构与算法之美【深度和广度优先搜索】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
copyright: true
---

![](/images/深度广度优先算法.png)

广度优先遍历算法和深度优先遍历算法！

<!--more-->



### 一、搜索算法

#### 1、关于搜索算法

> 1）所谓的算法都是基于数据结构之上的，因为图这种数据结构表达能力极强，所以像搜素算法，如：广度优先遍历和深度优先遍历都是**基于图**来实现的。
>
> 2）大部分的搜索的场景都可以抽象成**图 **。
>
> 3）广度和深度优先既可以对**无向图**也可以对**有向图**。



#### 2、搜索算法的基础（图）

> 图有两种存储方法，下面是用**邻接表**的方法存储实现**无向图**的代码。

```java
// 无向图
public class Graph { 
  // 顶点的个数
  private int v;
  // 邻接表中的散列表部分
  private LinkedList<Integer> adj[];
  // 初始化
  public Graph(int v) {
    this.v = v;
    adj = new LinkedList[v];
    for (int i=0; i<v; ++i) {
        // 为每个邻接表添加链表
        adj[i] = new LinkedList<>();
    }
  }
  // 无向图一条边存两次
  public void addEdge(int s, int t) { 
    adj[s].add(t);
    adj[t].add(s);
  }
}
```



### 二、搜索算法

#### ※ 适用条件

> 广度深度优先搜索算法属于暴力破解法，没有什么可以优化的。比其他的搜索算法 A*、IDE\* 要简单粗暴。‘
>
> **适用条件：**适合于状态空间不大（图不大）的情况下。



#### 1、广度优先搜索

###### ▉ 定义

> 广度优先搜索（Breadth-First-Search），简称 BFS。可以简单理解为以一点为中心，逐渐层层向外搜索，形如雷达。



###### ▉ 算法思路

> 1）判断起止点位置是否为同一位置（s == t）;
>
> 2）初始化变量  `visited（初始化为 0）`、`queue`、`prev（初始化 -1 ）`，并将起始点也进行初始化;
>
> - 起始点在 `visited[0]` 为 `true`。
> - 起始点入栈 `queue`。
>
> 3）先对第一层进行搜索终点顶点，出栈（上一层的顶点），遍历与上一层顶点相连接的顶点是否有我们要搜索的顶点 t。
>
> - 出栈
> - 根据邻接表遍历相邻顶点；
> - 判断该顶点是否访问过；
> - 如果没有法访问，记录路径；
> - 判断当前顶点是否为终止点（如果是，递归遍历路径）。
> - 否则，该节点标记为已经访问过，`visited[q] = true`。
> - 该顶点入栈（queue）                                                                                        

​        

###### ▉ 代码实现

> 相关变量：
>
> - s：起始点。
> - t：终止点。
> - visited：存储所有访问过的顶点（初始化为 0，访问过的顶点为 1 ）。
> - queue：存储每一层的顶点（依次出队进行判断来自哪一个顶点）。
> - prev：存储搜索路径（下标为当前顶点，存储的元素为当前下标顶点来自哪一顶点）。

```javascript
//广度优先搜索
public void bfs(int s, int t) {
  //判断起止点位置是否为同一位置（s == t）;
  if (s == t) return;
  //用来存储已访问的顶点（v为图的顶点个数）
  boolean[] visited = new boolean[v];
  //将第一个顶点置为true
  visited[s]=true;
  //定义一个队列，用来存储已经被访问但相连的顶点还没有被访问的顶点
  Queue<Integer> queue = new LinkedList<>();
  //现将第一个节点存储
  queue.add(s);
  //用来存储搜索路径（v为图的顶点个数）
  //将数组 prev 全部置为 -1
  int[] prev = new int[v];
  for (int i = 0; i < v; ++i) {
    prev[i] = -1;
  }
  // 出栈（上一层的顶点），遍历与上一层顶点相连接的顶点是否有我们要搜索的顶点 t。
  while (queue.size() != 0) {
   // 出栈
   int w = queue.poll();
   // 根据邻接表遍历相邻顶点
   for (int i = 0; i < adj[w].size(); ++i) {
      // 邻接表第 i 个元素
      int q = adj[w].get(i);
      // 判断当前顶点是否为终止点
      if (!visited[q]) {
        // 如果没有法访问，记录路径；
        prev[q] = w;
        //判断当前顶点是否为终止点（如果是，递归遍历路径）。
        if (q == t) {
          print(prev, s, t);
          return;
        }
        //否则，该节点标记为已经访问过
        visited[q] = true;
        //该顶点入栈（queue）                                     
        queue.add(q);
      }
    }
  }
}

// 递归打印 s->t 的路径
private void print(int[] prev, int s, int t) { 
  if (prev[t] != -1 && t != s) {
    print(prev, s, prev[t]);
  }
  System.out.print(t + " ");
}
```



###### ▉ 性能分析

> - **时间复杂度：**O（E）。最坏的情况就是图为连通图，且终止顶点距离起始点很远，需要遍历整个图，每个顶点和边都要至少访问一次，所以时间复杂度为 O(E + V)。因为连通图的边数一定大于等于顶点 V 。所以时间复杂度为 O（V）。
> - **空间复杂度： **O（V）。三个变量 visited、queue、prev 的空间永远超不出所有顶点的个数，所以空间复杂度为O（V）。



#### 2、深度优先搜索

###### ▉ 定义

> 深度优先搜索（Depth-First-Search），简称 DFS。所用到的算法为回溯算法，就像走迷宫， 每当发现前方的道路不通时，就会回到上一岔路口走另一条路。



###### ▉ 算法思路

> 1）初始化变量，初始化变量  `visited（初始化为 0）`、`prev（初始化 -1 ）` `found：默认为 false`。，并将起始点也进行初始化。
>
> - 起始点在 `visited[0]` 为 `true `。
>
> 2）判断 `found` 是否为 `true` （终止条件）。
>
> 3）判断起始顶点和终止顶点是否相等，如果相等，将 `found` 置为 `true` ，`return` 返回。
>
> 4）遍历邻接表，判断当前的顶点是否访问过。
>
> 5）如果未访问过，记录当前顶点。
>
> 6）以当前顶点为起点，继续递归调用。



###### ▉ 代码实现

> 相关变量：
>
> - s：起始点。
> - t：终止点。
> - found：标识已经找到终点顶点，不再继续递归。
> - visited：存储所有访问过的顶点（初始化为 0，访问过的顶点为 1 ）。
> - queue：存储每一层的顶点（依次出队进行判断来自哪一个顶点）。
> - prev：存储搜索路径（下标为当前顶点，存储的元素为当前下标顶点来自哪一顶点）。

```java

// 深度优先搜索
boolean found = false; 

public void dfs(int s, int t) {
  found = false;
  boolean[] visited = new boolean[v];
  int[] prev = new int[v];
  for (int i = 0; i < v; ++i) {
    prev[i] = -1;
  }
  recurDfs(s, t, visited, prev);
  print(prev, s, t);
}

private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
  if (found == true) return;
  visited[w] = true;
  if (w == t) {
    found = true;
    return;
  }
  for (int i = 0; i < adj[w].size(); ++i) {
    int q = adj[w].get(i);
    if (!visited[q]) {
      prev[q] = w;
      recurDfs(q, t, visited, prev);
    }
  }
}
```



###### ▉ 性能分析

> - 时间复杂度：O（E）。每条边最多访问两次，一次遍历，另一次回退。所以时间复杂度为 O（E）E：边。
> - 空间复杂度：O（V）。根据变量存储额外的空间大小为顶点的个数，所以空间复杂度为O（V）。



### 三、思考：如何找出社交网络中的三度好友关系？

> **答：**借助广度优先搜索，每一层是一度关系好友，用一个数组来记录每个顶点与起始顶点的距离，就可以找出三都好友。



### 四、实际运用

> 数据结构最难的不是掌握其原理，而是能够将实际问题和抽象问题转成成数据结构与算法。
>
> **举例：怎么将迷宫存储到计算机呢？ **
>
> 答：