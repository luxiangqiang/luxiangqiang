---
title: 前端设计模式之【装饰器模式】
categories:
- 设计模式
tags:
- 设计模式
---

设计模式之装饰器模式！

<!--more-->



### 一、什么是装饰器模式？

装饰器模式，又名装饰者模式。它的定义是“**在不改变原对象的基础上，通过对其进行包装拓展**，使原有对象可以满足用户的更复杂需求”。

> PS：在不影响原来功能基础上进行扩展。



### 二、应用场景

> 在实际的业务开发中，要对某一需求的功能进行扩展。**不用关心它现有的业务逻辑是啥样的，而是只对它原有的功能进行扩展，只关心扩展出来的新功能是如何实现的。**

- 如果直接去修改原代码 —— 违背了“**开放封闭原则**”。

- 往一个函数体中添加很多逻辑 —— 违背了“**单一职责原则**”。



#### 2.1 实例

旧业务逻辑

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>按钮点击需求1.0</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>点击打开</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 弹框创建逻辑，这里我们复用了单例模式面试题的例子
    const Modal = (function() {
    	let modal = null
    	return function() {
            if(!modal) {
            	modal = document.createElement('div')
            	modal.innerHTML = '您还未登录哦~'
            	modal.id = 'modal'
            	modal.style.display = 'none'
            	document.body.appendChild(modal)
            }
            return modal
    	}
    })()
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用
    	const modal = new Modal()
    	modal.style.display = 'block'
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
    	const modal = document.getElementById('modal')
    	if(modal) {
    	    modal.style.display = 'none'
    	}
    })
</script>
</html>
```

把旧逻辑进行抽离：

```javascript
// 将展示Modal的逻辑单独封装
function openModal() {
    const modal = new Modal()
    modal.style.display = 'block'
}
function closeModal() {
    const modal = document.getElementById('modal')
    if(modal) {
        modal.style.display = 'none'
    }
}
```

编写扩展功能：

```javascript
// 按钮文案修改逻辑
function changeButtonText() {
    const btn = document.getElementById('open')
    btn.innerText = '快去登录'
}

// 按钮置灰逻辑
function disableButton() {
    const btn =  document.getElementById('open')
    btn.setAttribute("disabled", true)
}

// 新版本功能逻辑整合
function changeButtonStatus() {
    changeButtonText()
    disableButton()
}
```

原代码扩展

```javascript
document.getElementById('open').addEventListener('click', function() {
    // 旧逻辑
    openModal()
    // 扩展功能
    changeButtonStatus()
})
```



#### 2.2 ES6 面向对象实现

> 装饰器模式一般将“被装饰者”传给“装饰器”，然后对其进行逻辑上的扩展。

```javascript
// 定义打开按钮
class OpenButton {
    // 点击后展示弹框（旧逻辑）
    onClick() {
        const modal = new Modal()
    	modal.style.display = 'block'
    }
}
```

```javascript
// 定义按钮对应的装饰器
class Decorator {
    // 将按钮实例传入
    constructor(open_button) {
        this.open_button = open_button
    }
    
    onClick() {
        this.open_button.onClick()
        // “包装”了一层新逻辑
        this.changeButtonStatus()
    }
    
    changeButtonStatus() {
        this.changeButtonText()
        this.disableButton()
    }
    
    disableButton() {
        const btn =  document.getElementById('open')
        btn.setAttribute("disabled", true)
    }
    
    changeButtonText() {
        const btn = document.getElementById('open')
        btn.innerText = '快去登录'
    }
}

const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```



### 3、ES7 中的装饰器

> 在 ES7 中的语法中完全支持了装饰器。

#### 3.1 实例

```javascript
// 装饰器函数，它的第一个参数是目标类
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到 Button 类上
@classDecorator
class Button {
    // Button类的相关逻辑
}

// 验证装饰器是否生效
console.log('Button 是否被装饰了：', Button.hasDecorator)
```



#### 3.2  不支持的 ES7 语法

因为浏览器和 Node 不支持 ES7 的语法，所以我们需要借助 Babel 进行转码。需要安装 Babel 及装饰器相关的 Babel 插件。



安装：

```javascript
npm install babel-preset-env babel-plugin-transform-decorators-legacy --save-dev
```

编写配置文件.babelrc：

```javascript
{
  "presets": ["env"],
  "plugins": ["transform-decorators-legacy"]
}
```

安装全局 Babel 命令行工具：

```
npm install babel-cli -g
```

 转码命令：

```
babel test.js --out-file babel_test.js
```



### 3.3 装饰器的原理

- 装饰器的基本定义 —— 定义装饰器函数
- 将“被装饰者”传给“装饰器” —— 函数传参和调用



#### 第一部分：函数传参 && 调用

##### 3.1.1 类装饰器的参数

```javascript
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}
// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}
```

> target 就是“被装饰者”本身。



##### 3.1.2 方法装饰器的参数

```javascript
function funcDecorator(target, name, descriptor) {
    let originalMethod = descriptor.value
    descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}   
```

- `target` 为 `Button.prototype`，类的原型对象，因为 `onclick` 方法在按钮的原型对象上。

为什么不直接修饰 Button 呢？

> 当我们装饰器安装到实例上的时候，实例并不存在，所以只能装饰到它的原型对象上。



##### 3.1.3 装饰器的调用

装饰器的运行是在代码**编译阶段**就执行了。



#### 第二部分：装饰器的属性

> 装饰器至少需要三个参数。

- 参数一：`target` —— 被装饰的目标对象 
- 参数二：`name` —— 修饰目标对象的属性名 
- 参数三：`descriptor` —— 属性描述对象(描述对象属性的属性)  —— 如果传递的是函数，则 value 则为该函数的函数体内容。
  - 数据描述符：
    - `value` :  存放属性值，默认为 `undefined`
    - `writable` :  属性的值是否可以改变，默认 `true`
    - `enumerable` :  表示属性是否可枚举，默认为 `true` 
  - 存取描述符：
    - `get `方法
    - `set` 方法

```javascript
function funcDecorator(target, name, descriptor) {
    let originalMethod = descriptor.value
    descriptor.value = function() {
    console.log('我是Func的装饰器逻辑')
    return originalMethod.apply(this, arguments)
  }
  return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}  
```

拿到了 `descriptor`，就相当于拿到了目标方法的控制权。通过修改 descriptor，我们就可以对目标方法的逻辑进行拓展。

> 我们通过 `descriptor` 获取到了原函数的函数体`（originalMethod）`，把**原函数**推迟到了**新逻辑**（console）的后面去执行



### 3.4 装饰器模式的适用条件

> 装饰器最大的特点就是强大的**灵活性**和**复用性**，不依赖于任何的逻辑。



**适用条件：**

- 需要用到**反复**出现的**扩展**逻辑时，应该想想是不是用到装饰器来解决，避免大量的**复制粘贴**。

- 非常赞的装饰模式库 ——  [core-decorators](https://github.com/jayphelps/core-decorators)





































































