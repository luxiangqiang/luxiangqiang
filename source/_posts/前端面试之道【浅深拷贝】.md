---
title: 前端面试之【深浅拷贝】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试

---

深拷贝终级解决方案！

<!--more-->



### 一、什么是浅拷贝？

> 实深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型赋值，则会进行地址的拷贝，最终两个变量指向同一份数据

```javascript
// 基本类型
var a = 1;
var b = a;
a = 2;
console.log(a, b); // 2, 1 ，a b指向不同的数据

// 引用类型指向同一份数据
var a = {c: 1};
var b = a;
a.c = 2;
console.log(a.c, b.c); // 2, 2 全是2，a b指向同一份数据
```

对于引用类型，会导致a b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个。



### 二、什么是深拷贝？

> 那么如何切断 a 和 b 之间的关系呢，可以拷贝一份 a 的数据，根据拷贝的层级不同可以分为浅拷贝和深拷贝，浅拷贝就是只进行一层拷贝，深拷贝就是无限层级拷贝。



#### 2.1 浅拷贝不能解决的问题

> 可以简单的解决第一层应用类型问题，但是如果多层的对象嵌套就不适用。

```javascript
var a1 = {b: {c: {}};
```

```javascript
function shallowClone(source){
    var target = {};
    for(var i in source){
        if(source.hasOwnProperty(i)){
           	target[i] = source[i];
         }
    }
    return target;
}
```



#### 2.2 实现一个简单深拷贝

> 一个简单的深拷贝就是使用浅拷贝 + 递归。

```javascript
function clone(source) {
    var target = {};
    for(var i in source) {
        if (source.hasOwnProperty(i)) {
        	if(typeof source[i] === 'object'){
               	 target[i] = clone(source[i])
             }else{
                 target[i] = source[i]
             }
         }
	}		
    return target;
}
```

**缺点：**

- 没有检验参数。

  ```javascript
  
  ```

- 没有判断是否为对象类型。

  ```javascript
  function clone(source) {
      if (!isObject(source)) return source;
  }
  ```

- 没有考虑其他对象类型（数组）的兼容性，还有 ES6 的 set, map, weakset , weakmap。

- 递归爆栈





























