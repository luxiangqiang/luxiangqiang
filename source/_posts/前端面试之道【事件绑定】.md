---
title: 前端面试之【事件绑定】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试
---



js 事件的处理程序！

<!--more-->

[TOC]

## 事件绑定（事件处理程序）

### 一、HTML 事件绑定

> 最直接的事件绑定就是在 ` HTML` 上做处理，显式的为按钮绑定 `click` 事件，用户点击按钮就会触发事件。



#### 1、事件绑定定义

1）`onClick` 特性的值是 `javascript` ，所以不能在内使用未转义的 `HTML` 语法字符。

2）`onClick` 也可以调用页面定义的脚本（函数名）。也可以是外部文件，事件处理程序有权访问全局变量。

3）`onClick` 内定义的函数自带的一个 `event`变量存储事件对象，通过 `event` 变量可以访问事件对象的属性值（也可以使用 `this` ，`this` 指向事件对象本身）。

```javascript
//1、onClick 内不能使用未转义的 HTML 语法字符（单引号）
<input type='button' value="点击我" onclick="alert(&quot;Clicked&quot;)" />
```

```javascript
//2、调用页面其他地方的脚本
<input type='button' value="点击我" onclick="showMessage()" />
<script>
	showMessage = ()={
        alert("Hello Word")
	}
</script>
```

```javascript
//3、event 事件对象
<!--两个都输出‘点击我’-->
<input type='button' value="点击我" onclick="alert('event.value')" /> 
<input type='button' value="点击我" onclick="alert(this.value)" />
```



#### 2、存在的缺点

###### ▉ 缺点

> 1）用户在 `HTML` 元素一出现就点击元素触发相应的事件，但可能改事件还没有初始化（尚未具备执行的条件），导致报错。
>
> 2）`HTML` 和 `Javascript` 紧密耦合。修改事件时，会修改两处，所以一般不使用 `HTML` 事件绑定。



###### ▉ 解决

> 1）加入 `try catch` 语句，在脚本函数没有被解析之前就点击了元素，就会引出错误。该错误不会让用户看见，而是被捕获。
>
> 2）不使用 `HTML` 事件绑定，而是转向使用 `javascript` 执行事件处理程序。

```javascript
<input type='button' value="点击我" onclick="try{showMessage();}catch(ex){}" />
```



### 二、DOM0 级事件绑定

> 通过将一个函数的值赋值给事件处理程序的属性来绑定事件。
>
> 1）简单
>
> 2）跨浏览器



### 1、事件绑定定义

> 1）先获取某个拥有事件处理程序属性的对象（属性一般都是小写，如 `onclick`），然后将该属性指向一个事件处理函数。
>
> 2）该方法被认为定义了元素的方法，处理事件是在该元素的作用域执行的，所以 `this`  指向该元素（可以通过 `this` 访问该元素的任何属性和方法）。
>
> 3）DOM0 级事件处理是在事件的**冒泡阶段**进行绑定的。
>
> 4）删除元素的绑定事件。

```javascript
var btn = documentElementById("myBtn");
btn.onclick = function(){
    alert('HelloWord')
}
```

```javascript
var btn = document.ElementById("myBtn");
btn.onclick = function(){
    alert(this.id) // 输出 myBtn
}
```

```javascript
btn.onclick = null;
```



### 三、DOM2级事件绑定

> DOM2 级事件处理程序定义了两个方法，分别是处理事件和删除事件的两个操作：`addEventListener()` 和 `removeEventListener()` 。



#### 1、事件绑定定义

> 1）可以添加多个事件处理函数。
>
> 2）移除函数必须和移除函数相同的参数。并且 `addEventListener()` 函数必须使用 `removeEventListener()` 才能移除。

该函数接受三个参数：

- 要处理的事件名；
- 绑定的函数；
- 布尔值（`true`：表示**捕获阶段**调用事件程序，`false`：表示**冒泡阶段**调用事件程序）；

```javascript
// 为 btn 绑定了两个事件处理函数，按顺序执行
btn.addEventListener('click',function(){
    alert('HelloWord') // 先执行 HelloWord
},false)
btn.addEventListener('click',function(){
    alert(this.id)  // 再执行 ID
},false)
```

```javascript
// 注意：这里的 function 和上方不是同一个函数，所以移除失败
// 通过将同一个函数赋值给统一的变量，就可以视作为统一参数
btn.removeEventListener('click',function(){
    alert(this.id)
},false)
```



#### 2、兼容性

> 1）DOM2 级事件处理程序兼容的浏览器有 `IE9、Firefox、Safari、Chrome` 和 `Opera `。
>
> 2）大多情况下，都将事件处理程序添加到**冒泡阶段，为了最大限度的兼容各种浏览器**。



### 四、IE 事件绑定

> 1）IE 实现了与 DOM 类中的两个方法：`attachEvent()` 和 `detachEvent() ` 。
>
> 2）IE8 版本之前所有的事件绑定都是在冒泡阶段。
>
> 3）IE 与 `DOM0` 级绑定事件的区别在于事件的作用域是「**全局变量**」（ `this` 指向 `window` 作用域）。
>
> 4）可以通过 `attach` 添加多个事件，且「**执行顺序和 `DOM2` 级相反**」。
>
> 5）`detachEvent` 删除事件也必须提供相同的参数，匿名函数无效。

```javascript
btn.attach('onclick',function(){
    alert('HelloWord')
},false)
```

```javascript
btn.attach('onclick',function(){
    alert('HelloWord') // 再执行 HelloWord
},false)
btn.attach('onclick',function(){
    alert(this.id)  // 先执行 ID
},false)
```

```javascript
// 移除无效
btn.detachEvent('onclick',function(){
    alert(this.id)
},false)
```



### 五、跨浏览器的事件绑定

> 为了能够保证事件绑定能在大多数的浏览器下运行，一般有两种方式：
>
> 1）使用能够隔离浏览器差异的 javascript 库。
>
> 2）自己开发合适的功能，使用能力检测，保证能够在大多数的浏览器下运行。
>
> 3）该程序没有考虑到浏览器的所有问题。如：在 IE 中的作用域问题。

```javascript
var EventUtil = {
    // 绑定事件
    addHandler: function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type, handler, false);
        }else if(element.attachEvent){
            element.attachEvent('on'+ type,handler)
        }else{
            element['on' + type] = handler;
        }
    },
    // 解除绑定
    removeHandler: function(element,type,handler){
        if(element.addEventListener){
            element.removeEventListener(type, handler, false);
        }else if(element.attachEvent){
            element.detachEvent('on'+ type,handler)
        }else{
            element['on' + type] = null;
        }
    }
}
```



### 小结

#### 1、`IE` 与 `DOM0/DOM2` 之间的区别

> 1）`IE` 与 `DOM0` 比较：`IE` 事件绑定时，`this` 指向全局变量 `window`，而 DOM0 的 `this` 却指向事件本身。
>
> 2）`IE` 与 `DOM2` 比较：`IE` 与 `DOM2` 相比，`DOM2` 中的添加多个事件执行的顺序（正序）与 `IE` 绑定多个事件执行的顺序相反（逆序）。

#### 2、兼容性

> 1）`IE8` 之前的只有冒泡阶段，所以  `IE8` 之前的事件绑定都是在冒泡阶段完成的（`DOM0` 级以及 IE 事件绑定）。
>
> 2）`DOM2` 事件第三个参数可以选择绑定阶段（冒泡还是捕获），因为 IE8 之前只有冒泡阶段，所以 `DOM2 `级别的事件绑定只适用于 ` IE9+` 。



## 事件对象

> 当触发 DOM 的某个事件时，就会产生一个 `event` 对象，对象中包含着与事件相关信息。



### 一、DOM 中的事件对象

#### 1、this、currentTarget、target

> 1）当事件直接绑定到目标事件时，三者的值相同。
>
> 2）当事件绑定到目标事件的父节点上，`this`  与` currentTarget` 的值与 `target` 的值不相同。
>
> 当点击该按钮时，事件的绑定是按钮的父节点，所以目标对象 `target` 是指向按钮元素的（`click` 的真正目标），由于按钮没有绑定事件处理程序，所以 `click` 事件冒泡到 `document.body` 事件才得到处理 。

```javascript
// 将事件绑定 btn 按钮的父节点上
document.body.onclick = (event)=>{
    alert(event.target === document.getElementById('btn')) // true
}
```



#### 2、处理多个事件

> 为了能够减少代码量，通过 `event.type` 来确定一个函数处理多个事件。

```javascript
handler = (event)=>{
    switch(event.type){
        case 'click':
            //要处理的点击事件
            break;
        case 'mouseover':
            // 要处理的鼠标进入事件
            break;
        case 'mouseout':
            // 要处理的鼠标滑出事件
    }
}

btn.onclick = handler;
btn.mouseover = handler;
btn.mouseout = handler;
```



#### 3、阻止默认的事件行为

> 可以通过使用 `preventDefault()` 方法来取消默认的行为（必须设置属性 `cancelable` 为 `true`），如 `a `标签的链接事件，阻止了跳转 `href` 的链接。

```javascript
link.onclick = (event)=>{
    event.cancelable = true;
    event.preventDefault();
}
```



#### 4、立即停止事件的传播

> 通过设置 `stopPropagation()` 方法立即停止在 DOM 层次中的传播（停止事件的捕获或冒泡）。
>
> 1）通过这种方式可以避免发生在父节点绑定的事件处理程序。



### 二、IE 中的事件对象

> IE 中事件对象 `event` 有一种不同的方式。
>
> 1）DOM0 级：`event` 作为 `window` 的一个属性。
>
> 2）attatach 添加的：传入一个 event 对象。

```javascript
 btn.onclick = ()=>{
     let event = window.event;
     alert(event.type)
 }
```



#### 1、srcElement

> `srcElement` 属性相当于 `DOM` 中的 `target` 属性，用来确定事件目标对象的。
>
> 1）因为事件处理程序的作用域是根据指定它的方式来确定，所以 `this` 不一定指向目标对象。因此我们通常用 `srcElement` 来替换。

```javascript
btn.onclick = ()=>{
    alert(window.event.srcElement === this) // true
}

btn.attachEvent('onclick',(event)=>{
    alert(event.srcElement === this) // false
})
```



#### 2、阻止默认的事件行为

> 只要将 `returnValue` 设置为 `false` 就可以阻止默认的行为。

```javascript
link.onclick = (event)=>{
    window.event.returnValue = false;
}
```



#### 3、立即停止事件的传播

> 设置 `cancelBubble` 属性即可停止事件的传播。由于 IE 中只有冒泡阶段，所以也只能阻止冒泡阶段在 DOM 层次中的传播。

```javascript
btn.onclick = (event)=>{
    window.event.cancelBubble  = true;
}
```



### 三、跨浏览器的事件对象

> 不同浏览器中的 Event 对象是不同的，所以要写一个跨浏览器的事件对象。



#### 1、定义 Event 事件

```javascript
let EventUtil = {
    // 绑定事件
    addHandler: function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type, handler, false);
        }else if(element.attachEvent){
            element.attachEvent('on'+ type,handler)
        }else{
            element['on' + type] = handler;
        }
    },
    // 解除绑定
    removeHandler: function(element,type,handler){
        if(element.addEventListener){
            element.removeEventListener(type, handler, false);
        }else if(element.attachEvent){
            element.detachEvent('on'+ type,handler)
        }else{
            element['on' + type] = null;
        }
    },
    // 获取事件对象
    getEvent: function(event){
        return event ? event : window.event;
    },
    // 获取事件目标对象
    getTarget: function(event){
        return event.target || event.srcElement;
    },
    // 阻止事件
    preventDefault: function(event){
        if(event.preventDefault){
            event.preventDefault();
        }else{
            event.returnValue;
        }
    },
    // 立即停止事件传播
    stopPropagation: function(event){
        if(event.stopPropagation){
            event.stopPropagation();
        }else{
            event.cancelBubble = true;
        }
    }
}
```



#### 2、调用 Event 对象事件

> 1）`getEvent()`
>
> 2）`getTarget()`
>
> 3）`preventDefault（）`
>
> 4）`stopPropagation（）`

```javascript
// IE 不存在 event (undefined)就返回 window.event
btn.onclick = (event)=>{
    event = EventUtil.getEvent(event);
}
```

```javascript
// 获取目标对象
btn.onclick = (event)=>{
    event = EventUtil.getEvent(event);
    let target = EventUtil.getTarget(event);
}
```

```javascript
// 阻止事件
btn.onclick = (event)=>{
    event = EventUtil.getEvent(event);
    let target = EventUtil.preventDefault(event);
}
```

```javascript
// 立即停止事件传播
btn.onclick = (event)=>{
    event = EventUtil.getEvent(event);
    let target = EventUtil.stopPropagation(event);
}
```



### 小结

> 1）`DOM0` 级别的 `Event` 存在 `window` 对象中，而 `DOM2` 和 `IE` 处理事件程序中的 `Event` 对象是当做参数传入的。
>



