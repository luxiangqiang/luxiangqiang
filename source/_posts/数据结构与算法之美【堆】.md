---
title: 数据结构与算法之美【堆】
categories:
- 数据结构
tags:
- 数据结构
copyright: true
---

为什么说堆排序没有快速排序快？

<!--more-->



### 一、什么是堆？

> 堆是一个完全二叉树；堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。



#### 1、堆的分类

> 大顶堆：每个节点的值**大于等于**子树每个节点值的堆。
>
> 小顶堆：每个节点的值**小于等于**子树中每个节点值的堆。



#### 2、堆的特点

> - 堆是一个完全二叉树；
> - 堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。



### 二、如何实现一个堆？

#### 1、堆的存储

> 数组中下标为 **i** 的节点的左子节点就是下标为 **i*2** 的节点，右子节点就是下标为 **i * 2+1** 的节点，父节点就是下标为 **i/2** 的节点。



#### 2、堆中插入一个数据

> 从下往上进行堆化。



##### ■ 代码实现

```java
/**
 * 时间:2019/2/28
 * 功能:插入数据
 * 分析:
 * 1)插入到数组尾部(堆最后的节点)
 * 2)自下而上堆化(比较和交换)
 * 边界条件:
 * 1)判断是否已经堆满
 * @param data 插入的数据
 */
public void insert(int data) {
    //判断堆是否已满
    if(count >= n) return;
    //计数+1(下标 0 不存储数据)
    count++;
    //将数据插入最后节点
    a[count] = data;

    //自下往上堆化
    int i = count;
    //判断插入数据的根节点是否大于 0 且插入的数据是否大于根节点数据
    while(i/2 > 0 && a[i] > a[i/2]) {
        //交换下标为 i 和 i/2 的元素
        swap(a,i,i/2);
        //继续堆化比较交换
        i = i/2;
    }
}
```



#### 2、堆中删除一个数据

> 把堆顶的元素删除之后，将最后一个节点放到堆顶，然后按照上边的方法进行交换，直到父子节点满足大小关系为止，从上往下堆化方法。



##### ■ 代码实现

```java
   /**
	 * 时间:2019/2/28
	 * 功能:删除堆顶数据
	 * 分析:
	 * 1)判断堆是否为空
	 * 2)数组长度 -1
	 * 3)从下标为 1 的数据从上到下进行堆化
	 * 4)在左右节点中选出最大元素进行交换
	 * 边界分析:
	 * 1)判断堆是否为空
	 * 2)堆中是否只有一个元素
	 * @param data 要删除的数据
	 */
	public void removeMax() {
		//如果堆中无数据,则返回
		if(count == 0) return;
		//删除堆顶的第一个元素,与最后一个元素进行交换
		a[1] = a[count];
		//数组长度-1
		count--;
		//从上到下进行堆化
		heapify(a,count,1);
	}
	/**
	 * 功能:从上自下堆化
	 * @param a 堆化的数组
	 * @param count 当前堆中的数据
	 * @param i 
	 */
	private void heapify(int[] a,int n,int i) {
		while(true) {
			int maxPos = i;
			//选择子节点中最大的数据作交换
			if(i*2 < n && a[i] < a[i*2]) maxPos = i*2;
			if(i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
			
			//如果堆顶只剩一个元素,break
			if(maxPos == i) break;
			
			//进行交换
			swap(a, i, maxPos);
			//继续往下堆化
			i = maxPos;
		}
	}
```



### 三、堆插入、删除的时间复杂度分析

>  n 个节点的完全二叉树，树的高度不会超过 log2n，堆化的过程就是顺着路径进行交换的过程，时间复杂度与树的高度成正比，也就是 **O(logn)**。



### 四、堆排序

> 借助于堆这种数据结构实现的排序算法，就叫作**堆排序**。这种排序方法的时间复杂度非常稳定，是 **O(nlogn)**，并且是原地排序算法。



#### 1、 建堆

###### **■ 方法一：**

> 借助前边讲的堆插入一个数据元素，就好比从1到n ，插入n个数据。数组操作就是**从前到后**处理数据，堆排序需要**从下向上堆化**。



######  ■ 方法二：（最常用的方法）

> 与第一种截然相反，数组从后向前处理（数组的中间位置），堆排序是**从上到下堆化**。

![](/images/建堆从上到下.png)



###### ■ **代码实现**

```java
	/**
	 * 时间:2019/2/28
	 * 功能:建堆
	 * 1)取数组中间从后往前
	 * @param a 数组
	 * @param n 数组的大小
	 */
	public static void buildHeap(int[] a,int n) {
		for (int i = n/2; i >= 1; i++) {
			heapify(a,n,i);
		}
	}
	/**
	 * 功能:从上自下堆化
	 * @param a 堆化的数组
	 * @param count 当前堆中的数据
	 * @param i 
	 */
	private static void heapify(int[] a,int n,int i) {
		while(true) {
			int maxPos = i;
			//选择子节点中最大的数据作交换
			if(i*2 < n && a[i] < a[i*2]) maxPos = i*2;
			if(i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
			
			//如果堆顶只剩一个元素,break
			if(maxPos == i) break;
			
			//进行交换
			swap(a, i, maxPos);
			//继续往下堆化
			i = maxPos;
		}
	}
```

> **注意：**
>
> 从 n/2 开始堆化，下标是 n/2 +1 到 n 的结点都是叶子节点，不需要堆化。**对于完全二叉树来说，下标从** 
>
> n/2+1到n的节点都是叶子节点**。**



###### ■ **建堆的时间复杂度分析**

![](/images/建堆时间复杂度.png)

> 1、堆化的时间复杂度为 O(logn)，需要堆化 n/2 + 1个结点，时间复杂度为 O(nlogn)，不够精确，叶子节点并没有参与堆化。
>
> 2、需要在倒数第二层进行堆化，所以将每层堆化的结点数和每层的高度相乘总体相加得出时间复杂度。
>
> 3、**建堆的时间复杂度为 O(n)。 **



#### 2、排序

> 借助删除堆顶元素的方法来对堆元素进行排序。



###### ■ **代码实现**

```java
	/**
	 * 功能:排序
	 * @param a 数组
	 * @param n 数据的个数
	 */
	public static void sort(int[] a, int n) {
	  //建堆
	  buildHeap(a, n);
	  //堆排序
	  int k = n-1;
	  while (k > 1) {
	    //交换堆顶元素和最后一个元素
	    swap(a, 1, k);
	    //堆元素减一
	    --k;
	    //从上向下进行堆化
	    heapify(a, k, 1);
	  }
	}
```



###### ■ 堆排序的时间复杂度分析

> 建堆的时间复杂度为  O(logn) ，n 个结点排序的**时间复杂度为 O(nlogn)**。



#### 3、堆排序的性能

###### **▍堆排序是否为原地排序算法？**

> **答：是**
>
> **分析：**数据交换只需要变量级别的临时空间，所以空间复杂度为 O(1)。



###### **▍堆排序是否为稳定排序算法？**

> **答：不是**
>
> **分析：**在整个堆排序的过程中，存在将堆的最后一个节点和堆顶节点的互换的操作，所以有可能改变相同数据的原始相对顺序。所以堆排序不是稳定排序。



###### ▍堆排序的时间复杂度？

> **答：O(nlogn)**
>
> **分析：**建堆的时间复杂度为 O(n)，堆排序的时间复杂度为 O(nlogn)，所以总的**时间复杂度为 O(nlogn);**





### 五、为什么快速排序比堆排序性能好？

###### 1、堆排序数据访问的方式没有快速排序友好

> 对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。堆排序访问元素会跳这访问，不像快速排序一样局部顺序访问，这样对 CPU 缓存不友好。



###### 2、对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

> 堆排序经过建堆，会将数据的逆序度降低，本来一组数据是有序的，经过建堆之后就会变得无序。而快速排序整个排序过程中，数据交换的次数不会比逆序度多。



### 六、扩展思考

###### 1、对于完全二叉树来说，下标从 n/2 + 1 到 n的都是叶子节点，怎么推导出出来的？

>



### 七、堆的应用

#### 1、应用一：优先级队列

##### ■ **定义**

> 顾名思义，队列是先进先出，而这里的优先级队列的出队顺序不是先进先出，而是按照优先级来的，优先级越高就先出队。
>



##### ■ **思路**

> 用堆实现优先级队列是最直接、最高效的一种方式，因为堆和优先级队列最为相似。一个堆可以看成一个优先级队列，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列删除一个元素，就相当于取出一个堆顶元素。



##### ■ 优先级队列一：合并有序小文件

###### ▍问题：

> 假设有 100 个小文件，每个文件的大小是 100 MB，每个文件存储的都是有序的字符串。希望将这些 100 小文件合并成一个有序的大文件。



###### ▍解决：

> 归并排序中的合并函数，先分别从 100 个文件中各提取一个字符串，放入数组中，然后比较大小，选择最小的字符串合并到大文件中，然后在数组中删除改元素，从该文件中重新选择一个字符串放到数组中重新比较。



###### ▍不足;

> 用数组其实不是最高效的方法，我们需要在数组中遍历所有元素进行比较，比较耗时。



###### ▍优化：

> 利用小顶堆来实现。



######  ▍时间复杂度分析：

> 1、数组的实现方式：对数组删除、插入以及比较取出最小值操作时间复杂度为 O(n)。
>
> 2、小顶堆实现方式：每个堆总数据为 100 ，删除堆顶、往堆中插入数据的**时间复杂度为 O(logn)**。



##### ■ 优先级队列二：高性能定时器

###### ▍问题：

> 假设有一个定时器，定时器维护了很多任务，每个任务都设定了出发的时间点，定时器每过一秒都要扫描一下任务，判断当前的任务有没有达到执行时间的，如果达到了，就拿出来执行。



###### ▍解决：

> 小顶堆来解决，小顶堆存放的数据就是任务时间和当前时间差。
>
> 1、堆顶元素就是最先执行的任务。
>
> 2、堆顶的任务执行完毕之后，然后重新计算差值，得出首任务。



#### 2、应用二：利用堆求 Top K

###### ▍问题：

> 如何在包含 n 个数据的数组中，查找前 K 大数据呢？1、静态数据；2、动态数据。



###### ▍ 静态数据：

> 1、首先维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。
>
> 2、如果取出的数据比堆顶大，我们呢就将堆顶元素删除，然后将数据进行插入。
>
> 3、如果比堆顶的元素小，我们就不做处理。
>
> 4、将数组全部遍历完成之后，堆中的数据就是前K大数据**。



###### ▍静态数据复杂度

> 遍历数组时间复杂度为 O(n)，一次堆化时间复杂度为 O(logK) 。
>
> 1、最坏的情况下：数据从小到大排列，时间复杂度为 O(nlogK) 。
>
> 2、最好的情况下：数据从大到小排列，时间复杂度为 O(n)。



###### ▍动态数据复杂度

> 实时的求前 k 大数据。
>
> 1、一直维护一个 K 大小的小顶堆，**当有数据被添加进来的时候**，就拿着它与堆顶的元素对比。如果比堆顶元素大，我们就删除堆顶元素，将此元素进行插入，如果比堆顶小，我们就不做任何处理。



#### 3、堆的应用三：利用堆求中位数

###### ▍问题：

> 如果数据的个数是奇数的时候，中位数为 n/2 + 1。如果是偶数的话，中位数有两个，分别为  n/2  和  n/2 + 1。如何求动态数据集合的中位数?



###### ▍静态数据求中位数：

> 关于静态数据，中位数是固定的，我们先可以进行排序，第 n/2 个数据就是中位数。
>
> **缺点：**排序的代价有点大。
>
> **优点：**边际成本会很小。



###### ▍动态数据求中位数：

![](/images/堆求中位数.png)

> 1、需要维护两个堆，一个大顶堆，一个是小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据。且小顶堆的数据都大于大顶堆的数据。
>
> 2、如果有 n 个数据，n 是偶数，从小到大排序，那前 n/2 个数据存储在大顶堆中,也就是**堆顶就是中位数**。如果 n 是奇数，大顶堆就存储 n/2 + 1个数据，小顶堆就存储 n/2 个数据。
>
> 3、如果新加入的数据**小于等于**大顶堆的堆顶元素，就将这个新数据插入到大顶堆；如果新加入的数据**大于等于**小顶堆的堆顶元素，就将这个新数据插入到小顶堆。
>
> 4、插入新数据会导致两个堆的数据不符合前边约定的情况，导致 n 是偶数的时候，两个堆的数据都是 n/2 个数据。奇数大顶堆有 n/2 + 1 个数据，小顶堆有 n/2 个数据。
>
> 5、可以不停的移动一个堆顶的元素向另一个堆顶移动，这样就可以调整了。



###### ▍时间复杂度分析

> 1、插入数据需要涉及到堆化，时间复杂度为O(logn) 。
>
> 2、求中位数直接返回堆顶元素就行了，所以时间复杂度为 O(1)。



### 八、本节思考：如何快速获取到Top 10最热门的搜索关键词？

###### ▍问题：

> 有 10 亿个搜索关键字的日志文件，如何快速获取 Top 10 的搜索关键词呢？
>



###### **▍方法选择**

> 1、一般用 MapReduce 去解决，解决思想：[请跳转《哈希算法》中的数据分片的应用解决方法。]()
>
> 2、如果是单机操作，上述方法就不能使用了。



###### ▍分析：

> 1、关键词是用户重复输入搜索的，首先要统计关键词出现的次数，选用一些支持快速实现增、删、改、查的数据结构（散列表、平衡二叉树等）。
>
> 2、散列表来实现，顺序遍历 10 亿关键词。散列表中不存在插入数据计数1，存在关键字就+1.
>
> 3、建立一个大小为 10 的小顶堆，遍历散列表，关键词出现的次数和顶堆进行比较，如大于顶堆元素，删除顶堆元素，插入这条数据。



###### ▍附加条件：

> 10 亿的关键词很多，假如我们不重复的关键词为 1 个亿，每个搜索关键词的长度为 50 个字节，需要 5 G 的内存空间，散列表需要避免冲突，不会选择太大的装载因子，所以消耗内存空间更多。假设机器只有 1 G 的存储空间，无法一次性将数据加载到内存中。



###### ▍改进：

> 1、使用**哈希算法**的相同数据经过哈希算法得到相同的哈希值一样的特性，通过这一个特性，将 10 亿个关键词通过哈希算法分片到 10 个文件中。
>
> 2、创建 10 个空文件，00,01,02...09，遍历 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后同 10 取模，
>
> 3、每个文件只有 1 亿个关键词，去掉重复的也就是 1000 万个，每个关键词平均 50 字节，所以总的大小为 500 MB，1 G的内存空间完全可以容下。
>
> 4、每个文件利用散列表和堆进行求 Top 10,然后将十个文件中的 Top10 放在一起，然后取 100 个关键词中的前十个。



### 九、扩展思考

▍**问题：**

> 有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？



▍**解答：**

> 1、首先，用户每点击一个新闻摘要的关键字，就通散列函数进行计数。
>
> 2、每过一个小时就遍历计算出散列表中的点击次数。
>
> 3、维护一个大小为 10 的小顶堆，遍历散列表中所有关键词出现的次数，与小顶堆的堆顶进行比较，如果大于堆顶元素就删除，将数据插入堆顶，否则就忽略，直到所有数据遍历完成。



**▍时间复杂度分析：**

> 1、遍历所有新闻关键词，时间复杂度为 O(n)。
>
> 2、插入堆数据最坏时间复杂度为 O(klog2(10))——这里的 k 应该小于 n 的。
>
> 3、总体的时间复杂度为 O(n)。









