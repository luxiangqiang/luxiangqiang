---
title: 浏览器如何工作的之【工作流程】
categories: 
- 前端
- 浏览器
tags: 
- 前端
- 浏览器
---

浏览器是如何工作的？

<!--more-->

[TOC]

## 浏览器的工作原理

### 一、整个浏览器的工作流程

> 整个过程都是流式处理，同步进行。

1、DNS 查询。

2、浏览器通过 HTTP 请求服务器。（HTTP 请求的过程是怎么样的）

3、构建 DOM 树。（解析 HTML 代码，构建 DOM 树）

4、计算 CSS属性。（如何将 CSS 属性挂载在 DOM 树）

5、排版 。（浏览器确定每个元素的位置）

6、渲染 。（模型变成位图的过程，将在内存每个元素渲染成图形）

7、合成 。

8、绘制。（位图绘制到屏幕上）



### 二、DNS 查询

> DNS 查询主要是通过访问的域名查询出它的 IP 地址。

 

#### 2.1 查询内容

> 通过 DNS 查询工具得出的一下六段内容:
>

1、第一段：查询参数和统计。

2、第二段：查询内容。

3、第三段：DNS服务器的答复。

> 显示 A (adress) 记录，即域名对应的所有 IP 地址。`math.stackexchange.com`有四个`A`记录，即四个 IP 地址。`600`是 TTL 值（Time to live 的缩写），表示缓存时间，即 600 秒之内不用重新查询。

![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061504.png)

4、第四段：显示域名的 NS 记录（Name Server），即哪些服务器负责管理该域名的 DNS 记录。

> `stackexchange.com `共有四条 NS 记录，即四个域名服务器，向其中任一台查询就能知道`math.stackexchange.com ` 的 IP 地址是什么。

![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061505.png)

5、第五段：管理域名的服务器的 IP 地址跟随着返回。

![img](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061506.png)

6、第六段：DNS 服务器的一些传输信息。



#### 2.2 DNS 服务器

1、本机知道 DNS 服务器的 IP 地址，通过请求 DNS 服务器才可以查询到该域名的 IP 地址。

2、DNS 服务器的 IP 地址，有可能是动态的，每次上网时由网关分配，这叫做 **DHCP 机制**；也有可能是事先指定的固定地址



#### 2.3 域名的层级

> DNS 服务器通过**分级查询**得到每个域名的 IP 地址。



###### ▉ 域名的层级结构

```
主机名.次级域名.顶级域名.根域名
```

- 根域名 (root) ：所有域名是一样的。
- 顶级域名（.com .net）。
- 次级域名 ：用户可以注册的。 
- 主机名（host）：如 www，又称三级域名。用户在自己域里为服务器任意分配的名称。



#### 2.4 根域名服务器

>  每一集域名都有自己的 NS 记录，NS 记录是指向该级域名服务器，该服务器知道下一级域名的各种记录。



###### ▉ 分级查询

> 从根域名开始查询每一级的 NS 记录，直到查到最终的 IP 地址。"根域名服务器"的 NS 记录和IP地址一般是不会变化的，它是**内置在 DNS 服务器里面的**。

- 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（IP 地址）。

- 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（IP 地址）。

- 从"次级域名服务器"查出"主机名"的 IP 地址。



#### 2.5 DNS 整个查询过程

1、本机通过本地设置的 DNS 服务器请求域名的 IP 地址。

2、DNS 服务器开始进行分层查询。

3、先是通过内置的根域名（.root）服务器查到顶级域名服务器" 的 NS 记录和 A 记录。

4、然后从 "顶级域名服务器（com.）" 查到 "次级域名服务器" 的 NS 记录和 A 记录。

5、再通过从 "次级域名服务器（用户注册的域名）" 查出 "主机名（www.）" 的 IP 地址。



#### 三、浏览器通过 HTTP 请求服务器。

1、浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包
括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间
传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由
客户端发出该请求已经被接受的报文。

2、一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远
程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正
确的响应。



#### 四、构建 DOM 树。

> 获取 HTTP 的 Request 的 body 中字符串（字符流）的 HTML 文本，进行解析并构建 DOM 树。

![1559028002988](C:\Users\10405\AppData\Roaming\Typora\typora-user-images\1559028002988.png)



##### 1、状态机解析代码

> HTML 词法状态机的作用就是将字符流解析成词（token)。状态机每读入一个字符就要做一次决策，这些决策和当前的状态有关。

① 字符流进入状态机对每个字符进行解析，每判断一个字符，就为一个状态。根据当前状态来确定下一字符确定的下一个状态。

② 用状态机做词法分析，将每个词的 “特征状态” 逐个拆开成独立状态，然后把所有的特征字符链合并起来，形成一个联通图结构。

③ 状态机涉及到编译原理，用 `javascript` 来讲解。可以设计函数，每个函数为一个状态，参数接受字符串，返回的是下一个状态函数。



##### 2、构建 DOM 树

> 要把上边状态机解析的词通过栈这种结构来构建 DOM 树。

① 在接收状态机解析的词的同时，就开始通过构建 DOM 树算法构建 DOM 树，当接受完所有输入的时候，栈顶就是最后的根节点，DOM 树的产出，就是 stack 的第一项，

② 构建 DOM 树，需要一个 Node 类，构建 DOM 树的所有结点都是这个 Node 类的实例。不一样的 HTML 结点对应不一样的 Node 子类（如 Element、Text等，如果基于 OOP 的话，需要抽象工厂来创建类）。

③ 在词中，开始标签和结束标签需要成对匹配的（在编译原理中，正是利用了栈匹配开始和结束标签的方案）。

④ 如果遇到 Text 结点，把相邻的 Text 结点合并起来。入栈，检查栈顶，若栈顶为 Text 结点，就合并 Text 结点。

⑤ 构建 DOM 的全过程

- 栈顶为当前元素；
- 遇到属性就添加当前节点；
- 遇到文本点，如果当前节点是文本节点，则跟文本节点合并，否则入栈为当前的子节点；
- 遇到注释节点，作为节点的子节点；
- 遇到开始标签就入栈一个节点，当前节点就是这个节点的父节点；
- 遇到结束标签就出栈一个节点（检查是否匹配）。



#### 五、计算 CSS 属性

> 上阶段构造的 DOM 树只有节点和属性，没有包含任何的 CSS 样式。这一节点将 CSS 规则应用到样式中去，为 DOM 树添加 CSS 属性。DOM 树构造到父节点的时候，还不知道它有没有子节点，所以算不出来 CSS。



##### 1、选择器的出现顺序

> 选择器出现的顺序必定跟 DOM 树的顺序一致，这是 CSS 设计的一个原则。即保证选择器在 DOM 构建到当前节点时，已经可以准确判断是否匹配了，不需要后续节点信息。



##### 2、CSS 分析

> ① CSS 需经过词法分析和语法分析，变成计算机可以理解的结构（属于编译原理的知识），解析之后变成一颗可用的抽象语法树。
>
> ② 一个 complex-selector 是检查一个元素的规则，一个复合选择器是由数个 complex-selector 通过连接符（combinator）组成。



##### 3、连接符的匹配规则

###### ▉ 后代选择器 —— “空格”

> ① 匹配到 a#b 元素时，开始检查所有的子代是否匹配 .cls。 
>
> ② 当遇到 \</a> 时，使规则退一步，才会时第三个不会被匹配到。
>
> **※ 总结：**后代选择器的作用范围是父节点的所有子节点，一次规则是在匹配到本地标签的结束时回退的。

```css
a#b .cls {
    width: 100px;
}
```

```html
<a id=b>
    <span>1<span>
    <span class=cls>2<span>
</a>
<span class=cls>3<span>
```



###### ▉ 后继选择器 —— “~”

> 后继选择器的匹配规则是不能再使用闭合标签规则，而是带父元素的规则。（带父元素规则，就不会匹配后继的子节点了）
>

```html
.cls~* {
    border:solid 1px green;
}
<div>
<span>1<span>
<span class=cls>2<span>
<span>
    3
    <span>4</span>
<span>
<span>5</span>
</div>

```



###### ▉ 子代选择器 —— “>”

> 也是使用父元素作为约束条件进行匹配。
>



###### ▉ 其他

> 其他选择器包括逗号，表示“或”的关系。编译器当做两条规则来处理。



##### 3、计算 css 完成

> CSS 计算把 CSS 规则应用到 DOM 树上，为 DOM 树添加了相关的属性过程，最后得到了一个带有 CSS 属性的树。
>



#### 六、排版

> 上一阶段确定了 CSS 属性得到一颗带有 CSS 属性的 DOM 树，而且构建 DOM 树和计算 CSS 属性两个节点产出的是一个一个的元素，那么这一阶段是浏览器确定每个元素的位置。



##### 1、基本概念

① 浏览器最基本的排版方案是正常流排版，浏览器的正常流是唯一**文字和盒模型**混排的排版方式，并遵循公认的文字排版规范。

② 文字排版规定了行模型和文字在行模型中的排布（行模型规定了行顶、行底、行高、文字区域、基线等对齐方式）。

③ 浏览器还支持元素和文字混排，元素是一个长方形区域，也就是所谓的盒模型。



##### 2、正常流文字排版

① 浏览器中的环境和显示中书写文字的环境差不多相同，但是浏览器支持改变排版的方向。我们把文字书写的方向叫做主方向，换行延伸的方向叫做交叉轴方向。

② 从字体中获取相关信息，其中一个重要属性为主轴的前后距离。文字排版还会受到一些 CSS 属性的影响，line-height、letter-spacing等。

③ 正常流中多数元素都是以盒来排版； `display` 为 `inline` 属性的元素，是拆成文本来排版的，会直接排入文档流中，主轴方向的 `margin` 属性和 border 属性也会计算进排版前进举例当中。

> 可以根据 display 属性可分为两类：

- 内部排版（文本排版）

- 是否为 `inline`（带有 `inline-` 前缀的盒子，称为行内级盒子）

④ 当没有指定文字书写方向的时候，从左到右文字中插入从右到左文字，会形成一个双向文字盒。

⑤ 即使没有元素包裹，混合书写方向也会形成盒结构。在排版时，遇到这样双向文字盒，会先排完盒内再排盒外。



##### 3、正常流中的盒

> 正常流中 `display` 不为 `inline` 的元素，以盒的形式跟文字一起进行排版。

① 主轴方向上的占据的空间是由 margin、border、padding、with/height 等属性和决定的，交叉轴方向是由 vertical-align 决定的，也会影响实际的行高。

② 浏览器对行的排版，先行内布局， 然后再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。

③ 块级盒子单独占据一整行，计算出交叉轴方向的高度即可。



##### 4、绝对定位元素

> `position` 属性为 `absolute` 的元素，根据包含它块来确定元素。因为这是跟正常流无关的一种独立排版模式，逐级找到父级的 `position` 非 `static` 即可。



##### 5、浮动元素排版

① 浏览器对 float 的处理事先排入正常流，在移动到排版宽度的最左/最右（主轴方向）。

② 移动后，float 元素占据一块空间，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。

③ float 元素排布完成后，float 元素所在的行需要重新确定位置。 



##### 6、其它排版

> CSS 每个排版都有复杂的规定，实现形式各不同。如 Flex 排版，支持 flex 属性，将每一行后的剩余空间平均分配给主轴方向的 width/height 属性。



#### 七、渲染

> 确定了每个元素的位置之后，根据样式信息和大小信息，为内存中的每个元素渲染出它的图形。在图形学中的意思是将模型变成位图的过程称为渲染。



##### 1、位图

> 位图就是内存中的一个二维表格，把每张图片的像素对应的颜色保存进去。（位图信息是DOM树中占据浏览器中内存最多的信息，内存优化主要考虑这点）



##### 2、渲染过程

> 浏览器渲染过程主要是将每个元素（Html元素/伪元素）的盒模型变成位图，inline 元素可能占据多行，每个盒对应一张位图。渲染过程分为两大类：

- 图形渲染 
- 文字渲染 



###### ▉ 图形渲染

> 盒的背景、边框、SVG元素、阴影等特性，都为绘制的图形类，需要一个底层库的支持。



###### ▉ 文字渲染

> 盒中的文字的绘制也会要一个底层库来支持，叫做字体库（目前常见的字体库为 Freetype）。字体库提供读取文字文件的基本能力，它会根据字符的码点抽取出字形。字形分为两种：

- 像素字形
- 矢量字形

通常字体会在小字体（小于6px、8px）提供像素字形，比较大的尺寸提供矢量字形（本身需要经过渲染才能继续渲染到元素的位图上去）。



###### ▉ 渲染过程

① 渲染过程生成的位图跟排版中占据的尺寸是相同的，但是现实中确有很大的差距，因为很多属性会影响渲染位图的大小，如阴影。为了优化，将阴影作为一个单独的盒子来处理。

② 渲染过程不会把子元素会知道渲染的位图上，当父元素和子元素发生相对位置变化时，可以保证渲染的结果最大程度被缓存，减少重新渲染。



#### 八、合成

> 合成并非浏览器必要执行的一环，实际上是一个性能的考量。

**合成可以这样理解：**合成的元素的意思是合成之后，通过 js 动态改变其他元素，合成的这部分元素，就不会重新渲染从而提高了性能。



##### 1、合成的过程

① 渲染过程不会把子元素渲染到位图上面，合成的过程，就是要创建一个合成层，把一部分子元素渲染到合成的位图上面。 



##### 2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？

> 合成的目标是提高性能，建立的原则就是最大限度减少绘制次数原则。好的合成策略是“猜测”可能变化的元素，把他排除到合成之外。

①    主流的浏览器一般根据 position、transform 等属性来决定合成策略，来猜测这些元素未来的变化。

②    以上猜测的准确性有限，所以新的 CSS 标准中，规定了 will-width 属性，可以由业务代码来提示浏览器的合成策略。



#### 九、绘制

> 绘制是把位图绘制到屏幕上，变成肉眼可见的图像的过程。一般最终显示的位图位于显存中，，有的情况只需把内存中的一张位图交给显示驱动或操作系统就 ok，这个将位图合成最终的位图叫做绘制。



##### 1、重排和重绘

> 所说的“重排”和“重绘”，所谓的重排是排版，重绘则是绘制过程。实际上，“绘制”过程发生的频率非常高，比如：鼠标滑过浏览器的显示区域，鼠标每次移动，都要造成重新绘制，如果不重新绘制，就会产生大量的鼠标残影。



##### 2、怎样减少重绘？

> 限制绘制面积可以提高性能，如果鼠标只在某个覆盖的区域滑动，我们只需重新绘制这个区域就可以了。



##### 3、解决办法

> “脏矩形”算法，把屏幕分成若干个矩形区域。

① 当鼠标移动导致绘制时，只重绘它影响到的几个矩形区域就够了。最小的影响区域只会涉及 4 个矩形，大型元素则覆盖多个矩形。

② 设置合适的矩形区域大小，可以很好的控制绘制时的消耗。设置过大会造成绘制面积增大，设置过小的矩形会造成计算复杂。

③ 重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交际部分绘制即可。



































