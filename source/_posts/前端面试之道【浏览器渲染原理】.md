---
title: 前端面试之道【浏览器渲染原理】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试
---

浏览器的渲染原理！

<!--more-->



## 一、浏览器的渲染原理

> JS 代码执行有自己的 JS 引擎，而浏览器的渲染也有一个引擎叫做渲染引擎。**Firefox** 的渲染引擎叫做 **Gecko**，**Chrome** 和 **Safari** 中都是基于 **WebKit** 开发的。



### 1、DOM 树的构建

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

① 当我们在网页中向服务器请求对应的 HTML 时，服务器将 HTML、CSS、JS 文件转化为 0,1字节数据在网络中传输给浏览器。

② 浏览器将接收到的字节数据转化为字符串。

③ 转化为字符串之后，浏览器再将这些字符串通过词法分析转化为标记（token）—— 代码的最小单位,这一过程叫做标记化。

④ 结束标记化后，将这些标记转化为 Node 结点，浏览器根据不同的结点构建为一棵 DOM 树。



### 2、CSSOM 树的构建

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

① 将 CSS 文件转化为 CSSOM 树。这个过程和上述过程是类似的，但是有一点不同，浏览器为了确定结点的样式，这个过程是非常耗时的。

② 浏览器通过递归的方式 DOM 树为结点设置样式。通过过先找到具体的标签，然后递归找到设置的上级标签，最后确定选择器选择的所选标签的样式。

③ 所以应该避免书写过于具体的 CSS 选择器，少一些添加无意义的 HTML 标签，有利于提高习页面的性能。





### 3、DOM + CSSOM 生成渲染树

> 将生成的 DOM 树和 CSSOM 树进行合并生成渲染树（Render Tree）。



① 两者并不是简单的合并，而是渲染树只会包括需要**显示的结点**，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

② 浏览器生成渲染树的时候，就会根据渲染树进行布局（回流），调用 GPU 绘制，合成图层，显示在屏幕上。这一部分属于底层操作。



## 二、浏览器的渲染流程

> 由于我们屏幕的刷新率为每秒 60 次，也就是 16.7 ms 一次，所有说在刷新一次之间页面重新绘制两次是没有意义的，只会影响性能。



#### 1、渲染帧的流程

> 渲染帧指的是一次完整绘制的过程。所以在 16.7 ms 一帧内渲染完成才会保证不会掉帧，否则页面会有卡顿感。（屏幕都渲染完成了，你的动画确还没有变化）

一帧需要完成以下操作：

①  **脚本执行（JavaScript）：**脚本造成了需要重绘的改动，比如增删 DOM、请求动画等；

②  **样式计算（CSS Object Model）：**级联地生成每个节点的生效样式；

③  **布局（Layout）：**计算布局，执行渲染算法；

④  **重绘（Paint）：**各层分别进行绘制（比如 3D 动画）；

⑤   **合成（Composite）：**合成各层的渲染结果；



#### 2、耗时的 JS 会阻塞渲染

> 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。

```javascript
// 
<div id="message"></div>
<script>
var then = Date.now()
var i = 0
var el = document.getElementById('message')
while (true) {
  var now = Date.now()
  if (now - then > 1000) {
    if (i++ >= 5) {
      break;
    }
    el.innerText += 'hello!\n'
    console.log(i)
    then = now
  }
}
</script>
```



## 三、为什么操作 DOM 慢

> 因为操作 DOM 是属于渲染引擎的东西，而 JS 属于 JS 引擎的东西，所以我们通过 JS 操作 DOM 的时候，这个过程涉及到两个线程的通信，那就回带来一些性能上的损耗。如果操作 DOM 次数过多，就相当于两个线程之间一直通信，并且操作 DOM 会导致重绘回流的情况，性能就会有所下降。



#### 1、插入几万 DOM 怎么实现页面不卡顿？

> 两种解决方案：
>
> 1）第一种通过 `requestAnimationFrame` 的方式循环插入 DOM。
>
> 2）第二种方式是通过**虚拟滚动**。



#### 2、两种实现方式

> requestAnimationFrame 实现。

```javascript
const total = 30000;              // 总 DOM 数
const size = 100;                 // 每次渲染的 DOM 数
const bathCount = total / size;   // 一共处理 300 次
var countDone = 0;                // 已经处理完的多少次
const ul = document.querySelector('ul');

function addItems(){
    const fragment = document.createDocumentFragment();
    // 一次渲染 100 个DOM 
    for (var i = 0; i < size; i++) {
        var li = document.createElement('li');
        li.innerText = 'item ' + (countDone * size + i);
        fragment.appendChild(li);
    }

    // 每次插入 100 个结点就修改 DOM 一次
    ul.appendChild(fragment);

    // 已经完成插入的次数
    countDone++;

    // 判断是否处理完成
    if(countDone < bathCount){
        window.requestAnimationFrame(addItems);
    }
}
addItems();
```

> 虚拟滚动实现：

```javascript

```



## 四、什么情况阻塞渲染

#### 1、阻塞的原因

> 1）渲染的前提是生成渲染树才能下一步的渲染，所以生成渲染树的过程也就是加载 HTML 和 CSS 肯定会阻塞渲染。（**js 阻塞渲染也会阻塞解析，而CSS 只会阻塞渲染，不会阻塞解析**）
>
> 2）当浏览器在解析 script 标签的时候会暂停 DOM，完成后会在从暂停的地方重新开始。



#### 2、减少阻塞

> 1）要想渲染的越快，就必须降低渲染文件的大小，优化选择器。
>
> 2）想要第一次加载页面加载的快，所以将 JS 文件标签放在 body 底部。
>
> 3）当 `script` 标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script` 标签放在任意位置。
>
> 4）对于没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染。

**补充：**

- async 异步下载脚本，下载完执行执行，在 onload 事件触发之前，不会阻塞页面但是不能保证脚本出现的顺序执行。
- defer 属性也会异步下载，但是会按照页面脚本的执行顺序下载，脚本的执行是按照页面脚本顺序执行的。而且是在 DOM 解析完成和 onload 触发之前执行。



## 五、重绘（Repaint）和回流(Reflow)

> **回流必将引起重绘，重绘不一定会引起回流。**



#### 1、重绘

> 在文档流中的位置并未发生改变，重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘。



#### 2、回流

> 在文档流中为止发生改变，回流是布局或者几何属性需要改变就称为回流。



#### 3、重绘/回流与EventLoop

① 当 EventLoop 执行完微任务后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次；

② 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能；

③ 判断是否触发了 media query；

④ 更新动画并且发送事件；

⑤ 判断是否有全屏操作事件；

⑥ 执行 `requestAnimationFrame` 回调；

⑦ 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好；

⑧ 更新界面；

⑨ 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。



#### 4、如何减少重绘和回流

①  使用 `transform` 替代 `top`；

②  使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）;

③  不要把节点的属性值放在一个循环里当成循环里的变量;

④  不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局;

⑤ 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`;

⑥ CSS 选择符**从右往左**匹配查找，避免节点层级过多;

⑦ 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。

























