---
title: 数据结构与算法之美【二分查找】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
copyright: true
---

如何用最省内存的方式实现快速查找 !

<!--more-->



## 二分查找（上）

> 一般**二分查找**的都可以用**散列表**或者**二叉查找树**来解决。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。



### 一、适用条件

#### 1、二分查找依赖的是顺序结构（数组）

> 二分查找算法需要按照下标随机访问元素 ,因为时间复杂度为 O(1)，如果使用链表，下标随机访问时间复杂度变成为 O(n)。



#### 2、二分查找针对的是有序数据

> 二分查找只能应用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用，使用二叉树。



#### 3、二分查找不适合数据量太小

> 如果要处理的数据量太小，直接遍历就足够了。一个特殊情况，那就是数据之间**比较操作非常耗时**，无论数据量大小，推荐使用二分查找。



#### 4、二分查找不适合数据量太大

> 由于二分查找底层依赖的是数组这种结构，内存空间要求是连续的。如果数据量太大，内存连续的空间不足，用数据存储起来比较吃力。



### 二、最简单的二分查找

> 最简单的情况就是有序数组中不存在重复的元素



#### 1、最简单代码实现

```java
public int simpleFind(int[] a,int n, int value) {
    int low = 0;
    int high = n - 1;

    // 当两个指针同时指向一个数据时，必须用 <=
    while(low <= high) {
        //注意:两者之和可能会溢出
        //改进: low + (high - low)/2 或 low + ((high - low)>>2)
        int mid = (low + high)/2;
        if(a[mid] == value) {
            return mid;
        }else if(a[mid] < value) {
            // 如果不 + 或 - 会发生死循环
            low = mid + 1;
        }else {
            high = mid - 1;
        }
    }
    return -1;
}
```



#### 2、递归代码实现方式

```java
public int recursionTwoFind(int[] a,int low,int high,int value) {
    //终止条件
    if(low > high) return -1;

    //计算中间结点
    int mid = low + (high-low)/2;

    //进行递归
    if(a[mid] == value) {
        return mid;
    }else if(a[mid] < value){
        return recursionTwoFind(a, mid + 1, high, value);
    }else {
        return recursionTwoFind(a, low, mid - 1, value);
    }
}
```



### 三、三个重点

#### 1、循环退出条件

> 注意是 low <= height,而不是 low < heigh。
>
> **原因：**指向同一个数据，并不能查找到。



#### 2、mid 的取值

> mid=(low+high)/2 写法有问题。
>
> **原因：**因为如果 low 比和 height 大的话，两者之和可能会溢出。
>
> **优化：**应写成 low+(high-low)/2 ，如果优化到极致的话，改进为位运算符 low+((high-low)>>1)。



#### 3、low 和 high 的更新

> low=mid+1，high=mid-1。
>
> **原因：**如果不进行 +1 和 -1 ，就有可能会发生死循环



## 二分查找（下）

### 一、四个变体问题

#### 1、查找第一个值等于给定值的元素

> 有序数据集合中包含**重复数据**，之前的二分查找只适合于无重复数据，在这里就不适用了，查找第一个值等于给定值的元素。



■ **代码实现 **

```java
/**
	 * 变体一:查找第一个值等于给定值的元素
	 * @param a 数组
	 * @param n 数组的长度
	 * @param value 超找的值
	 * @return 该元素的数组下标
	 */
	public int find1(int[] a, int n, int value) {
		int low = 0;
		int high = n - 1;
		
		// 当两个指针同时指向一个数据时，必须用 <=
		while(low <= high) {
			//注意:两者之和可能会溢出
			//改进: low + (high - low)/2 或 low + ((high - low)>>2)
			int mid = low + (high - low)/2;
			if(a[mid] == value) {
				// 找出重复元素中第一个元素
				if(mid == 0 || a[mid - 1] != value) {
					return mid;
				}else {
					high = mid - 1;
				}
			}else if(a[mid] < value) {
				// 如果不 + 或 - 会发生死循环
				low = mid + 1;
			}else {
				high = mid - 1;
			}
		}
		return -1;
	}
```



#### 2、查找对后一个值等于给定值的元素

> 查找对后一个值等于给定值的元素。



 ■ **代码实现**

```java

	/**
	 * 变体一:查找最后一个值等于给定值的元素
	 * @param a 数组
	 * @param n 数组的长度
	 * @param value 超找的值
	 * @return 该元素的数组下标
	 */
	public int find2(int[] a, int n, int value) {
		int low = 0;
		int high = n - 1;
		
		// 当两个指针同时指向一个数据时，必须用 <=
		while(low <= high) {
			//注意:两者之和可能会溢出
			//改进: low + (high - low)/2 或 low + ((high - low)>>2)
			int mid = low + (high - low)/2;
			if(a[mid] == value) {
				// 找出重复元素中第一个元素
				if(mid == n - 1 || a[mid + 1] != value) {
					return mid;
				}else {
					low = mid + 1;
				}
			}else if(a[mid] < value) {
				// 如果不 + 或 - 会发生死循环
				low = mid + 1;
			}else {
				high = mid - 1;
			}
		}
		return -1;
	}
```



#### 3、查找第一个大于等于给定值的元素

> 查找第一个大于等于给定值的元素。



■ **代码实现**

```java
/**
	 * 变体三:查找第一个大于等于给定值的元素
	 * @param a 数组
	 * @param n 数组的长度
	 * @param value 数组的值
	 * @return 
	 */
	public int find3(int[] a, int n, int value) {
		int low = 0;
		int high = n - 1;
		
		// 当两个指针同时指向一个数据时，必须用 <=
		while(low <= high) {
			// 注意:两者之和可能会溢出
			// 改进: low + (high - low)/2 或 low + ((high - low)>>2)
			int mid = low + (high - low)/2;
			if(a[mid] >= value) {
				if((mid == 0) || (a[mid - 1] < value )) {
					return mid;
				}else {
					high = mid - 1;
				}
			}else {
				low = mid + 1;
			}
		}
		return -1;
	}
```



#### 4、查找第一个小于等于给定值的元素

> 查找第一个小于等于给定值的元素。



■ **代码实现**

```java
/**
	 * 变体四:查找第一个小于等于给定值的元素
	 * @param a 数组
	 * @param n 数组的长度
	 * @param value 数组的值
	 * @return 
	 */
	public int find4(int[] a, int n, int value) {
		int low = 0;
		int high = n - 1;
		
		// 当两个指针同时指向一个数据时，必须用 <=
		while(low <= high) {
			// 注意:两者之和可能会溢出
			// 改进: low + (high - low)/2 或 low + ((high - low)>>2)
			int mid = low + (high - low)/2;
			if(a[mid] <= value) {
				if((mid == n-1) || (a[mid + 1] > value )) {
					return mid;
				}else {
					low = mid + 1;
				}
			}else {
				high = mid - 1;
			}
		}
		return -1;
	}
```



### 二、扩展思考：如何快速定位一个 IP 地址的归属地？

■ **问题：**

> 如何在 12 万条数据中，快速定位一个 IP 地址的归属地？



■ **解决：**

> 1、首先预先处理这 12 万条数据，让其按照起始 IP 从小打到排序，将 IP 转化为 32 位的整型数，然后按照对应到的整型值的大小关系，从小到大进行排序。
>
> 2、将问题转化为**变体四的问题**，“查找最后一个小于等于某个给定值的元素”。
>
> 3、找到一个 IP 区间起始位置的IP 小于等于该查找 IP 的区间，然后检查该 IP 是否在区间内。



■ **代码实践**

Github：[JS 快速定位一个 IP 地址归属地](https://github.com/luxiangqiang/Data-Structure-Coding/tree/master/%E6%9F%A5%E8%AF%A2IP%E5%9C%B0%E5%9D%80%E5%BD%92%E5%B1%9E%E5%9C%B0)









