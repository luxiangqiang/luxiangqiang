---
title: 前端面试之道【事件流与委托】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试
---



事件流与委托是前端重点内容之一！

<!--more-->



## 事件流

> 浏览器开发团队遇到的问题是，当点击页面的某一元素的时候，不仅点击了当前源苏苏，而且也点击了包含当前元素的容器，也相当于点击了整个页面。然而为了规范页面中的事件的接收顺序，两个浏览器团队提出了完全相反的想法。



### 一、事件流

> 所谓的事件流描述的是从页面中接收事件的顺序。
>
> 1）IE 提出的是**事件冒泡流**。
>
> 2）NC 提出的是**事件捕获流**。



#### 1、事件冒泡

> IE 的事件流叫做事件冒泡。事件是从具体的元素接收，向上传播到不具体的结点。
>
> 1）所有的浏览器都支持事件冒泡。
>
> 2）IE 5 之前事件冒泡会跳过`<html>` 元素，从 `body` 到 `document`。
>
> 3）`IE 9`、`Firefox`、`Safari`、`Chrome` 等浏览器事件一直冒泡到 `window` 对象。

```html
// 例子
div > body > html > document > window // 当点击页面的 div 元素时，事件的传播顺序
```



#### 2、事件捕获

> NC 提出的另一个事件流叫做事件捕获。事件从不具体的结点到具体的元素。用意是事件到达预定的目标结点之前捕获它。
>
> 1）老版本的浏览器只支持事件冒泡，不支持事件捕获。
>
> 2）一般没有特殊要求，都是用事件冒泡。

```html
// 例子
window > document > html > body > div // 当点击页面的 div 元素时，事件的传播顺序
```



#### 3、DOM 事件流

> “DOM2” 的事件流包括三个阶段，**事件捕获、处于目标阶段、事件冒泡阶段**。
>
> 1）一般「处于目标阶段」属于事件「冒泡阶段」的一部分。
>
> 1）`IE 9`、`Firefox`、`Safari`、`Chrome` 等浏览器会在事件捕获阶段触发事件对象上的目标。相当于有两个机会在目标对象上操作事件。
>
> 2）`IE 8` 更早的版本不支持 `DOM ` 事件流。

```
// 事件捕获
window > document > html > body
// 处于目标阶段
body > div 
// 事件冒泡阶段
div > body > html > document > window
```



### 二、事件处理程序

链接：[事件绑定和事件对象](http://luxiangqiang.xn--6qq986b3xl/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/)



## 委托

> 事件处理程序的数量直接关系到页面的性能问题，主要分为两个方面：
>
> 1）每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。
>
> 2）事先指定所有事件处理程序而导致的 `DOM` 访问次数过多，会延迟整个页面的交互就绪时间。



### 一、事件委托

> 为了解决“事件绑定”过多的问题，解决方案是**事件委托**。利用事件冒泡，只需绑定一个事件处理程序，就可以管理页面所有的事件。



#### 1、定义

> 1）事件委托，只需将事件处理程序绑定到 `DOM` 树最高的层次上。
>
> 2）一般考虑绑定到页面的 `document` 对象上。

```javascript
// 绑定到 document 对象上
EventUtil.addHandler(document, "click", handler);
const handler = (event)=>{
    event = EventUtil.getEvent();
    let target = EventUtil.getTarget(event);
    if (target.name && target.id) {
        switch (target.name) {
            case 'delete':   
                
            case 'edit':
                
            case 'selectImg':
                
            case 'updataImg':
               
            case 'modifyStaffInfo':
               
            case 'modelYes':   
        }
    }
}
```



#### 1、优点

> 1）`document` 很快就可以访问，页面呈现的元素立即具备了绑定的功能。
>
> 2）页面设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 `DOM` **引用更少**，**时间就越少**。
>
> 3）整个页面占用的**内存空间少**，提升了整体的性能。



### 二、移除事件绑定

> 页面元素在绑定事件处理程序的时候，浏览器中的代码就会和 javascript 代码之间建立一个链接。这种链接越多，页面就会越慢。
>
> 1）事件委托减少事件绑定，限制连接的数量。
>
> 2）在不需要时移除时间绑定程序（内存中留有不用的处理程序）。



#### 1、两种情况

> 造成以上问题的两种情况：
>
> **1）文档中移除绑定事件的元素。**虽然元素被移除，但是事件处理程序还在内存中，无法当做垃圾被回收,因为虽然元素被移除了，但是在内存中与元素保持的引用的关系。
>
> 例如：`removeChild()` 和 `replaceChild()` 方法，更多的是使用 `innerHtml` 替换页面的一部分。
>
> **2）卸载页面的时候。**如果在页面卸载之前没有清理干净事件处理程序，还会存储在内存中。不断的刷新、卸载页面使得内存中事件处理程序的数量越来越多，因为事件处理程序占用的内存空间有没释放掉。



#### 2、解决方案

> 通过 onunload 事件处理在页面卸载的时候，将页面中绑定的事件处理程序全部移除掉。





