---
title: 数据结构与算法之美【队列】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
---

队列在线程池等有限资源池中的应用！

<!--more-->



### 一、队列的基本常识

#### 1、什么是队列

> 先进先出的数据结构。



#### 2、特点

> 先进先出，吃多了就拉！



### 二、怎么实现队列

> 用**数组**来实现的叫做**顺序队列**，用**链表**来实现叫做**链式队列**。



#### 1、顺序队列

##### ■ 代码实现

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    //将数据插入到尾部
    items[tail] = item;
    //指向尾部的下标加、+1
    ++tail;
    //返回ture
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    //取出队头的第一个数据
    （问题：队列头部的值还仍然存在数组中）
    String ret = items[head];
    //队头下边向后移动+1
    ++head;
    //将出队的元素返回
    return ret;
  }
}
```



##### ■ 问题探讨

> 用两个指针来控制队列，频繁的出队和入队会产生head 和 tail 都会持续往后移动，当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。怎么解决呢？



##### ■ 解决一：数据迁移

> 每出队一个元素就进行数据搬移，导致的时间复杂度从 O(1) 上升到了 O(n)，可以继续进行优化。



##### ■ 优化：解决一

> 当数据出队的时候，不做任何数据搬移，当无法往数组中添加数据的时候，然后集中进行数据搬移，优化后出队的时间复杂度为 O(1)，入队的时间复杂度分析：
>
> 1、当队尾有空余空间，进行直接插入，时间复杂度为 O(1)。
>
> 2、当队尾没有空闲时间时，先进行搬移然后进行插入，时间复杂度为O(n)。用均摊分析方法求出平均时间复杂度为 O(1)。



##### ■ 优化后的代码

```java
 // 入队操作，将 item 放入队尾
  public boolean enqueue(String item) {
    // tail == n 表示队列末尾没有空间了
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新 head 和 tail
      tail = tail - head;
      head = 0;
    }
    //将入队列的元素插入到队尾
    items[tail] = item;
    //队尾指针+1
    ++tail;
    return true;
  }
```



#### 2、链式队列

##### ■ 代码实现

```java
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```



##### ■ 三种常见的队列

###### 1、循环队列

▍**由来**

> 数组实现队列，在 tail == n 的时候，需要进行数据搬移，入队就会受到影响，为了避免这次操作，出现了循环队列。



▍**定义**

> 循环队列，顾名思义，队列首尾相接形成一个环。



▍ **示意图**

![](/images/循环队列.png)



▍**工作方式**

> 上图中，当 tail 指向 7 时，插入一个新数据并不更新 tail ,而是将 tail 指向下标为 0 的位置，当再次插入数据的时候，然后将 tail + 1更新为 1。



▍**判定条件**

> 最重要的是**队空**和**队满**两种判空条件。
>
> ① 队列的判空条件：**head == tail** 。
>
> ② 队满的判断条件：**(tail+1)%n=head。**

**补充：**

> 当a=bq+r，q是整数，并使其达到最大，此时我们说a模除b等于r。以数学式子表示：a模除b。例如要计算100模除16，由于100/16是一个大于6且不大于7的整数，取q=6。100-16*6=4，而4就是答案。

**注意：**

> 当队列满时，tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。



▍ **代码实现**

```java
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```



###### 2、阻塞队列

▍**由来**

> 通过队列实现安全高效的数据处理的功能。



▍**定义**

> 阻塞队列，是在普通队列基础上实现了阻塞线程的功能（**生产者—消费者模式**）。

**详细分析：**在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回



▍**问题一：阻塞产生的问题**

> 当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

**▍问题解决：**

> 通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。



**▍问题二：多线程引起的问题**

> 配置多个 “消费者” 需要开启多线程。而多个线程同时操作队列，就会存在线性安全问题，使用到下方的并发队列来解决线性安全问题。



###### 3、并发队列

> 线性安全队列叫做**并发队列**。



▍**实现方式**

> 最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。

**补充：**实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。



### 三、队列的应用场景

> 队列可以应用在任何有限池中，用于排队请求，比如数据库的连接池等。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”来实现请求排队。



### 三、本节思考

#### ■ 问题

> 当向固定大小的线程池请求一个线程的时候，如果线程没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种策略是怎么实现的呢？



#### ■ 解决

**1）非堵塞处理方式**

> 直接拒绝任务请求；

**2）阻塞处理方式**

> 将请求排队，等到有空闲线程时，取出排队的请求继续处理。



#### ■ 链表和数组排队请求的区别

> **① 基于链表的实现。**实现一个无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
>
> **② 基于数组实现。**实现一个有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，对于**响应时间比较敏感**的系统更加合适。设置一个合理的队列大小是非常有讲究的，队列太大导致等待的请求太多，队列太小会导致无法充分资源，发挥最大性能。



### 四、扩展思考

##### 1、类似于线程池用到队列排队请求，还有哪些类似的池结构或者场景会用到队列请求呢？ 

>  **答：**Android 中的 Handle 消息处理机制中的消息队列用到了队列请求（需扩展）



##### 2、如何实现无锁并发队列呢？

> **答：**



### 五、队列的基本掌握

#### 1、用数组实现一个顺序队列

#### 2、用链表实现一个链式队列

#### 3、实现一个循环队列



