---
title: 前端设计模式之【工厂模式】
categories:
- 设计模式
tags:
- 设计模式
---

 前端设计模式之【工厂模式】。

<!--more-->



## 构造器模式

#### 1、实例

```javascript
function User(name , age, career) {
    this.name = name
    this.age = age
    this.career = career 
}
```



#### 2、定义

> 当新建对象的内存被分配后，用来初始化该对象的特殊函数，就叫做构造器。在 JavaScript 中，我们使用构造函数去初始化对象，就是应用了**构造器模式。**



#### 3、原理

- 变化：变化的是取值的操作，确保了灵活性。
- 不变：用户的属性，这些用户共性。
- 构造器：构造器确保了共性的不变。



#### 4、小结

> 构造器模式抽象了每个对象实例的变与不变，工厂模式去做的是不同构造函数之间的变与不变。



## 简单工厂模式

假如不同的工种，属性不相同，所以进一步进行抽离。观察变与不变。



#### 1、实例

```javascript
function Coder(name , age) {
    this.name = name
    this.age = age
    this.career = 'coder' 
    this.work = ['写代码','写系分', '修Bug']
}
function ProductManager(name, age) {
    this.name = name 
    this.age = age
    this.career = 'product manager'
    this.work = ['订会议室', '写PRD', '催更']
}
```



#### 2、定义

> 工厂模式其实就是**将创建对象的过程单独封装。**



#### 3、原理

- 变化：单一属性值变化，
- 不变：共享属性值还是不变。
- 构造器：构造器确保了共性的不变。



#### 4、小结

> 只需对创建对象进行封装，然后无脑传参，就可以达到目的。

```javascript
function User(name , age, career, work) {
    this.name = name
    this.age = age
    this.career = career 
    this.work = work
}

function Factory(name, age, career) {
    let work
    switch(career) {
        case 'coder':
            work =  ['写代码','写系分', '修Bug'] 
            break
        case 'product manager':
            work = ['订会议室', '写PRD', '催更']
            break
        case 'boss':
            work = ['喝茶', '看报', '见客户']
        case 'xxx':
            // 其它工种的职责分配
            ...
            
    return new User(name, age, career, work)
}
```



#### 5、适用条件

- 有构造函数的地方，我们就应该想到简单工厂；

- 在写了大量构造函数、调用了大量的 new。



#### 6、简单工厂不适用情况

```javascript

```



## 抽象工厂模式 —— 开放封闭式原则

- 对拓展开放，对修改封闭。
- 软件实体（类、模块、函数）可以扩展，但是不可修改。



#### 1、抽象手机工厂 —— 抽象

> 用来设置限制条件、设置规定 —— 最大的抽象工厂。

```javascript
class MobilePhoneFactory {
    // 提供操作系统的接口
    createOS(){
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }
    // 提供硬件的接口
    createHardWare(){
        throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
    }
}
```



#### 2、具体手机工厂 —— 具体

> 想要生产实例，必须将抽象为具体化 —— 设定具体生产实例的工厂。

```javascript
// 具体工厂继承自抽象工厂
class FakeStarFactory extends MobilePhoneFactory {
    createOS() {
        // 提供安卓系统实例
        return new AndroidOS()
    }
    createHardWare() {
        // 提供高通硬件实例
        return new QualcommHardWare()
    }
}
```



上述 new 出的对象是大的工厂的具体产品类，他们具有共同的规定和特性，我们从而在进行抽象。



#### 3、具体产品类的抽象

具有统一的特性。

```javascript
// 定义操作系统这类产品的抽象产品类
class OS {
    controlHardWare() {
        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');
    }
}
```

```javascript
// 定义具体操作系统的具体产品类
class AndroidOS extends OS {
    controlHardWare() {
        console.log('我会用安卓的方式去操作硬件')
    }
}

class AppleOS extends OS {
    controlHardWare() {
        console.log('我会用🍎的方式去操作硬件')
    }
}
```



#### 4、抽象硬件工厂

```javascript
// 定义手机硬件这类产品的抽象产品类
class HardWare {
    // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性
    operateByOrder() {
        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');
    }
}
```

```javascript
// 定义具体硬件的具体产品类
class QualcommHardWare extends HardWare {
    operateByOrder() {
        console.log('我会用高通的方式去运转')
    }
}

class MiWare extends HardWare {
    operateByOrder() {
        console.log('我会用小米的方式去运转')
    }
}
```



#### 5、生产最终的产品

```javascript
// 这是我的手机
const myPhone = new FakeStarFactory()
// 让它拥有操作系统
const myOS = myPhone.createOS()
// 让它拥有硬件
const myHardWare = myPhone.createHardWare()
// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)
myOS.controlHardWare()
// 唤醒硬件(输出‘我会用高通的方式去运转’)
myHardWare.operateByOrder()
```



#### 6、扩展内容

比如FakeStarFactory不需要了，需要换一种类型的产品，只需进行新建产品类就可以，而抽象出来不变的不进行修改，这就达到了我们设计模式的目的，变与不变。

```javascript
class newStarFactory extends MobilePhoneFactory {
    createOS() {
        // 操作系统实现代码
    }
    createHardWare() {
        // 硬件实现代码
    }
}
```



#### 7、四个关键角色

- **抽象工厂（抽象类，它不能被用于生成具体实例）：** 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。
- **具体工厂（用于生成产品族里的一个具体的产品）：** 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
- **抽象产品（抽象类，它不能被用于生成具体实例）：** 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。
- **具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：** 比如我们上文中具体的一种操作系统、或具体的一种硬件等。



#### 8、学习目标

- 学会用 ES6 模拟 JAVA 中的抽象类；

- 了解抽象工厂模式中四个角色的定位与作用；

- 对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。



#### 9、小结

##### 9.1 学习的高标准

只会 JavaScript、只理解 JavaScript 、只通过 JavaScript 去理解软件太局限性，你的视野只会太过于狭隘，JS 只不过是编程世界中的一个分支，虽然它很流行，但是它不够强大。看 TypeScript 朝着什么方向变化？其他编程语言有哪些优秀的特性值的我们去学习？ES5\6\7等，他们变化了什么？为什么要朝那个方向变化？背后的原理是什么，我相信作为技术人更应该关注的是这些。这些东西都是一成不变的，找到变化的和不变的，变化的是如果有规律变的，不变的是保持怎么样的，你都应该清楚。

##### 9.2  SOLID 的五个原则

- 单一功能原则（Single Responsibility Principle）
- 开放封闭原则（Opened Closed Principle）
- 里式替换原则（Liskov Substitution Principle）
- 接口隔离原则（Interface Segregation Principle）
- 依赖反转原则（Dependency Inversion Principle）



##### 9.3 佐证五个原则的设计模式

设计模式的出现就是作为上述五个原则的一个素材，比如抽象工厂模式就是为了证明开放封闭式原则，变与不变的进行抽离。











