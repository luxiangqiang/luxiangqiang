---
title: 前端进阶深入系列之【模块化】
categories: 
- 前端
- javascript
- 前端深入系列
tags: 
- 前端
- javascript
- 前端深入系列
---

代码实现模块化有哪些方式？

<!--more-->



### 一、什么是模块化？模块化具备哪些特性？

- 定义模块接口，通过接口可以调用模块的功能。
- 隐藏模块内部实现，使用模块无知关注模块内部的实现细节。也避免了有可能产生的副作用和 bug。



### 二、使用对象、闭包和立即执行函数实现模块

#### 1、隐藏模块内部实现 

> 函数会创建的新的作用域，在此作用域内创建的变量只对当前函数可见，对外部不可见，所以可以选择立即执行函数来作为模块。



#### 2、定义模块接口

> 有了模块，要想在外部使用模块内部的变量，必须通过接口来实现。一种实现方式是利用对象和闭包，模块内部返回一个对象，该对象内包含模块提供的方法。而这些方法通过闭包保持函数模块内部变量，甚至当模块执行完毕仍然保持模块内部变量。



#### 3、模块扩展

> 扩展模块是为了更好的扩展模块的功能，调用立即执行函数，并将需要扩展的模块作为参数，然后在函数内部，为模块扩展方法，增加所需要的变量和函数，最后通过公共的两个方法，可以使用模块。



###### ▉ 模块扩展的缺点

> 创建的两个模块的功能都有自己独立的作用域，导致扩展的模块无法共享原有模块的内部属性。



### 三、使用 AMD 和 CommonJs 模块化

> 两者的主要区别是：AMD 的设计理念是明确基于浏览器，而 CommonJs 的设计是面向通用的 JavaScript 环境的，而不限于浏览器。



#### 1、AMD 

> AMD 很容易指定模块及依赖关系，最流行的实现是 RequireJs 。

define 函数接受一下参数：

- 新创建模块的 ID。
- 当前模块依赖的ID列表。
- 初始化模块的函数。

```
// 具体过程
// AMD 首先请求依赖的模块，这个过程是异步的，以免阻塞。下载解析完毕之后，调用函数工厂，并传入依赖的模块。
define('MouseCounterModule',['jQuery'],$ => {
	...
})
```



###### ▉ AMD 的优点

- 自动处理依赖，无序考虑模块引入的顺序。
- 异步加载模块，避免阻塞。
- 在同一个文件中可以定义多个模块。



#### 2、CommonJS

> CommonJS 是基于 JavaScript 环境的（Node.js），它的使用是基于文件的模块，所以每个文件中只能定义一个模块。通过 module 对象的 exports 方法暴露模块的接口，require 引用接口。
>
> 服务器之所以流行的原因：

- **服务端：**服务器加载模块是同步加载，可以访问模块的公共接口；
- **客户端：** 客户端需要远程服务器下载文件，同步加载导致阻塞。



###### ▉ CommonJS 的优点

- 语法简单。
- CommonJS 是 Node.js 的默认格式。



###### ▉ CommonJS 的缺点

- 不显式的支持浏览器，需要对不支持的格式进行打包。



### 四、ES6 模块

> ES6 模块结合了 CommonJS 和 AMD 的优点：

- ES6 语法简单，是基于文件的；
- ES6 支持异步模块加载。



###### ▉ 导入和导出

> ES6 引入了两个关键字：

- export —— 从模块外部指定标识符。
- import —— 导入模块标识符。

```javascript
// 导出部分表示符
export { message, sayHi}
// 默认导出
export default class xiaolu{}
```

```javascript
// 导入部分标识符(花括号是导入指定内容)
import {message, sayHi} from 'app.js'  
// 导入全部标识符   
import * as xiaolu from 'app.js'  
// 导入默认导出的内容
import xiaolu from 'app.js'
```



###### ▉ export 和 import 重命名

> 当出现重命名是，可以使用关键字 as 设置别名

```
export { say as sayHello }
import {greet as sayHello} from 'Salute.js'
```













