---
title: 数据结构与算法之美【散列表】
categories:
- 数据结构
tags:
- 数据结构
- 散列表
password: sanliebiao
copyright: true
---

![](/images/散列表上.png)

Word文档中的单词拼写检查功能是如何实现的？

<!--more-->

## 散列表（一）

### 一、什么是散列表

> 散列表的英文也叫做 “Hash Table”,平时我们叫他 “哈希表” 或者 "Hash表"。散列表用的是**「数组支持下标随机访问的特性」**，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说没有数组就没有散列表。



### 二、散列表的特点

> **散列思想：**把数组下标叫做**键（key）**或者**关键字**，把数组中的值转化为数组的下标的映射方法叫做**散列函数（"Hash"函数或者“哈希函数”），通过散列函数计算得到的值叫做**散列值（“Hash值” “哈希值”）。



### 三、散列表的优点（随机访问）

> 1、散列表就是利用数组支持下标随机访问，时间复杂的O（1）的特性，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应的下标位置。
>
> 2、通过键值查询数据元素的时用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。



### 四、散列表的缺点（散列冲突）

#### 1、散列冲突

> 即使再完美的散列表也会出现散列冲突的情况。



#### 2、开放寻址法

> 当我们遇到散列冲突的时候，就**重新探测**一个空闲位置，将其插入。



■ **优点**

① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。

② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？）



■ **缺点**

① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。

② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。

③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。



■ **两种探测方法**

##### 1、线性探测

- **插入操作**

> ​    插入数据，若位置被占用，则从当前位置开始往后依次寻找空闲位置，直到插入。



- **查找操作**

> 查找元素，如果求得的元素不相等，我们就依次向后查找。



- **删除操作**

> **前提：**通过线性探测，找到一个空闲位置，我们就认定散列表不存在该值。
>
> **方法：**将删除的元素标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下测。



##### 2、二次探测和双重散列

> ① 所谓的二次探测，跟线性探测很像，线性探测每次探测步长为1，而二次探测是原来的二次方。它探测的下标序列就是 hash(key)+0，hash(key)+1²hash(key)+2²…
>
> ② 所谓的双重散列，不仅要使用一个散列函数，我们要使用一组散列函数，先用一组散列函数计算得到存储位置，如果已经被占用，就再用第二个散列函数，以此类推，直到找到空闲存储位置。



##### 3、装载因子

> 表示散列表空位的多少。装载因子越大，空闲位置越少，冲突越多，散列表的性能就会下降。

```
散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
```



#### 3、链表法

> 当插入数据的时候，计算出散列表的槽位，将其插入到槽位后对应的链表中。
>
> 1、插入的时间复杂度为 O(1)。
>
> 2、查找、删除的时间复杂度为O(k)   。



■ **优点**

① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。

② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺序查找还是快很多。



■ **缺点**

① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。

② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。



### 五、散列函数

#### 1、定义

> 散列函数，把它定义成 hash（key）,其中 key 表示元素的键值，hash（key）的值表示经过散列函数计算得到的散列值。



#### 2、散列函数的设计要求

① 散列函数计算得到的散列值是一个**非负整数**；

> 解释：数组下标是从 0 开始的。  

② 如果 key1 = key2,那 hash（key） == hash（key2）;

> 解释：相同的 key 的到的散列值也相同。

③ 如果 key1 ≠ key2,那 hash（key）  ≠  hash（key2）;

> 解释：有可能不能达到此要求，因为会有散列冲突现象。



### 六、应用思考：Word文档中的单词拼写检查功能是如何实现的？

> **答：**常见的英文单词有 20 万个左右，假设单词的平均长度是 10 个单词，平均一个单词占用 10 个字节的内存空间，20 万大约占用 2 MB，这个大小完全可以存储的开，我们用散列表来实现。当用户输入单词的时候，我们拿着单词去散列表中查找，如果查找到了，则说明拼写正确，如果没有，则拼写错误，基于提示。



### 七、扩展思考

#### 1、假设我们有 10 万条 URL 访问日志，如何按照访问次数给URL 排序？

> **答：**首先，我们遍历这 10 万条数据，URL 为 key，访问次数是value，将他们存入散列表。然后借助排序算法中的快排。



#### 2、有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

> **答：**先以第一个数组为例建立一个散列表，key 字符串，value 全部设置为 0，另一个数组中的字符串作为 key 在散列表中进行查找，如果可以找到，则为两个数组共同的字符串。





## 散列表（二）

### 一、何为工业级的散列表

- 支持快速的查询、插入、删除操作；
- 内存占用合理。不能浪费过多的内存空间；
- 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。



### 二、如何实现这样一个散列表？

- 设计一个合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决方法



#### 1、如何设计散列函数？

> 散列表设计不能太复杂；散列函数生成的值尽可能的随机并且均匀分布。

- 数据分析（重点）
- 直接寻址法
- 平方取中法
- 折叠法
- 随机数法



#### 2、如何根据装载因子动态扩容

> 散列表的装载因子越大，散列表中的元素越多，空闲位置越少，散列冲突的概率越大。多次寻址导致消耗很长时间，链表法导致拉很长的链，查找过程非常慢。
>



■ **静态数据**

> 很容易根据特点设计出合适的散列表。



■ **动态数据**

> 随着数据不断的插入，装载因子不断的慢慢变大，到达一定程度的时候，散列冲突不得不发生。



##### 动态扩容

> 我设置一定的阈值来进行散列空间的扩容，在装载因子小于某个值的时候进行缩容，超过某个阈值进行扩容。



##### 两个问题

- 扩容过大，导致内存浪费。
- 散列空间过小，导致散列冲突。



##### 两个方法

- 如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；
- 如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。



### 二、如何避免低效地扩容？

#### 1、什么是低效的扩容？

> 当装载因子到达阈值时，需要先进行扩容，再插入数据，在这个种极端的情况下插入数据会非常慢。



#### 2、怎么解决低效的扩容？

> 当达到装载因子阈值之后，申请新空间，但是不进行数据搬移，当有新数据插入的时候，从老散列表拿出数据往新的散列表进行插入。重复此过程，在极端的情况下复杂度也是O（1）。



### 三、如何选择冲突解决方法？

> 最常用解决冲突的方法为链表法和开放寻址法。 java中的 LinkedHashMap 就采用了链表法解决冲突。
>
> 而 ThreadLocalMap 就采用了线性探测的开放寻址法来解决冲突。



#### 1、开放寻址法

**■ 优势：**

① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。

② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？）



**■ 缺点：**

① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。

② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。

③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。



**■ 适用条件：**

> 当数据量比较小、装载因子小的时候，适合采用开放寻址法。



#### 2、链表法

**■ 优势：**

① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。

② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺村查找还是快很多。



**■ 缺点：**

① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。

② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。



**■ 改进：**

> 我们将链表法中的链表改造为其他高效动态的数据结构，比如跳表、红黑树。这样，即便出现的散列冲突，极端情况下，所有数据都散列到同一个桶内，最终退化成的散列表的查询时间也只不过是O(logn)。



**■ 适用条件：**

> 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。



### 五、举例：工业级散列表 HashMap 

#### 1、初始化大小

> HashMap默认的初始化大小16，当然这个默认值可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始化大小，减少动态扩容的次数，这样大大提高HashMap的性能。



#### 2、装载因子和动态扩容 

> 最大转载因子是0.75，当 HashMap 中的元素个数超过0.75 * capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都是原来的**两倍大小**。 



#### 3、散列冲突解决方法

> 使用链表法来解决冲突的。负载因子和散列函数设计的再合理，也避免不了会出现拉链过长的情况，一旦拉链过长，则会影响 HashMap 的性能。



#### 4、对链表法的优化

> 当链表长度太长（默认超过8）时，链表就转化成了红黑树，利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。





## 散列表（三）

### 一、LRU 缓存淘汰算法

#### 1、淘汰数据

> 维护一个按照访问时间从大到小有序排序的链表结构。因为缓存大小有限，我们遍历整个链表，当缓存空间不足时，需要淘汰一个数据，直接将头部的结点删除。
>



#### 2、缓存数据

> 当缓存某个数据的时候，先在链表中查找这个数据，如果没有找到，直接将数据添加到尾部，如果找到了，将它移动到尾部。再遍历链表的时候需要遍历整个链表，时间复杂度为O(n)。



#### 3、主要操作

> 一下三种操作都涉及“**查找**”操作，时间复杂度为 O(n)，我们将链表和散列表两种数据结构组合到一起，将复杂度降为O(1)。
>

- **往缓存添加一个数据** 
- **从缓存删除一个数据**
- **在缓存查找一个数据**



#### 4、散列表和(双向)链表结合

![](/images/散列表和链表的结合.png)

> 除了双向链表存储数据之外，我们还有一个 hnext 指针，一个链是在我们的双向链表中，另一个hnext是我们散列表的**拉链**。hnext指针将我们的链表串在散列表中。
>



**①  查找一个数据 **

> 散列表查找数据的时间复杂度为 O(1)，查找到之后，我们将其移动到双链表的为尾部。



**② 删除一个数据 **

> 我们通过散列表在O(1)的时间复杂度之内找到数据之后，然后通过前驱指针O(1)的时间复杂度，直接获取双向链表前驱结点，删除只需要O(1)的时间复杂度。



**③ 添加一个数据**

> 添加数据先要查看缓存中有没有该数据，如果没有就添加到双链表的尾部，添加的时候判断缓存有没有满，如果满了，需要先删除链表头部的数据，然后将数据插入到链表的尾部。如果没有满，就直接插到链表的尾部。



### 二、Redis 有序集合

> 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？



#### 1、Redis 中的有序集合支持的核心操作主要有下面这几个

- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
- 迭代输出有序序列。



#### 2、跳表比红黑树的优势

> 1、查找操作比红黑树要快。
>
> 2、插入、删除和红黑树差不多，但是**按照区间查找**O(logn)就能完成。
>
> 2、跳表更容易代码实现，意味着可读性好，不容易出错。
>
> 3、跳表更加灵活，它可以通过改变索引构建策略，**有效平衡执行效率和内存消耗。**



#### 3、红黑树的优势

> 红黑树直接拿来用就可以了，跳表必须自己实现。



### 三、LinkedHashMap 

> LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。



#### 代码实例：

```java
// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序
HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());    //打印顺序为 1235
}

```

> 实现原理与LRU 缓存淘汰策略一样的，按照此分析。



### 四、为什么散列表经常和链表使用

#### 原因一：

> 1、虽然散列表可以非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
>
> 2、它无法按照某种顺序快速的遍历数据，如果希望按照顺序遍历散列表中的数据，那我们就将散列表中的数据拷贝到数组中，然后排序，再遍历。



#### 原因二：

> 因为散列表是动态数据结构，不停的进行插入、删除。每当我们进行遍历数据的时候，先要进行排序，那效率就会很低。



### 五、思考

1、如果把双向链表改成单链表，还能否正常工作呢？为什么呢？

> **答:** 可以，但是删除操作时间复杂度会降到 O（n）。



2、假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：

- 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；

> 答：散列表实现，时间复杂度为 O（1）。

- 查找积分在某个区间的猎头 ID 列表；

> 答：跳表。

- 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。

> 答：需要排序，暂时无法实现。（？？？？？）



### 六、疑问

> 1、散列表和链表是怎么关联起来的？
>
> 2、散列表怎么直接定位到结点的？答：散列表中存储少量的链表。
>
> 3、查找数据将其移动到尾部？答：需要维护一个指向尾部的指针。
>
> 4、插入的时候，内存已满，需要在链表头部插入数据，散列表对应的值是否也应该改变？

