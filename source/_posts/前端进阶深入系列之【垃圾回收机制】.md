---
title: 前端进阶深入系列之【垃圾回收机制】
categories: 
- 前端
- javascript
- 前端深入系列
tags: 
- 前端
- javascript
- 前端深入系列 
---

JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？

<!--more-->s



### 内存泄漏

#### 1、什么是内存泄漏？

> 不再用到的内存，没有及时释放，就叫做内存泄漏。

**内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它**。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。



#### 2、怎么解决内存泄漏？

> 很多编程语言需要手动释放内存，但是很多开发者喜欢系统提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"。



### 一、为什么有垃圾回收机制？

> js 中的字符串、对象、数组等只有确定固定大小时，才会动态分配内存，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃



### 二、js 的垃圾回收机制

> JavaScript 与其他语言不同，它具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。



### 三、垃圾回收机制原理

> 找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。



### 四、两种垃圾回收策略

> js 中最常用的就是标记清除法。垃圾收集器必须跟踪哪个变量有用哪个没用，对于没有用的变量打上标记，以备将来收集其内存。

- **标记清除法**
- **引用计数法**



#### 1、标记清除法

> 垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。



###### ▉ 实现原理

> 通过判断一个变量是否在执行环境中被引用，来进行标记删除。



###### ▉ 标记清除的缺陷

> 其实标记清除和引用计数的缺陷相同的，因为都是判断变量在执行环境中的引用来确定该变量是否应该被回收，当保持着引用时，改变变量会一直在内存中存储。



#### 2、引用计数法

> 引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。



###### ▉ 实现原理

> 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。



###### ▉ 引用计数的缺陷

> 两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。

**举例：**最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。



#### 3、管理内存

> 虽然说是 js 的内存都是自动管理的，但是对于 js 还是存在一些问题的，最主要的一个问题就是**分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少**。



###### ▉ 主要原因

> 也是为了安全方面考虑，防止运行 js 网页将系统内存耗尽，导致整个系统崩溃。内存限制问题不仅影响到了给变量分配内存，还会影响调用栈以及线程同时执行的语句数量。



###### ▉ 解决方案

> 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做**解除引用**。

- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。
- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）

```javascript
var a = 20;  // 在堆内存中给数值变量分配空间
alert(a + 100);  // 使用内存
var a = null; // 使用完毕之后，释放内存空间
```

> **补充：**因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。