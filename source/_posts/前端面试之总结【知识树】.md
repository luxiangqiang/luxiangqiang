---
title: 前端面试知识体系树
categories:
- 前端
- 面试
tags:
- 前端
- 面试
---

前端面试知识体系树！

<!--more-->

## 目录

[TOC]



## JS基础知识点

### 一、JS中的基本类型问题

> js 的基本类型分为几大类？各是什么？

答：两大类，分别为**原始类型**和**对象类型**。



> 原始类型包括哪些类型？（6 种）

答：String 、Number、Boolean、null、undefined、symbol

> 补充：symbol 表示独一无二的值，为了防止对象的属性都是字符串类型而冲突引入的。

```javascript
// 通常参数是字符串类型，如果为对象类型，就会调用 toString 方法
let s1 = Symbol(参数);// 这个参数可以认为是 Symbol 实例的一个描述,用于区分

// 第一种写法
let a = {};
a[s1] = 'Hello!';

// 第二种写法
let a = {
    [s1] = 'Hello';
}
```



> 原始类型的特点是什么？原始类型和对象类型的区别是什么？对象函数传参发生的问题？

答：① 原始类型存储的都是值，而对象类型存储的是地址。（变量之间的赋值都是地址之间的赋值）

​		② 对象当做参数传递传递是副本。



> null 是对象类型吗？如果不是，为什么？

答：虽然检测 typeof  null 是对象类型，其实这是一个 js 的bug。JS 的最初版本是 32 位系统的，为了性能考虑将用低位存储变量的类型信息，`000` 开头代表的是对象，然而 null 表示全零，所以错误的将 null 判断为对象。虽然内部的判断代码已经改变，但是这个 bug 就一直存在下来。



> 总结：undefined 和 null 出现的情况。 

答：

- **undefined**

1、变量提升: 只声明未定义默认值就是 undefined

2、严格模式下：没有明确的执行主体，this 就是 undefined

3、对象没有这个属性名，属性值是 undefined

4、函数定义形参不传值，默认就是undefined

5、函数没有返回值（没有return 或者return;），默认返回的就是 undefined

- **null**

1、手动设置变量的值或者对象某一个属性值为 null（此时不赋值，后边会赋值）

2、在 JS 的 DOM 元素获取中，如果没有获取到指定的元素对象，结果一般都是 null。

3、Object.prototype._proto\_ 的值也是 null

4、正则捕获的时候，如果没有获取到结果，默认的也是 null



> 那为什么 0.1 + 0.2 > 0.3 ?

答：① 原因：js 采用的是 IEEE 754 双精度版本。

​        ② 因为计算机是通过二进制来存储的，0.1 的二进制的表示是一个无限循环的小数，这也没有什么问题。但是js采用的浮点数标准需要裁减数字，所以循环的数字就会被裁剪掉，导致出现了精度丢失，造成了 0.1 不再是 0.1，而是变成了 0.1000...002 。同样 0.2 变成了 0.2000..002 ，所以两者相加的数大于 0.3。

> 补充：为什么0.1 不是 0.1 ，为什么 console.log(0.1) 等于 0.1 呢？怎么解决这个问题？

答：① 因为在输入内容进行转换的时候，二进制转换成十进制，然后十进制转换成字符串，在这个转换的过程中发生了取近似值，所以打印出来的是一个近似值。

​		②可以通过原生的取近似值（四舍五入）的方法解决就可以了。

```
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```



**2、执行顺序**

- 声明一个全局的作用域（词法环境）。
- 进行函数和变量提升（上边的两个阶段）
- 代码自上而下执行
- 遇到函数执行循环此过程



### 二、JS 中的类型转换问题（笔试）

#### 1、转化为 Boolean 类型

> 只有 `null`、`undefined`、`‘ ‘`、`0`、`NAN`、`false` 转化为 `false`。 



#### 2、对象转原始类型

- `Object` 转字符串类型，直接调用 `toString()` 方法。
- 除 `String` 类型外，`Object` 转其他类型的话，直接调用 `valueOf `方法。
- 如果调用 `valueOf` 返回的不是原始类型的值，会调用 `toString()` 方法，toString() 如果返回的不是原始值，就会报错。



#### 3、四则运算符

> 加法运算符

- 只要运算符其中一方为字符串类型，另一方一会转换为字符串类型。
- 如果双方都不是字符串，则将转化为数字（boolean）或字符串(数组)。
- 对于无效格式，转化为 NaN。

```
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"


'a' + + 'b' // -> "aNaN"
```



> 其他运算（减/乘/除）

- 只要一方为数字，另一方也会转化为数字。

```
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```



#### 4、比较运算符

- 如果是对象和数字比较，则将对象通过 valueOf 转化为原始类型进行比较。
- 如果是字符串，将其转化为 unicode 字符索引来比较。



#### 5、逻辑运算符

> **在条件判断中:**

- && : 所有条件为真，整体才为真。
- || ：只有一个条件为真，整体就为真。



> **在赋值操作中：**

- A && B ：首先看 A 的真假，**A 为假，返回 A 的值，A 为真返回 B 的值。**

```
0 && 1 => 0
1 && 2 => 2
```

- A || B : 首先看 A 的真假，**A 为真返回的是 A 的值，A 为假返回的是 B 的值（不管B 是啥）**

```
0 || 1 => 1
1 || 2 => 1
```



### 三、类型判断（typeOf  VS instanceof）

> typeOf 能够正确的判断类型？

答：除了 null 都显示正确的类型。

```
typeOf 1   // 'number'
typeOf '1' // 'string'
typeOf undefined // 'undefined'
typeOf true // ‘boolean’
typeOf Symbol() // ‘symbol’

// 并不能准确的判断对象的具体类型
typeOf [] // 'object'
typeOf {} // 'object'
typeOf null // 'object'
typeof console.log // 'function'
```



> instanceof 能够正确判断对象的原理是什么？

答：正确的判断一个对象类型，使用 instanceof 内部机制是通过原型链来判断的。

> 补充：instanceof 不是百分之百可信任的。自定义一个 instanceof 行为的东西进行判断。



> == 和 === 有什么区别？

答: 

① ==：如果双方的类型不相同，先进行类型转换。如果相同就比较大小。

- 判断 null 和 undefined ，是的话就会返回 true。
- 判断两者类型是否为 string 和 number，是的话将字符串为 number。
- 如果一方为 boolean，就把boolean 转为 number 再判断。
- 如果 object 与原始类型比较，先把 object 转化为原始类型再判断。

② ===：只比较数值大小。

![img](https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 四、JS 中的相关 this 问题  

#### 1、判断 this   

> 如何正确的判断 this ?   

答：  

- 直接调用的函数，`this` 指向的是全局 `window` 对象。  
- 对象调用，`this` 指向该对象（. 前边谁调用 `this` 就指向谁）。   
- `new` 的方式，`this` 永远被绑定在新创建的对象上，任何方式都改变不了 `this` 的指向。  

 

> 箭头函数的 this 指向谁?  

答：① 箭头函数其实是没有 this 的，this 只取决于包裹箭头函数的第一个普通函数的 this。  

​		② 箭头函数使用 bind 改变 this 的指向是无效的。 

 

#### 2、改变 this 的值  

> 改变 this 的值的三种方式？  

- call  
- apply  
- bind (如果第一个参数上下文为空，这绑定在 window 上)  

 

> bind 对一个函数多次调用，那么上下文会指向谁呢？ 

```javascript
let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // => ?
```

答: 第二个 bind 绑定的函数是 bind ，所以 fn 绑定的 this 永远是第一个 bind 决定的，此处是 window。



> 多种 this 的规则出现，应该怎么判断？

答：this 的规则具有优先级，`new —> bind/apply/call —> obj.foo() —> foo() `



> apply、call、bind 之间的区别是什么？



> 手写一个apply、call、bind。



### 五、闭包

> 什么是作用域？什么是作用域链？

答：

- 作用域：规定**变量和函数**的可使用的范围叫做作用域。
- 作用域链：每个函数都会有一个作用域，查找变量或函数时，由局部作用域到全局作用域依次查找，**这些作用域的集合就称为作用域链。**



> 什么是闭包？

答：函数执行，形成一个私有的作用域，保护里边的私有变量不受外界的干扰，除了保护私有变量外，还可以存储一些内容，这样的模式叫做闭包。



> 闭包的作用/应用有哪些？

答：保护和保存。



> 保护和保存在实际项目中哪里用到？

答：

- **保护作用**

1）团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过return 或 window.xxx 的方式暴露在全局下。

2）jQuery 的源码中也是利用了这种保护机制。

3）封装私有变量

- **保存作用**

1）选项卡闭包的解决方案。



> 循环绑定事件引发的索引什么问题？怎么解决这种问题？

```javascript
// 事件绑定引发的索引问题
var btnBox = document.getElementById('btnBox'),
    inputs = btnBox.getElementsByTagName('input')
var len = inputs.length;
for(var i = 0; i < 1; i++){
    inputs[i].onclick = function () {
        alert(i)
    }
}
```

答：

**1）原因**

> 所有的事件绑定都是异步的，当触发点击事件，执行方法的时候，循环早就结束了。（js 是单线程的，浏览器是多线程的）

- 同步：JS 中当前这个任务没有完成，下面的任务都不会执行，只有等当前彻底完成，才会执行下面的任务。
- 异步：JS 中的当前任务没有完成，需要等一会在完成，此时我们可以继续执行下面的任务。

**2）解决方案**

> 当点击事件执行的时候，就会在私有作用域查找 i 的值，此时私有作用域没有 i ，就回去全局作用域查找，此时全局作用域的 i 已经被改变。所以说，要创建一个私有作用域的 i 。

- **方式一：自定义属性**

```javascript
// 方式一:自定义属性
for(var i = 0; i < 1; i++){
    inputs[i].myIndex = i;
    inputs[i].onclick = function () {
        alert(this.myIndex);
    }
}
```



- **方式二：闭包解决**

> **优点：**通过创建私有作用域（闭包）方式解决，循环几次，就创建几个私有作用域（闭包），然后，每个私有作用域都有一个私有变量 i ，存的值分别是循环的值。
>
> **缺点：**生成多个不销毁的私有作用域（堆内存），对性能有一定的影响。

```javascript
 for(var i = 0; i < 1; i++){
     ~function (i) {
         inputs[i].onclick = function () {
             alert(this.myIndex);
         }
     }(i)
 }
```



- **方式三：let 块级作用域**

```javascript
var len = inputs.length;
for(let i = 0; i < 1; i++){
    inputs[i].onclick = function () {
        alert(i)
    }
}
```



### 六、原型和原型链

![1565139171429](C:\Users\10405\AppData\Roaming\Typora\typora-user-images\1565139171429.png)

> 什么是原型？什么是原型链？如何理解？

答:  

**原型：**每个 JS 对象都有 `__proto__` 属性，这个属性指向了原型。

**原型链：**原型链就是多个对象通过 `__proto__` 的方式连接了起来。

**总结：**

- 所有的实例的 _proto\_ 都指向该构造函数的原型对象（prototype）。
- 所有的函数（包括构造函数）是 Function() 的实例，所以所有函数的 _proto\_ 的都指向 Function() 的原型对象。
- 所有的原型对象（包括 Function 的原型对象）都是 Object 的实例，所以 _proto\_ 都指向 Object （构造函数）的原型对象。而 Object 构造函数的 _proto\_ 指向 null。
- Function 构造函数本身就是 Function 的实例，所以 _proto\_ 指向 Function 的原型对象。



### 七、深拷贝和浅拷贝

> 什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？

答：

由于对象的赋值的是地址，会导致一方改变另一方，我们不想出现这种情况，所以出现了深浅拷贝。

- **浅拷贝**

**方式一：**浅拷贝会把对象的属性值拷贝到新的对象当中，如果属性值是对象的话，拷贝的是地址。所以浅拷贝只不过解决的是第一层。

```javascript
let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

**方式二：**通过扩展运算符来解决。

```javascript
let a = {
  age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
```

- **深拷贝**

答：一般会通过 `JSON.parse(JSON.stringify(object))` 来解决。（一般可以解决大部分问题）

```javascript
let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

局限性：

- 忽略 `undefined` => 忽略
- 不能序列化函数 => 忽略
- 会忽略 `symbol` => 忽略
- 不能解决循环引用的对象 => 报错

> 补充：因为手写深拷贝函数涉及到很多边界问题（原型链的处理、`DOM` 的处理等），通常推荐使用 `lodash` 来实现深拷贝函数。



## ES6 知识点及常考面试题

### 一、var、Let、Const

> 什么是变量提升？

答：变量提升就是该变量还未被声明，但是却可以使用未声明的变量；虽然描述为提升，但不是真正的将代码提升到顶部，而是在代码执行前，先在词法环境中进行了注册。



> 为什么会存在变量提升呢？

答：根本原因就是为了解决函数之间互相调用的情况。



> 变量和函数怎么进行提升的？优先级是怎么样的？

答：**1、提升规则：**

- **第一阶段：**对所有函数声明进行提升（**忽略表达式和箭头函数**），引用类型的赋值（函数的声明，函数的提升代表着可执行，因为提升之后保持着引用）分为三步：
  - 开辟堆空间
  - 存储内容
  - 将地址赋值给变量
- **第二阶段：**对所有的变量进行提升，全部赋值为 undefined（如果已经存在，不赋值为undefined）。然后依次顺序执行代码。



> 什么是暂时性死区？

答：使用 let 和 const 时，我们不能在声明之前使用变量，这叫做暂时性死区。



> var 和 let、const 的区别是什么？

答：

- var 存在变量提升，而 let、const 则不会。
- var 声明的变量会挂载到 window 上，而其他两者不会。
- let 和 const 的作用基本一致，后者声明的变量不能再次赋值（注意：但是能改变值）



#### 1、rem 和其他单位之间的区别

###### ▉ 定义

> **px：**像素 px 是相对于显示器屏幕分辨率而言的 。
>
> **em： **当前对行内文本的字体尺寸未被人为设置，则相对于 [浏览器的默认字体] 尺寸。
>
> **rem：**相对的只是 HTML **根元素**（根元素就是没有父节点的 dom 节点 ）大小。` html{font-size:10px}`



###### ▉ 计算关系

> 浏览器默认字体 大小 16 px;
>
> 1 em = 16px;
>
> 1rem = 10px；
>
> 10/16=0.625=62.5% 



###### ▉ 区别

> 1）IE无法调整那些使用 px 作为单位的字体大小； 
>
> 2）Firefox 能够调整 px 和 em，rem，但是 96% 以上的中国网民使用IE浏览器(或内核) ；
>
> 3) em的值并不是固定的； em 会继承父级元素的字体大小 。
>
> 3）rem 可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应（兼容性除 IE8 之外）。



###### ▉ 使用

> 1、为了简化font-size的换算，需要在css 中的 body 选择器中声明`Font-size=62.5%`，这就使em值变为 `16px*62.5%=10px`, 这样`12px=1.2em`, `10px=1em`, 也就是说只需要将你的原来的 px 数值**除以 10**，然后换上em 作为单位就行了。 
>
> 2、选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用 rem，如果要考虑 [ **兼容性**]，那就使用 px,或者**两者同时使用**。 



#### 2、Flex布局和传统布局有什么区别？ 

> **传统布局：**基于盒模型，依赖于 display 属性、position 属性 、float 属性。对于一些特殊的布局非常不方面，比如垂直居中。
>
> **Flex 布局：**可以简便、完整、响应式地实现各种页面布局,它已经得到了所有浏览器的支持。



#### 3、圣杯布局和双飞翼布局

###### ▉ 为什么使用圣杯布局？

> 必须按照源顺序（在 DOM 中表现为先写 Left，然后 Middle，最后，Right）等，它将可能导致代码不够灵活，尤其是从 DOM 的载入顺序上来说，中间的内容不能被首先加载。 







### 二、模块化

> 为什么要使用模块化？

答：模块化解决了命名冲突问题，可以提高代码的复用率，提高代码的可维护性。



> 都有哪几种方式可以实现模块化，各有什么特点？

答：

**1、立即执行函数**

**2、AMD 和 CMD**

**3、CommonJS**

> 最早是应用在 Node 的上边的，

**4、ES Module**

- CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- CommonJS 是**同步导入**，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是**值拷贝**，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用**实时绑**定的方式，导入导出的值都**指向同一个内存地址**，所以导入值会跟随导出值变化
- ES Module 会编译成 `require/exports` 来执行的



### 三、循环遍历

> forEach、for..in、for...of 之间的区别？

答：

#### 1、普通 for 循环

> 当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。

#### 2、foreach 循环

> **功能：**可以获取到 key 和 value 数组的本身。

**缺点：**

- 不能用 break，continue 语句跳出循环。
- 函数内不能使用 return 语句。

**注意：**在不同浏览器下测试的结果都是 forEach 的速度不如 for 。

```javascript
//item 为数组元素
//index 为索引下标
arr.forEach(function (item,index,arr) {
    console.log(item,index,arr)
})
```

#### 3、for...in 循环

> **for-in 循环遍历的是对象的属性。 2**数组的索引 ，除了遍历数组也可以遍历对象。

**缺点：**

- for-in 遍历的顺序并不是确定的。
- 它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 
- for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：https://juejin.im/entry/5a1654e951882554b8373622

#### 4、for...of 循环

> ES6 新增语法。

**优点：**

- 以正确响应 break, continue, return。 
- for-of 循环不仅支持数组，还支持大多数类数组对象。
- for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。
- for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 



### 四、link和@import区别

> link 和 @import 区别主要有哪些？

##### 1、加载顺序区别

link 标签引入的 CSS 是被同时加载的；而 @import 引入的 CSS 是将页面加载完毕后才会加载。



##### 2、兼容性区别

link 作为 HTML 元素，不存在兼容性；而 @ import 是 CSS2.1 才有的语法，只有 IE5+ 才能识别。



##### 3、DOM可控性区别

link 标签插入样式，可以通过 JS 操作 DOM；@import 不能插入样式，因为 DOM 方法是基于文档的。



##### 4、权重区别

`link`引入的样式权重大于`@import`引入的样式。







## 浏览器

### 一、浏览器的渲染原理

- 构建 DOM 树
- 构建 CSSOM 树
- 生成渲染树（DOM + CSSOM）



> 浏览器的渲染原理是什么？

#### 1、构建 DOM 树

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1）在 URL 中请求服务器，服务器返回对应的 HTML、CSS、JS 文件，是通过 0,1 **字节数据**在网络中传输的。

2）然后浏览器将接收到的**字节数据转化为字符串**。

3）浏览器再将这些字符串通过**词法分析**转化为**标记**（token）—— 代码的最小单位，这一过程叫做**标记化**。

4）标记化结束后，再将这些**标记转化为 Node 结点**，浏览器根据不同的结点构建称为**一颗 DOM 树**。

#### 2、构建 CSSOM 树

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1）将接受到的 **CSS 文件转化为 CSSOM 树**。这个过程和上述过程类似，但是有一点不同，浏览器**确定结点样式**，这个过程是**非常耗时**的。因为浏览器需要通过**递归的方式**寻到到 DOM 结点，然后给找到的元素设定好样式。

2）通过先找到**具体的标签**，然后递归找到该标签的**上级标签**，依次递归，最后**确定标签的样式**。

> 性能优化：所以应该避免写过于具体的 CSS 选择器，少加无意义的 HTML 标签，有利于提高页面的性能。

#### 3、生成渲染树（DOM + CSSOM）

> 构建了 DOM 树和 CSSOM 树之后，需要将这两课树合成渲染树。

1）两者合成不是简单的合成，而是渲染树只会包括需要**显示的结点和样式信息**，如果某个结点是 `display:none` ，那么不会在渲染树中显示。

2）然后生成渲染树之后，浏览器根据渲染树**进行布局**（**又称回流**），调用 **GPU 绘制**，合成图层，**显示在屏幕**上。



### 二、为什么操作 DOM 那么慢？（框架采用虚拟DOM的原因）

> 为什么操作 DOM 那么慢？

答：

1）因为**操作 DOM 是属于渲染引擎**的东西，而 **JS 属于 JS 引擎**的东西，所以我们通过 JS 操作 DOM 的时候，这个过程涉及到**两个线程的通**信，如果操作 DOM 次数过多，就相当于两个线程之间一直通信，那就回带来一些性能上的损耗。

2）操作 DOM **会导致重绘回流**的情况，性能就会有所下降。



> 既然操作 DOM 那么慢，怎么实现插入几万 DOM 不卡顿？

答：两种解决方案：

1）第一种通过 `requestAnimationFrame` 的方式循环插入 DOM。

2）第二种方式是通过**虚拟滚动**。

- **requestAnimationFrame 实现**

```javascript
const total = 30000;              // 总 DOM 数
const size = 100;                 // 每次渲染的 DOM 数
const bathCount = total / size;   // 一共处理 300 次
var countDone = 0;                // 已经处理完的多少次
const ul = document.querySelector('ul');

function addItems(){
    const fragment = document.createDocumentFragment();
    // 一次渲染 100 个DOM 
    for (var i = 0; i < size; i++) {
        var li = document.createElement('li');
        li.innerText = 'item ' + (countDone * size + i);
        fragment.appendChild(li);
    }

    // 每次插入 100 个结点就修改 DOM 一次
    ul.appendChild(fragment);

    // 已经完成插入的次数
    countDone++;

    // 判断是否处理完成
    if(countDone < bathCount){
        window.requestAnimationFrame(addItems);
    }
}
addItems();
```



### 三、浏览器阻塞页面渲染

> 什么情况下阻塞页面渲染？

答：

1） 因为浏览器首先生成渲染树之后才进行渲染，所以在**生成 DOM 树 和 CSSOM树的时候肯定会阻塞渲染**。

2）在遇到 `script` 标签的时候，也会暂停构建 DOM 树，加载完文件之后，再从暂停出继续构建 DOM 树。



> 怎样做出优化，使得首屏的渲染性能最佳？

答：

1）降低 HTML 和 CSS 文件的大小，优化选择器，减少构建 CSSOM 树的时间。

2）首屏加载 js 文件，将script 标签放在 body 的底部。

- 不是非要放底部，也可以给标签加上 `defer` (**表示 js 文件会并行下载，只有当HTML解析完才顺序执行**)和 `async` 属性（**没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染**）。



### 四、回流和重绘

> 什么是回流？

在文档流中的位置发生改变，回流是布局或者几何属性需要改变就称为回流。



> 什么是重绘？

在文档流中并没发生位置上的改变，重绘是当结点的外观发生变化而布局没有发生改变就叫做重绘。



> 那么如何减少回流和重绘呢？

答：

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）;
- 不要把节点的属性值放在一个循环里当成循环里的变量;



## 性能琐碎

#### 1、防抖

> 防抖就是设定一定的时间才执行任务，当用户在此时间内点击了，就会重新进行计时，待到用户不触发事件了，设定的任务才会去执行。

应用：

- input 输入框校验
- 输入数据出现下拉列表

```javascript
function debounce(func, delay) {
    var timeout;
    return function(e) {
        console.log("清除",timeout,e.target.value)
        clearTimeout(timeout);
        var context = this, args = arguments
        console.log("新的",timeout, e.target.value)
        timeout = setTimeout(function(){
          console.log("----")
          func.apply(context, args);
        },delay)
    };
};
```



#### 2、节流

> 在高频的事件触发中，为了能够减少触发的频率，让某个用户的方法某个时间段只执行一次。就是降低函数执行的频率。

应用：

- resize 调整窗口大小
- scroll 滚动
- 按钮保存点击

```javascript
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0
  return function(...args) {
    // 当前时间
    let now = +new Date()
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now
      func.apply(this, args)
    }
  }
}

setInterval(
  throttle(() => {
    console.log(1)
  }, 500),
  1
)
```



## 设计模式

#### 1、单例设计模式

> 在实际项目中用过什么设计模式？说说什么是单例设计模式？

答：把实现当前区域的属性和方法放在同一个命名空间下，而多个命名空间是互补干扰的。避免了全局变量的冲突和污染。



> 什么是高级单例模式？

答: 基于 JS 高阶编程技巧 ‘惰性思想’ （保存闭包机制）来实现的单例模式，并且可以把常用的设计模式（命令模式、发布订阅模式、promise 模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期的开发和维护,这种设计思想综合体就是高级单例模式，也是项目中最常应用的

```
补充：

- 单例模式：既方便私有，也方便共有。
- 闭包：只方便私有，不方便共有。
```



## Vue 框架

### MVVM

> 什么是 MVVM？

答：Model 就用纯 JavaScript 对象表示，View 负责显示，两者做到了极大限度的分离。把 Model 和 View 关联起来就是 ViewModel。ViewModel 主要负责把 Model 的数据同步到 View 显示，还负责把 View 修改的数据同步回 Model。



### 一、生命周期八个钩子函数

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed



### 二、生命周期每个阶段

#### 1、beforeCreate

> 这 beforeCreate 调用的时候，是获取不到 props 和 data 中的数据的，所有的数据都在初始化在 initState 中。



#### 2、Created 

> 可以访问之前不能够访问的数据，但是组件还没有挂载，所以看不到。



#### 3、beforeMount

> 如果有元素的话就继续往下编译，如果没有则停止编译，直到在虚拟 DOM 上挂载元素。然后通过渲染元素的优先级，render 函数 > template 选项 >  outer HTML。
>
> DOM 绑定的数据还没有进行渲染，处于占位状态，因为此时还没有挂载到页面上，JS中的虚拟DOM形式存在的。



#### 4、Mount

> 这一阶段将虚拟的DOM， 渲染成真实的 DOM并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。



#### 5、beforeUpdate 和 update

> 当 vue 发现data中的数据发生了改变，会**触发对应组件的重新渲染**，先后调用**beforeUpdate**和**updated**钩子函数。

另外还有 `keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。



#### 6、beforeDestroy 和 Destroy

> 最后就是销毁组件的钩子函数 `beforeDestroy` 和 `destroyed`。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 `destroyed` 钩子函数。



### 三、组件之间的通信

- 父子通信
- 兄弟组件通信
- 跨多层级组件通信
- 任意组件通信



#### 1、父子组件通信

- **方式一：静态传递数据**

​         单向数据流：父组件一般通过 props 传递数据给子组件，子组件通过 emit 发送事件传递给父组件，这两种方式是最常用的父子通信实现方法。



- **方式二：动态传递数据**

  可以用 v-bind 来实现。通过 v-bind 绑定 props 的自定义的属性。



- **方式三：通过$ref 实现通信**
  - **如果 ref 用在子组件上，指向的是组件实例**，可以理解为对子组件的索引，**通过$ref可能获取到在子组件里定义的属性和方法**。
  - 如果ref在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过$ref可能获取到该DOM 的属性集合，轻松访问到DOM元素，作用与JQ选择器类似。

```vue
 <!-- 父组件 -->

<template>
  <div>
    <h1>我是父组件！</h1>
    <child ref="msg"></child>
  </div>
</template>

<script>
  import Child from '../components/child.vue'
  export default {
    components: {Child},
    mounted: function () {
      console.log( this.$refs.msg);
      this.$refs.msg.getMessage('我是子组件一！') 
    }
  }
</script>
```

```vue
 <!-- 子组件 -->

<template>
  <h3>{{message}}</h3>
</template>
<script>
  export default {
    data(){
      return{
        message:''
      }
    },
    methods:{
      getMessage(m){
        this.message=m;
      }
    }
  }
</script>
```



- **方式四：**

  通过 `$children` 和  `$parent ` 获取到子组件或者父组件的实例来进行通信。



#### 2、兄弟组件通信

- **方式一：**

  字传父，父传子



- **方式二：**

  Vuex



- **方式三：**

  可以通过查找父组件中的子组件实现， `this.$parent.$children`，在 `$children`中可以通过组件 `name` 查询到需要的组件实例，然后进行通信。



#### 3、跨多层次组件通信

> 可以使用 Vue 2.2 新增的 API `provide / inject`

```vue
假设有父组件 A，然后有一个跨多层级的子组件 B

// 父组件 A
export default {
  provide: {
    data: 1
  }
}
// 子组件 B
export default {
  inject: ['data'],
  mounted() {
    // 无论跨几层都能获得父组件的 data 属性
    console.log(this.data) // => 1
  }
}
```



#### 4、任意组件通信

> 这种方式可以通过 Vuex 或者 Event Bus 解决。



### 四、keep-alive 组件有什么作用

> 需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 `keep-alive` 组件包裹需要保存的组件。

对于 `keep-alive` 组件来说，它拥有两个独有的生命周期钩子函数，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。



### 五、v-show 与 v-if 区别

#### 1、v-show

> `v-show` 只是在 `display: none` 和 `display: block` 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说在切换时开销更高，更适合不经常切换的场景。



#### 2、v-if

> 当属性初始为 `false` 时，组件就不会被渲染，直到条件为 `true`，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。



### 六、computed 和 watch 区别

#### 1、computed 

> 是计算属性，依赖其他属性计算值，并且 `computed` 的值有缓存，只有当计算值变化才会返回内容。



#### 2、watch 

> `watch` 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。



#### 3、两者的区别

> 一般来说需要依赖别的属性来动态获得值的时候可以使用 `computed`，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 `watch`。



### 七、data 什么时候可以使用对象？

> 组件复用时所有组件实例都会共享 `data`，如果 `data` 是对象的话，就会造成一个组件修改 `data` 以后会影响到其他所有组件，所以需要将 `data` 写成函数，每次用到就调用一次函数获得新的数据。

我们使用 `new Vue()` 的方式的时候，无论我们将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况了。



## Bootstrap

> 什么是 Bootstrap？什么是栅格系统？

答：

**Bootstrap：**Bootstrap 是一种用于快速开发 web 的应用程序和网站的前端框架。具有**移动设备优先**、浏览器支持良好、**容易上手**、**响应式设计**等优点。

**栅格系统：**Bootstrap 提供了一套**响应式、移动设备优先**的流式栅格系统，随着**屏幕或视口（viewport）尺寸**的增加，系统会**自动分为最多12列**。



> 栅格系统的工作原理？

答：





## 网络原理基础

### 一、输入 URL到页面渲染，经历了哪些过程？

> 输入 URL到页面渲染，经历了哪些过程？



#### 1、浏览器端

##### 1.1 输入

输入网址，浏览器会根据字符串匹配算法给出四五条搜索记录。

##### 1.2 判断URL是否合法

浏览器就会判断 URL 的合法性，如果不合法（采用的字符都是符合 ASCII），就要进行转义。

##### 1.3 HSTS 列表

HSTS 就是一种安全策略的机制，是为了让浏览器强制使用 HTTPS 访问的。当你的网站均采用 HTTPS，并符合它的安全规范，就可以申请加入 **HSTS 列表**，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。无论匹配到没有，都要开始 DNS 查询工作了。



#### 2、DNS 解析

##### 1.1 为什么需要 DNS 解析

因为 http 是基于 tcp 连接的，tcp 是需要通过 ip 地址去识别访问的。DNS 就是将域名转化成 ip 地址的过程。

##### 1.2 DNS 迭代查询过程

检测域名是否存在于**浏览器缓存**中，如果有缓存直接使用，没有则下一步，查看本机浏览器的 **dns 缓存**。

**1、系统缓存**

浏览器会调用一个类似 `gethostbyname` 的库函数，此函数会先去检测本地 hosts 文件，查看是否有对应 ip。

**2、路由器缓存、ISP 缓存**

如果浏览器和系统缓存都没有，就会向 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询**路由器缓存**，然后再查询 **ISP 的 DNS 缓存**（**PS：**ISP缓存，本身是一种宽带接入提供商给网页批量访问加速的技术。ISP会将当前访问量较大的网页内容放到ISP服务器的缓存中，当有新的用户请求相同内容时，可以直接从缓存中发送相关信息，不必每次都去访问真正的网站，从而加快了不同用户对相同内容的访问速度，同时也能节省网间流量结算成本）。

##### 3、 DNS 递归查询

根域服务器（.） ->  顶级域名服务器（eg: .com，.org）-> 主域名服务器（eg: google.com）

##### 1.3 迭代查询和递归查询的区别？

- **迭代查询：**DNS 收到请求时，而不是直接返回查询结果，而是告诉客户端另一台 DNS 服务器地址。然后客户端再向这台的 DNS 服务器提交请求，依次循环。
- **递归查询：**当 DNS 服务器收到请求时，就会检查 DNS 缓存，如果没有就会询问其他服务器，并将返回的查询结果返回客户端。

##### 1.4如何进行 DNS 优化？

DNS 查询经历很多步骤，查询很慢。浏览器获取到 IP 地址后，一般都会加到**浏览器的缓存**中，本地的 **DNS 缓存**服务器，也可以去记录。另外使用 **DNS 负载均衡**，通常我们的网站应用各种云服务，DNS 系统根据每台机器的负载量，地理位置的限制等等，去提供高效快速的 DNS 解析服务。



#### 3、TCP 连接

##### 3.1 TCP 的三次握手

##### 3.2 TCP 四次挥手

#### 4、HTTP 请求

##### 4.1 发送请求

通过 get 或 post 发送 HTTP 请求。 

##### 4.2 响应请求

通过服务器响应码判断请求是否成功。

#### 5、浏览器的渲染原理



### 二、OSI、TCP/IP、五层协议的体系结构

> 说说五层模型有哪些？各自的作用是什么？每层协议有哪些？各自的作用是什么？

答：从上到下分为：

- **应用层：**FTP、HTTP、DHCP、DNS
- **传输层：**UDP、TCP、
- **网络层：**IP
- **数据链路层：**以太网协议、ARK
- **物理层：**



#### 1、物理层

物理层通过物理手段将电脑连接起来，主要负传送 0 ，1 信号来通信。但是单纯的 0、1没有任何意义，也没有规定怎么结合，那么有了链路层。



#### 2、数据链路层

链路层诞生意味着通过规定的 “以太网” 协议规定的**电信号的分组形式**，不同分组代表不同的信息，双方通信都可以识别这些信息。

##### 2.1 以太网协议

以太网协议规定，每一组电信号就是就是一个**数据包**（帧：最短 64 字节，最长 1518 字节）。每个数据包分为：

- **标头(Head)：**数据包的说明，发送者、接受者、数据类型等。 
  - 长度：固定为 18 字节。
- **数据 (Data)：**数据包的具体内容。
  - 最短 46 字节，最长 1500 字节（**数据包超过这个就要进行分割**）

##### 2.2  MAC 地址

MAC 地址（六个十六进制）就是作为网络中所有设备做标识的，也就是数据包的发送地址和接受地址。

##### 2.3  广播

一个设备怎么知道另一个设备的 MAC 地址的？

- **同一子网络：ARP 协议**

  - **前提：**不知道对方的 `MAC` 地址。
  - **解决：**通过 **`ARP` 协议**得到对方的 `MAC` 地址。

  - **过程：**将对象的 MAC 地址放到数据包的头部，通过广播的方式对同一子网的所有设备发送该数据包，每个设备都会取出数据包标头中的 MAC 地址和自身的 MAC 地址做比较，如果两者相同，就接受这个包，作进一步的处理。否则就丢弃这个包。

- **不同子网络：**

  如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到**两个子网络连接处的"网关"**，**让网关去处理**。



#### 3、网络层 

**想要进行数据通信，必须知道两个地址：IP 地址/MAC 地址。**网络层的功能就是实现了**主机到主机**的通信（不同子网络下的通信）。

##### 3.1 网络地址                

不同子网之间的通信需要通过“路由”的方式，但是怎么判断两个设备是否在同一子网络中呢？所以就有了**网络地址，简称“网址”。** 

##### 3.2 IP 协议                   

- **由来：**无法判断两个设备是否在同一子网中。

- **组成：**IP 协议规定网络地址是由 32 个二进制位组成（四个十进制位），前一部分代表**网络的标识**，后一部分代表**主机标识**。
- **定义：** 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为 **IP 地址。**
- **作用：** 是为每一台计算机分配 IP 地址，是为了确定哪些地址在同一个子网络。

##### 3.3   子网掩码

- **由来：**IP 地址无法判断前多少位代表网络部分，后多少位代表主机部分，所以用**子网掩码**来解决。
- **组成：**网络部分全部为 1 表示，主机部分全部为 0 表示。(如果已知网络部分是前 24 位，主机部分是后 8 位，那么子网络掩码就是 `11111111.11111111.11111111.00000000`，写成十进制就是 `255.255.255.0`。）
- **作用：**将**两个IP地址**与**子网掩码**分别进行**AND运算（**两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

##### 3.4 IP 数据包

把 IP 数据包直接放进以太网数据包的"数据"部分，有一个好处就是**上层的变动完全不涉及下层的结构**。

- **标头：**20 ~ 60 字节，整个数据的长度最大为 65535 字节。
- **数据：**最长的数据部分为 65515 字节。需要分割成几个以太网的数据包发送（规定最长为 1500 字节）。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052910.png)

##### 3.5 ARP 协议

- **作用：**通过 `ARP` 协议获取到对方的 `MAC` 地址（通过 IP 地址得到 MAC 地址）。
- **前提：**对方的 `IP` 地址是已知的（**DNS 协议解析域名**）。
  - **过程：** `ARP` 协议发出一个数据包，包含在以太网的数据包中（其中包含对方的 `IP` 地址，对方的 `MAC` 地址栏是 `FF:FF:FF:FF:FF:FF`）。子网络中的每台主机都会收到这个包，然后从中取出 `IP` 地址与自身对比，如果两者相同，都做出回复，向对方报告自己的 `MAC` 地址，否则就丢弃这个包。



#### 4、传输层

传输层的功能就是建立**“端口到端口”**的通信。

##### 4.1  由来

不同的程序需要接收不同的数据，所以需要确定每个程序的端口和传入数据逇端口号。

##### 4.2  UDP 协议

加入端口号，需要 UDP 协议，将整个 UDP 的数据包放入 IP 数据包的数据部分。UDP 数据包也分为标头和数据部分：

- **标头：**发出端口和接收端口。
- **数据：**具体内容。
- **长度：**65,535 字节

##### 4.3 TCP 协议

- **由来：**UDP 虽然能完成两个主机之间的通信，但是数据包一旦发出，无法知道对方是否收到，所以 TCP 诞生了。
- **TCP 数据包：** TCP 数据包也会嵌入到 IP 数据包的数据部分。
- **长度：**理论上无限长，但是为了传输效率，不能超过 IP 数据包数据部分的长度（为了确保数据包不再分割）。



#### 5、应用层

应用层的功能就是规定了**应用程序的数据格式**。

##### 5.1 应用层数据包

应用层的数据包直接放在 TCP 数据包的 “数据” 部分。

![img](http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png)

不同的协议规定不同的数据格式，比如电子邮件、网页、FTP数据的格式，这些应用程序协议构成了“应用层”。



#### 小结

以上是自下而上的五层协议体系发送数据的过程，那么要想发送到另一台设备，必须知道对方的 IP 地址和 MAC 地址，这个过程是怎么样子的？



#### 6、用户网络配置：为新计算机配置 IP 地址

##### 6.1 上网参数配置

一般一台新的计算机上网必须设置一下四个参数：

- **本机的 IP 地址**
- **子网掩码**
- **网关的 IP 地址**
- **DNS 的 IP 地址**



##### 6.2 动态获取 IP 地址

- 网络中新加入的计算机需要分配 IP 地址，有两种方式，**静态 IP 地址和动态 IP 地址**。

- 由于设置静态的 IP 地址不够灵活，需要动态的分配 IP 地址，自动分配 IP 地址的协议叫做 `DHCP`  协议。

- DHCP 协议规定在同一子网络中，必须有一台计算机负责管理本网络中的所有 IP 地址，它叫做`“DHCP服务器”`。

- 一旦有新的计算机加入，新计算机必须向 "DHCP服务器" 发送一个 "DHCP请求" 数据包，**申请IP地址**。



##### 6.3 DHCP 协议

**1、DHCP 的数据包**

DHCP 是建立在 UDP 协议之上的，整个数据包如下：

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061102.png)

- **以太网标头：**设置发送方和接收方的 MAC 地址。但是只知道发送方的 MAC 地址，而不知道接收方的 MAC 地址。
- **IP 标头：** 设置发送方和接收方的 IP 地址。这两者本机都是不知道的，所以默认设置发送方的 IP 地址为0.0.0.0，接收方的 IP 地址设置为 255.255.255.255。
- **UDP 标头：**设置发送方和接收方的端口号。这部分是 DHCP 设置好的，**发送方是 68 端口号，接收方是 67 端口号。**



**2、DHCP 过程**

- 以太网以广播的方式发送这个数据包，同一个子网络中的所有计算机都会受到这个包。然后拆分数据包，接受方的 MAC 地址是 `FF-FF-FF-FF-FF-FF`，不知道是给谁发的。然后继续拆分数据包，**当看到发出方 IP 地址是 `0.0.0.0`，接收方是 `255.255.255.255`，于是 DHCP 服务器知道"这个包是发给我的"，**而其他计算机就可以丢弃这个包。

- 然后 DHCP 服务器读出这个包的数据内容，然后返回一个“DHCP”响应数据包。也是设置以太网标头（双方的网卡地址），IP 标头的 IP 地址是 DHCP 服务器的 IP 地址和接受方 `255.255.255.255` IP 地址，给该计算机**分配的 IP 地址**以及相关参数在数据包的**数据部分**。



#### 7、DNS 协议：获取接收方的 IP 地址

要想知道对方的 IP 地址，必须通过 DNS 解析域名。也是向 DNS 服务器发送 DNS 数据包，然后 DNS 服务器做出响应，返回对方的 IP 地址。



#### 8、子网掩码：判断两个主机是否在同一子网落中

两个设备的 IP 地址分别对子网掩码进行 AND 运算。如果结果相同，则为在同一自网络中，否则不在同一自网络中。如果同一网络中，就通过 IP 地址得到对方的 MAC 发送数据包。否则通过路由转发。



#### 9、HTTP 协议

![img](http://www.ruanyifeng.com/blogimg/asset/201206/bg2012061106.png)

HTTP 协议会嵌入到 TCP 协议中。



### 三、TCP 协议

> UDP 和 TCP 的区别是什么？

答：UDP 对于 TCP 传输数据是高效的，但是  TCP 相对于 UDP 是可靠性传输的。



> TCP 握手的作用是什么？

答：

- TCP 是**面向连接**的并保证了数据**可靠性传输**。
- TCP 三次握手客户端和服务端进行**相互确认**的过程。



> TCP 为什么要进行三次握手，为什么不是一次、两次？

**防止了服务器端的一直等待而浪费资源。**

答：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。如果此时客户端发送的延迟的握手信息服务器收到，然后服务器进行响应，认为客户端要和它建立连接，此时客户端并没有这个意思，但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。



> TCP 三次握手的过程是怎么样的？

答：

- **初始状态：** 客户端处于 `closed(关闭) ` 状态，服务器处于 `listen(监听)` 状态。
- **第一次握手：**客户端发送请求报文将 `SYN = j（1）` 初始化序列号发送给客户端，发送完之后客户端处于 `SYN_Send` 状态。
- **第二次握手：**服务端受到 `SYN` 请求报文之后，如果同意连接，会以自己的 `SYN(服务端) = K（0）` 和 `ack（1） = SYN(客户端) + 1(ACK = 1)` 报文作为应答，服务器为 `SYN_Receive`  状态。
- **第三次握手：** 客户端接收到服务端的 `SYN + ACK` ，然后发送 `ack = SYN(服务端) + 1(ACK = 1) `确认包作为应答，客户端转为 `established ` 状态。





> TCP 断开连接四次挥手过程是怎么样的？

**1、初始化状态：**刚开始双方都处于 **establised** 状态，客户端发起关闭请求。

**2、第一次挥手：**客户端发送一个 `FIN = 1` 报文，指定序列号`seq = u`。此时客户端处于**CLOSED_WAIT**状态。

**3、第二次挥手：**服务端收到 `FIN `之后，确定客户端请求释放连接，不再发送数据，但是还会接受数据。会发送 **(ACK = 1)ack = seq(客户端) + 1** (客户端的序列号加一)报文和指定一个序列号  **seq = v**，此时服务端处于 **CLOSE_WAIT** 状态。客户端收到服务端的确认之后进入等待状态。

**4、第三次挥手：**如果服务端发送完数据也想断开连接了，也会发送一个 `FIN = 1` 报文，且指定一个序列号 `seq = w`  和 **(ACK =  0)ack = u + 1**，此时服务端处于 **LAST_ACK** 的状态。

**5、第四次挥手：**客户端收到并回复一个确认信息**(ACK = 1)ack=seq(服务端)+1**，指定序列号**seq = seq(第一次挥手的 u) + 1**，此时客户端处于 **TIME_WAIT(2MSL)** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 **CLOSED** 状态。

**6、**服务端收到 ACK 报文之后，就处于关闭连接了，处于 **CLOSED（有个保活时间）** 状态。



> 为什么要等待 2MSL?

答： 是客户端向服务端确认的时候，包丢失了，导致服务端再次向 客户端发送 FIN = 1 的释放连接请求，这时 客户端 在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。



> 保活时间？

答：另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。



### 四、ARQ 协议

> 什么是 ARQ 协议？它的作用是什么？

ARQ 是超时重传机制，通过**确认**和**超时机制**确保了数据正确送达，ARQ 协议包含两种协议：

- 停止等待 ARQ 
- 连续 ARQ 



#### 4.1 停止等待 ARQ 

##### 1、正常传输过程

客户端向服务端发送一段报文，此时会启动一个定时器，等待对方的回应，在定时器设定的时间内，如果接受方应答了，那么就取消定时器并发送下一个报文。



##### 2、报文丢失或出错

在传输中，报文可能出现丢包的情况，这时候定时器设定的时间就会再次发送丢失的报文数据，直到服务端接收位置，所以每次都要备份发送的数据。

即使接收端接收成功，但是报文在传输中出现错误，此时服务端会抛弃该报文，等待客户端的重传。

> PS：一般定时器设定的时间会大于一个 RTT（往返时延：从发送端发送到发送端接受响应的延时时间） 的平均时间。



##### 3、ACK 超时或丢失

即使发送端传输过程中没有出现丢包问题，但是在服务器返回数据的时候可能出现丢包问题，这时候客户端会重新发送报文，服务端收到相同序列号的报文会丢弃该报文重新应答，直到客户端发送下一序号的报文为止。

在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。



#### 4.2 连续 ARQ

##### 1、由来

上边的停止等到 ARQ协议，即使在网络好的情况下也使用的话，每次发送数据都要等待，效率很低，所以就有了连续 ARQ 协议。



##### 2、连续发送

在连续 ARQ 中，发送端拥有一个**发送窗口**，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。



##### 3、累积确认

连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。



##### 4、累积确认的弊端

在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接收到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。



### 五、滑动窗口

在 TCP 中，发送端和接收端都维护着窗口：分别为发送端窗口和接收端窗口。

- 发送端窗口：包含已发送未应答的数据和未发送的数据。
- 接收端窗口：包含已经接收的数据。



##### 5.1滑动窗口的基本概念

> 为什么实现滑动窗口？

答：滑动窗口是一个很重要的概念，它帮助 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况（PS：发送端一直发送就会导致拥塞）。



> TCP 滑动窗口是如何对流量进行控制的？

答：

1、发送端的窗口是由接收端窗口剩余大小决定的，接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

2、当发送端接收到应答报文后，会随之将窗口进行滑动



##### 5.2 Zero 窗口

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。



### 六、拥塞处理

拥塞处理主要作用域接收方，保证接收方及时及接受数据。拥塞处理的四个算法：

- **慢开始算法**
- **拥塞避免算法**
- **快速重传算法**
- **快速恢复算法**



> 说一下 TCP 的拥塞处理处理？

##### 6.1 慢开始算法

**1、作用：**慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。（下载文件）



**2、步骤：**

- 创建连接之后，初始设置拥塞窗口为 1 MSS（一个分段的最大数据量）
- 每过一个 RTT（往返时间）就将窗口大小乘以 2 。
- 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。



##### 6.2 拥塞避免算法

**1、设计：**拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。



**2、定时器超时处理：**在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了。

- 将阈值设为当前拥塞窗口的一半；
- 将拥塞窗口设为 1 MSS；
- 启动拥塞避免算法；



##### 6.3 快速重传算法和快速恢复算法

1、一旦接收端报文出现失去顺序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无序等待定时器超时而是直接启动快速重传算法。具体分为两种：



**2、TCP Taho 实现如下**

- 将阈值设为当前拥塞窗口的一半
- 将拥塞窗口设为 1 MSS
- 重新开始慢开始算法



**3、TCP Reno 实现如下**

- 拥塞窗口减半
- 将阈值设为当前拥塞窗口
- 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了
- 使用拥塞避免算法



##### 4、TCP New Ren 改进后的快恢复

**TCP New Reno** 算法改进了之前 **TCP Reno** 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 **TCP New Reno** 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。



### 七、HTTP/TLS 协议

> HTTP 请求首部的组成及其作用是什么？

答：组成：

- **请求行：**请求方法、URI、HTTP版本。
- **请求首部：**主要传递重要信息，如：为浏览器和服务器提供报文主题大小、所使用的语言、内容信息大小。
- **实体：**传递的信息内容。



> Post 和 Get 请求的区别？

答：

- **大小区别:**

Get 传递内容给服务器存在大小限制的，而POST理论上是没有限制的。

原因:每个浏览器对于 URL 的长度是存在限制的，谷歌:8kb, 火狐:7KB, IE:2kb 的长度。如果超过URL 的长度，就会对 URL 字段进行截取。

- **缓存问题:**

Get 请求会出现缓存(这个缓存不一定是304),POST 是没有缓存的。

在项目中，一般不让其出现缓存"清除缓存"（URL一样）:在 URL 的末尾追加一个随机数。

xhr.open("get","/getList?num=2&_=" + Math.random())

- **安全问题:**

一般来说GET不安全，而POST相对安全一些。（URL劫持）



> 常见的状态码有哪些？分别代表什么？

答：

- 1XX（信息性状态码） :  服务器正在处理请求中。
- 2XX （成功状态码）:  请求处理完毕。
- 3XX （重定向状态码）:  需要附加操作以完成请求。
  - 301：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后使用该资源，使用现在所指 URI。
  - 302：临时性重定向。表示该状态码被分配了新的 URI，希望用户本次能够使用新的 URI 访问。
  - 304：服务器资源未改变，可直接使用客户端未过期的缓存。
- 4XX （客户端错误状态码）:  服务器无法处理请求。
  - 400：该请求报文中有语法错误。
  - 403：没有资源的访问权限。
  - 404：找不到资源。
- 5XX （服务端错误状态码）:  服务器处理请求出错。
  - 500：服务器发生错误
  - 503：服务器超荷载或正在维护。



> 什么是TLS？

答：

HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。

TLS 协议位于**传输层之上，应用层**之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 `Session Resumption` 减少到一个 RTT。



> TLS 的两种加密方式？

答：两种加密方式：

- **对称加密：**对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

  > 这种加密虽然好，但是问题就是如何让对方知道你的秘钥？传输数据是在网络中进行的，如果秘钥通过网络传输，一旦被截取，就是去了意义。

- **非对称加密**：有两种秘钥，公钥和私钥，公钥所有人都知道，可以用公钥加，但是数据的解密需要私钥，私钥只有分发公钥的一方才知道。

  > 非对称加密解决了对称加密的问题，在进行对称加密之前，进行一个非对称加密。

  **流程：**

  首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。



> TLS 的握手流程？

答：

1、客户端发送一个随机值以及需要的协议和加密方式。

2、服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）

3、客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书

4、服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

5、通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

> PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。



## 如何正确的向面试官提问？

**1、问题一：你们为什么要招聘这个职位？**

这个问题会使得面试官开始谈论当前的项目，或者谈论前一位离职人员。无论哪种情况，都会让你了解，一些与你最密切相关的公司情况。

**2、问题二：你们的新员工多吗？**

这个问题起一个过渡作用，使得谈话导向公司内部的情况。但是，它本身也能说明一些问题。如果公司成立已经超过四年，又没有新项目，但是新员工却很多，这往往说明公司文化不是很健康。

**3、问题三：你们公司（团队）目前面临的最大挑战是什么？**

如果面试官开始谈论一些具体的技术问题，这很好；如果他的回答是项目时间紧迫，或者需要更多的资金，那你就要小心一点了，公司管理上面可能有问题。

**4、问题四：什么新技术（编程语言）是你们未来希望采用的？**

如果你申请的是技术职位，面试官恰巧又是技术负责人，那么这个问题将会非常合适。你会对公司的技术路线有所了解和准备，一旦入职，就能更好地适应公司的需要。

**5、问题五：在业务方面，有没有什么地方是你们不满意的，未来想要改进的？**

很少有公司，会百分之百满意自身的现状，即使那些状况很良好的公司也是如此。这个问题可以让你对公司管理层的关注重点和担忧之处，有所了解。

**6、问题六：我申请的这个职位，对公司的业务有何影响？**

这个问题会让你了解自己在公司的角色，以及你的岗位对公司是否重要。