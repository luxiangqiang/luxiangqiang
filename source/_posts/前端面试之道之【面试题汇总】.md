---
title: 前端面试之道之【面试汇总】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试
password: lxq
---

前端 js、css、vue等面试题解答汇总。

<!--more-->

[TOC]



## 一、CSS 篇

#### 1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？

> ① 标准盒子模型：宽度 = 内容的宽度`（content）+ border + padding + margin`
> ② 低版本 IE 盒子模型：宽度 = 内容宽度`（content+border+padding）+ margin`



#### 2、 box-sizing属性？

> 用来控制元素的盒子模型的解析模式，默认为 `content-box`。

① `context-box：` W3C 的标准盒子模型，设置元素的 `height/width` 属性指的是 `content` 部分的高/宽
② `border-box：` IE 传统盒子模型。设置元素的 `height/width` 属性指的是 `border + padding + content` 部分的高/宽。



#### 3、 CSS 选择器有哪些？哪些属性可以继承？

**① 选择器：**

- ID 选择器、类选择器、标签选择器；

- 相邻选择器（+）、子元素选择器（>）、兄弟选择器（~）、后代选择器（ul li）、通配符选择器（*）；
- 属性选择器（a[href="...l"]）；
- 伪类选择器（a:hover, li:nth-child）



**② 可继承属性：**font-size、font-family、color。

**③ 不可继承属性：**border、padding、 margin、 width、height

**④ 优先级：**important > 内嵌样式 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪元素 > 继承 > 通配符

> 注意：important 提高 css 样式的权重，在 IE 中失效。



#### 4、说说你对伪类和伪元素的了解，分别举出五个例子。

**① 伪类和伪元素**

伪类：伪类用于某些**选择器**添加特殊效果。

伪元素：为某些**元素**添加特殊效果。



**② 两者区别：**

- 伪元素相当于添加元素设置元素，而伪类是在元素添加效果。两者都不存在于 dom 树中，是文档流之外的东西。
- 伪类没有数量上的限制，只要两个伪类不相互排斥，可同时使用在同一元素上。



**③ 伪元素**

- :: before
- :: after

- :: first-line
- :: first-letter
- :: last-letter



**④ 伪类**

- : first-child
- : visitive
- : hover
- : active
- : focus
- : lang



**⑤ CSS3 新增伪类**

- p:first-of-type: 选择父元素的首个元素。
- p:last-of-type: 选择属于其父元素的最后一个元素。
- p:nth-child(2): 选择其父元素的第二个子元素。
- p:only-of-type: 选择属于其父元素没有兄弟节点唯一元素。
- p:first-child: p:last-child 选择父元素的第一个元素或最后一个元素
- div:not(div2)  除 div2 的所有元素（否定伪类选择器）。
- :enabled  disabled 表单控件的禁用状态。
- :checkd 单选框或复选框被选中。



#### 5、 CSS 优先级怎么计算？

> **特指度：**表示一个 css 选择器表达式的重要程度，**哪个的计算结果大，浏览器就会以哪个为优先。**

**① 计算方法**

- 通用选择器（*）、子元素选择器（>）、相邻兄弟选择器（+）  +0

- element 元素选择器：+1；
- class 选择器、伪类选择器、属性选择器：+10；
- id 选择器：+100；
- 内联样式 +1000



**② 计算规则**

- !important 声明的样式优先级最高，如果冲突再进行计算。
- 如果优先级相同，则选择最后出现的样式。
- 继承得到的样式优先级最低。



#### 6、 display有哪些值？说明他们的作用?

- inline：内联（默认值）；

- none：隐藏（不占空间）；

- block：块显示；

- block-inline：内联块级元素呈现；

- table：表格显示。

  

#### 7、position的值？

- static：（默认）按正常文档流排序；
- relative：相对定位。不脱离文档流，通过静态位置top、left、right、bottom定位；
- absolute：绝对定位。参考距其最近一个不为 static 的父级元素通过 top、bottom、left、right 定位。

- fixed：固定定位。所固定的参照对象是**可视窗口**。



#### 8、纯CSS实现三角形原理

> 均分原理。

```javascript
.triangle{
    width: 0;
    height: 0;
    border-top: 40px solid transparent;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 40px solid #ff0000;
}
```



#### 9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？

① 如何居中一个 div？

```javascript
margin:0 auto;
```

② 如何居中一个浮动元素？

> flexbox 居中

③ 如何让绝对定位的 div 居中？

> flexbox 居中
>



#### 10、谈一下你对 Flexbox 的了解，以及适用场景？

> Flex 布局提供了更高效的对容器进行布局、对齐和分配空间。传统的布局，block 垂直从上到下布局；而 inline 布局则是水平方向排列。Flex 没有在方向上的限制，可自由操作。



#### 11、为什么要初始化CSS样式？

> 由于浏览器的兼容性问题，不同浏览器的某些标签的默认值是不相同的，如果没有对 CSS 初始化，往往会出现浏览器之间的页面显示差异。

```css
// 淘宝初始化统一规范
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } 
body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; } 
h1, h2, h3, h4, h5, h6{ font-size:100%; } 
address, cite, dfn, em, var { font-style:normal; } 
code, kbd, pre, samp { font-family:couriernew, courier, monospace; } 
small{ font-size:12px; } 
ul, ol { list-style:none; } 
a { text-decoration:none; } 
a:hover { text-decoration:underline; } 
sup { vertical-align:text-top; } 
sub{ vertical-align:text-bottom; } 
legend { color:#000; } 
fieldset, img { border:0; } 
button, input, select, textarea { font-size:100%; } 
table { border-collapse:collapse; border-spacing:0; } 
```



#### 12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？

① 在谷歌浏览器中，使用 collapse 属性值和使用 hidden 没有区别。

② 在火狐以及 opera 和  IE 中，使用 collapse 的值和使用 display：none 没有什么区别。 



#### 13、display:none 与 visibility：hidden 的区别？

- display: none 不显示对应的元素，在文档流中**不分配空间**。（回流+重绘）
- visibility: hidden 隐藏对应元素，在文档中仍然**保留原来的空间**。（重绘）



#### 14、对 BFC 的理解？

> BFC 称为块级格式化上下文，是一个独立的容器，容器里边的内容不会影响到外边的内容，这个隐藏的属性需要被触发。    



**①  触发 BFC 的条件：**

- 根元素（html）;
- float 的值不为 none ;
- overflow 的值不为默认的 visible ;
- display 的值为 inline-block、table-cell、table-caption ;
- position 的值为 absolute 或 fixed。



**② BFC 的规则**‘

> 1）在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）。
>
> 2）相邻两个盒子之间的垂直的间距是被 margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直 margin 是折叠的。—— margin 上下折叠问题
>
> 3）BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。—— margin 高度塌陷



#### 15、浮动带来的问题？以及清除浮动的方式？

**① 浮动问题：**

- 父容器的高度无法撑开。
- 覆盖后边跟随的元素。



**② 清理浮动：**

- overflow:hiddle(当子元素超出父元素，就会出现问题)
- clear: both 属性解决。
- 利用伪元素（::after）的方法。



#### 16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？

**① margin 折叠问题：**

> 当两个盒子的垂直外边距 margin 是邻接的（相接触的），两个盒子就会使用一个外边距，外边距以高度最大值为准。（同一 BFC 中）
>
> - 兄弟元素折叠
> - 父子元素折叠



**解决：**处在不同的 BFC 中。

**1、 兄弟元素折叠解决办法**

- 将元素设置为浮动 float:left;。 
- 在设置 margin-top/bottom 值时统一设置上或下。
-  元素的 position 的值为 absolute/fixed。



**2、父子折叠解决办法：将两个 margin 隔离开，不直接相接触。**

- 父元素设置 border；
- 父元素设置 padding；
- 父元素设置 overflow（父元素就为BFC，BFC 特性之一为内外不相互影响）；



**② margin 塌陷问题：**

> **高度塌陷：**浮动的子元素无法撑开父元素的高度，导致父元素高度塌陷（浮动元素为一个 BFC ，所以不影响其他 BFC 外元素）。
>
> **嵌套塌陷：**父盒子和子盒子存在嵌套关系的时候，子盒子和父盒子共用一个 margin。



**解决：**

1、高度塌陷解决办法：

- 清除浮动的方法。
- 父元素设置 overflow 属性（此时父元素也为 BFC，让浮动的元素正常溜排列，不能脱离文档流）



#### 17、移动端的布局用过媒体查询吗？

> 通过媒介查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应设备上的显示。

```html
1、在 head 标签中
<link rel="stylesheet" type="text/css" href="xx.css" media="only screen and (max-device-width:480px)">
```

```css
1、在 css 中设置
@media only screen and (max-device-width:480px){
    // css样式
}
```



#### 18、css 预处理器

- Less 是一个动态 CSS 语言框架，Less 扩展了 CSS 的动态特性。（变量、混入、嵌套、函数）。
- SASS 是一种 CSS 的开发工具，提供了许多便利的写法。



#### 19、margin 和 padding 分别适合什么场景使用？

① 什么时候使用 margin?

- 需要在 border 外侧添加空白；
- 空白处不需要背景颜色；
- 上下相连的两个盒子之间的空白，需要相互抵消时。



② 什么时候使用 padding？

- 需要在 border 内侧添加空白
- 空白处需要背景颜色
- 上下相连的两个盒子的空白，希望为两者之和



#### 20、display:inline-block 什么时候会显示间隙？

- 有空格时候会有间隙解决：移除空格
- margin 正值的时候 解决：margin使用负值



#### 21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理?

- scroll：出现滚动条。
- auto：子元素内容大于父元素内容出现滚动条。
- visible：溢出内容出现在父元素之外。
- hidden：溢出隐藏。



#### 22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？

① 响应式设计网站是一个网站能够兼容多个终端。

② 基本原理：通过媒介查询检测不同设备屏幕尺寸做处理。

③ 兼容 IE：头部必须有 meta 声明的 viewport。



#### 22、px、em、rem 有什么区别？

**px：**





## JavaScript 篇

#### 1、原始类型

> 定义：原始类型都是存储的值，没有函数可以调用，共有六种原始类型。

- string
- number
- boolean
- undefined
- null
- symbol



#### 2、关于 null 和 undefined 的区别？

① `null` 表示"没有对象"，即该处不应该有值。

② `undefined` 表示"缺少值"，就是此处应该有一个值



#### 3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？

① 原始类型存储的是指针，对象类型存储的是地址。

② 对象之间的赋值，是地址的赋值，改变对象的值，导致两个变量的值都会发生改变。



#### 4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？

**①  `typeof`**

>  对于原始类型来说，除了 `null` 都可以显示正确的类型。

```javascript
typeof 1         // 'number'
typeof '1'       // 'string'
typeof undefined // 'undefined'
typeof true      // 'boolean'
typeof Symbol()  // 'symbol'
typeof null      // 'object'
typeof {}        // 'object'
typeof console.log()// 'fuction'
```



**②  `instanceof`**

> 判断一个对象的正确类型，可以使用 `intanceof` ，因为内部机制是**通过原型链来判断的**。**`instanceof `** 检测左侧的 `__proto__` 原型链上，是否存在右侧的 `prototype ` 原型。

```javascript
const Person = function() {}
const p1 = new Person()
// p1._proto_._proto_ 原型链上是否存在 Person.prototype
p1 instanceof Person // true
```



#### 5、类型转换

![img](https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### ① 转换 Boolean 类型

> `undefined`、`null`、`false`、`NAN`、`‘ ’`、`0`、`-0` 值为 false，其他值都为 true。



#### ② 对象转原始类型

> 对象转换类型的时候，会调用内置的  [[ToPrimitive]]  函数，该函数的逻辑为：

- 如果为原始类型，就不转换；
- 需要转字符串，调用  `x.toString()`  方法。不是字符串类型就用 `x.valueOf()` 方法。

- 如果都没有返回原始类型，就会报错;



> **补充：**x.toString 和 x.valueOf() 的区别？

- x.toString：将转化的类型用字符串表示。

```javascript
var a = 3;
var b = '3';
var c = true;
var d = {test:'123',example:123}
var e = function(){console.log('example');}
var f = ['test','example'];

a.toString();// "3"
b.toString();// "3"
c.toString();// "true"
d.toString();// "[object Object]"
e.toString();// "function (){console.log('example');}"
f.toString();// "test,example"
```

- x.valueOf：将返回自身的值。

```javascript
var a = 3;
var b = '3';
var c = true;
var d = {test:'123',example:123}
var e = function(){console.log('example');}
var f = ['test','example'];

a.valueOf();// 3
b.valueOf();// "3"
c.valueOf();// true
d.valueOf();// {test:'123',example:123}
e.valueOf();// function(){console.log('example');}
f.valueOf();// ['test','example']
```



#### 6、四则运算符

- 其中一个为字符串，另一个就会转化为字符串。
- 其中一方不是数字，就会转换字符串。
- 除了加法运算外，只要一方为数字，另一方也会转换为数字。

```javascript
4 * [] // 0
```

- `+ 'b'` 等于 `NaN`

```javascript
'a' + + 'b' // -> "aNaN"
```



#### 7、比较运算符

- 如果是对象，就通过 valueOf 转化原始类型再比较。

- 如果是字符串，就通过 `unicode` 字符索引来比较

```javascript
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```



#### 8、逻辑运算符（&& 与 ||）

> 默认情况下返回布尔类型，但是也可以返回一个操作数。

| 运算符         | 语法             | 说明                                                         |
| :------------- | :--------------- | :----------------------------------------------------------- |
| 逻辑与（`&&`） | `expr1 && expr2` | 若 `expr1` 可转换为 `true`，则返回 `expr2`；否则，返回 `expr1`。 |
| 逻辑或（`||`） | `expr1 || expr2` | 若 `expr1` 可转换为 `true`，则返回 `expr1`；否则，返回 `expr2`。 |
| 逻辑非（`!`）  | `!expr`          | 若 `expr` 可转换为 `true`，则返回 `false`；否则，返回 `true`。 |

```javascript
a5 = "Cat" && "Dog"     // t && t 返回 "Dog"
a6 = false && "Cat"     // f && t 返回 false
a7 = "Cat" && false     // t && f 返回 false
a8 = ''    && false     // f && f 返回 ""
a9 = false && ''        // f && f 返回 false
```

```javascript
o5 = "Cat" || "Dog"     // t || t 返回 "Cat"
o6 = false || "Cat"     // f || t 返回 "Cat"
o7 = "Cat" || false     // t || f 返回 "Cat"
o8 = ''    || false     // f || f 返回 false
o9 = false || ''        // f || f 返回 ""
```



#### 8、运算符的优先级

|   操作符分类   |                            操作符                            |
| :------------: | :----------------------------------------------------------: |
| 算 术 操 作 符 |                              +                               |
|       ++       |                            (自增)                            |
|       ––       |                            (自减)                            |
|       *        |                            (乘法)                            |
|       /        |                            (除法)                            |
|       %        |                            (求余)                            |
|     **&&**     |                        **（逻辑与）**                        |
|    **\|\|**    |                         **(逻辑或)**                         |
|     **!**      |                         **(逻辑非)**                         |
|       <<       | (左移) 将第一操作数的二进制形式的每一位向左移位，所移位的数目由第二操作数指定。右面的空位补零。 |
|       >>       | (算术右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位。 |
|      >>>       | (逻辑右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位，左面的空位补零。 |
|       =        |                          赋值操作符                          |
|       ==       |                        相等的话返回真                        |
|       !=       |                如果操作数不相等的话则返回真。                |
|       >        |            如果左操作数大于右操作数的话则返回真。            |
|       >=       |          如果左操作数大于等于右操作数的话则返回真。          |
|       <        |            如果左操作数小于右操作数的话则返回真。            |
|       <=       |          如果左操作数小于等于右操作数的话则返回真。          |



#### 8、如何正确判断 this？箭头函数的 this 是什么？

① 三种 this 场景：

- 全局调用函数，内部的 this 永远指向 windows 。
- 对象调用函数，谁调用 this ，this 就指向谁。
- new 的方式，this 永远绑定在 new 出的对象。



② 箭头函数中的 this：

- 箭头函数中是没有 this 的。
- 箭头函数中的 this 是指向包裹箭头函数的第一个函数的。



③ bind 中的 this：

- `this` 取决于第一个参数，如果第一个参数为空，那么就是 `window`。

```javascript
fun.bind(a) // 函数.bind(参数)
```



④ 多种规则出现的优先级

> 箭头函数一旦绑定了 this，就不会被人和方式所改变。

new ——> bind ——> obj.foo() ——> 全局调用。

![img](https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 8、call 、apply、bind 的区别

> 三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。

**共同点：**

① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；

② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；

③ apply 、 call 、bind 三者都可以利用后续参数传参；

**不同点：**

①  call 顺序传参，而 apply 是数组传参。

② bind 的 `this` 取决于第一个参数，如果第一个参数为空，那么就是 `window`。

③ bind 是返回对应函数（**需要加一对花括号进行调用**），便于稍后调用；apply 、call 则是立即调用 。



#### 9、call、apply 及 bind 函数内部实现是怎么样的？

###### ▉ Call 的内部实现

- 首先 `context` 为可选参数，如果不传的话默认上下文为 `window`
- 接下来给 `context` 创建一个 `fn` 属性，并将值设置为需要调用的函数
- 因为 `call` 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来
- 然后调用函数并将对象上的函数删除



> **※ 手写一个 call 方法：**

```javascript
// this 为调用的函数
// context 是参数对象
Function.prototype.myCall = function(context){
    // 判断调用者是否为函数
    if(typeof this !== 'function'){
        throw new TypeError('Error')
    }
    // 不传参默认为 window
    context = context || window
    // 新增 fn 属性,将值设置为需要调用的函数
    context.fn = this 
    // 将 arguments 转化为数组将 call 的传参提取出来  [...arguments]
    const args = Array.from(arguments).slice(1)
    // 传参调用函数
    const result = context.fn(...args)
    // 删除函数
    delete context.fn
    // 返回执行结果
    return result;
}
// 普通函数
function print(age){
    console.log(this.name+" "+age);
}
// 自定义对象
var obj = {
    name:'小鹿'
}
// 调用函数的 call 方法
print.myCall(obj,1,2,3)
```



###### ▉ apply 的内部实现

- 首先 `context` 为可选参数，如果不传的话默认上下文为 `window`
- 接下来给 `context` 创建一个 `fn` 属性，并将值设置为需要调用的函数
- 因为 `apply` 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用
- 然后调用函数并将对象上的函数删除



> **※ 手写一个 apply 方法：**

```javascript
// 手写一个 apply 方法
Function.prototype.myApply = function(context){
    // 判断调用者是否为函数
    if(typeof this !== 'function'){
        throw new TypeError('Error')
    }
    // 不传参默认为 window
    context = context || window
    // 新增 fn 属性,将值设置为需要调用的函数
    context.fn = this
    // 返回执行结果
    let result;
    // 判断是否有参数传入
    if(arguments[1]){
        result = context.fn(...arguments[1])
    }else{
        result = context.fn()
    }
    // 删除函数
    delete context.fn
    // 返回执行结果
    return result;
}

// 普通函数
function print(age,age2,age3){
    console.log(this.name+" "+ age + " "+ age2+" "+age3);
}
// 自定义对象
var obj = {
    name:'小鹿'
}
// 调用函数的 call 方法
print.myApply(obj,[1,2,3])
```



###### ▉ bind 的内部实现

- 判断调用者是否为函数。
- 截取参数，注意：这里有两种形式传参。
- 返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用）



>  **※ 手写一个 bind方法：**

```javascript
// 手写一个 bind 函数
Function.prototype.myBind = function (context) {
    // 判断调用者是否为函数
    if(typeof this !== 'function'){
        throw new TypeError('Error')
    }
    // 截取传递的参数
    const args = Array.from(arguments).slice(1)
    // _this 指向调用的函数
    const _this = this;

    // 返回一个函数
    return function F(){
        // 因为返回了一个函数，我们可以 new F()，所以需要判断
        // 对于 new 的情况来说，不会被任何方式改变 this
        if(this instanceof F){
            return new _this(...args,...arguments)
        }else{
            return _this.apply(context,args.concat(...arguments))
        }
    }
}

// 普通函数
function print(){
    // new 的方式调用 bind 参数输出换做 [...arguments]
    console.log(this.name);  
}
// 自定义对象
var obj = {
    name:'小鹿'
}
// 调用函数的 call 方法
let F = print.myBind(obj,1,2,3);
// 返回对象
let obj1 = new F();
console.log(obj1);
```



#### 10、== 和 === 有什么区别？

> == 如果类型不相同，则先进行类型转换。=== 判断两者的**类型和值**是否相同。



**① == 比较规则**

- 若类型相同，则直接比较大小；类型不同，先进行转换。
- 判断 null == undefined 返回 true。
- 判断 string 和 number 时，将字符换转化为 number。
- 判断其中一方为 boolean 值时，将 boolean 转化为 number。
- 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断。



![img](https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageslim)



#### 11、闭包有关面试题？

> 要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承



**① 什么是闭包？**

> **闭包**是有权限访问其他函数作用域内的变量的一个函数。



**② 闭包为什么可以有权访问到？**

> 在 js 中，变量的作用域属于函数域，当函数执行完毕时，作用域就会被清理，内存被回收。但是闭包是建立在一个函数的内部的子函数，可以访问上级作用域，上级函数执行完后，作用域不会销毁，所以闭包可以访问上级作用域的权限，上级函数执行完后作用域内的值也不会销毁。



**③ 闭包解决了什么？**

> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的 Ajax 成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。



**④ 闭包有哪些应用场景？**

> 闭包随处可见，一个 Ajax 请求的成功回调，一个事件绑定的回调方法，一个 setTimeout 的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。



**⑤ 经典面试题**

```javascript
for(var i = 1;i <= 5;i++){
    (function(j){
        setTimeout(function timer(){console.log(j)},j*1000)
    })(i)
}
```



#### 12、立即执行函数

**① 什么是立即执行函数**

> 声明一个匿名函数，并立即执行。

```javascript
// 写法一：
(function(){alert('我是匿名函数')})()
// 写法二：
(function(){alert('我是匿名函数')}())
```



**② 立即执行函数有什么作用？**

> js 没有块级作用域，创建一个独立的作用域，用来隔离作用域避免污染。



**③ 经典面试题**

```javascript
  for(var i = 1;i <= 5;i++){
      (function(j){
          console.log(j)
      })(i)
  }
```



#### 13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？

> 对象赋值其实复制了地址，一方改动会导致另一方的值也改动。可以通过浅拷贝来解决这个问题。



**① 浅拷贝 **

###### ▉ Object.assign()  

> Object.assign()  可以实现一个浅拷贝，将 `source` 的所有属性值拷贝到 `target` 新对象中。如果属性是对象的话，拷贝的是地址。

```javascript
let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```



###### ▉ `...` 扩展运算符

> 扩展运算符也可以实现一个浅拷贝。

```javascript
let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
```



###### ▉**实现一个浅克隆**

> 自己实现一个浅拷贝，和上边的两种实现没什么差别。

```javascript
 // 实现浅克隆
function shallowClone(o){
    const obj = {};
    for(let i in o){
        obj[i] = o[i]
    }
    return obj;
}
```



**② 深克隆**

> 对于多层嵌套的对象，浅克隆就是失去了作用。



###### ▉ 序列/反序列化（parse/stringify）

**序列化：**把变量从内存中变成可存储或传输的过程称之为序列化。stringify 方法可以将 JS 对象序列化成 JSON 字符串。

**反序列化：**把变量内容从序列化的对象重新读到内存里称之为反序列化。JSON对象parse 方法可以将 JSON 字符串反序列化成 JS 对象。

```javascript
const newObj = JSON.parse(JSON.stringify(oldObj));
```

**缺点：**

1、无法实现对函数、RegExp 等特殊对象的克隆。

2、会抛弃对象的 constructor，所有的构造函数会指向 Object。

3、对象有循环引用，会报错。



###### ▉ 实现一个深克隆函数

> 序列/反序列化不可能实现了，所以实现一个对象类型判断函数。要面对不同的对象(正则、数组、Date等)要采用不同的处理方式。推荐使用 lodash 函数。

```javascript
const isType = (obj, type) => {
  if (typeof obj !== 'object') return false;
  const typeString = Object.prototype.toString.call(obj);
  let flag;
  switch (type) {
    case 'Array':
      flag = typeString === '[object Array]';
      break;
    case 'Date':
      flag = typeString === '[object Date]';
      break;
    case 'RegExp':
      flag = typeString === '[object RegExp]';
      break;
    default:
      flag = false;
  }
  return flag;
};

const arr = Array.of(3, 4, 5, 2);
console.log(isType(arr, 'Array')); // true
```



#### 14、Object 和 Function 的关系

> ① 所有的构造函数的 `_proto_`  包括 `Object` 和 `Function` 本身都指向 `Function.prototype `。（可以理解为所有的构造函数都是 `Function` 的实例）。
>
> ② 因为所有的对象实例的 `_proto_` 都指向 `Object.prototype ` ，又因为所有的原型对象都是 Object 的实例，包括 `Function` 的原型 `Function.prototype ` ，所以 `Function.prototype` 也指向 `Object.prototype`。
>
> ③ `Object.prototype` 的 `_proto_` 最终指向 `null`。

er![JavascriptçPrototype,Function,Object,__proto__å³ç³»ç¤ºæå¾](https://img-blog.csdn.net/20151118103413727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 15、你理解的原型是什么？

> 每个 JS 对象都有一个 \_proto_ 属性，这个属性指向了原型。原型中定义了很多属性和函数，其中的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型，这个属性和  `_proto_` 属性指向是同一原型。并不是所有的函数都具有 `prototype` 的属性，`bind `函数就没有。



#### 16、如何理解原型链？

> 所谓的原型链就是多个对象通过  `__proto__` 的方式连接了起来形成一条链。



#### 17、说说 js 中的继承？

> ######  ES5 中的继承：

##### 1、经典继承（构造函数）

```javascript
/ 详细解析
//1、当用调用 call 方法时，this 带边 son 。
//2、此时 Father 构造函数中的 this 指向 son。
//3、也就是说 son 有了 colors 的属性。
//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。
function Father(){
	this.colors = ["red","blue","green"];
}

function Son(){
    // this 是通过 new 操作内部的新对象 {} ，
    // 此时 Father 中的 this 就是为 Son 中的新对象{}
    // 新对象就有了新的属性，并返回得到 new 的新对象实例
    // 继承了Father,且向父类型传递参数
	Father.call(this);
}

let s = new Son();
console.log(s.color)
```

① 基本思想：在子类的构造函数的内部调用父类的构造函数。

② 优点：

- 保证了原型链中引用类型的独立，不被所有实例共享。

- 子类创建的时候可以向父类进行传参。

③ 缺点:

- 继承的方法都在构造函数中定义，构造函数不能够复用了（因为构造函数中存在子类的特殊属性，所以构造函数中复用的属性不能复用了）。
- 父类中定义的方法对于子类型而言是不可见的（子类所有的属性都定义在父类的构造函数当中）。



##### 2、组合继承

```javascript
function Father(name){
	this.name = name;
	this.colors = ["red","blue","green"];
}

// 方法定义在原型对象上（共享）
Father.prototype.sayName = function(){
	alert(this.name);
};

function Son(name,age){
    // 子类继承父类的属性  
	Father.call(this,name);     //继承实例属性，第一次调用 Father()
    // 每个实例都有自己的属性
	this.age = age;
}

// 子类和父类共享的方法（实现了父类属性和方法的复用）                              
Son.prototype = new Father();   //继承父类方法,第二次调用 Father()

// 子类实例对象共享的方法
Son.prototype.sayAge = function(){
	alert(this.age);
}

var instance1 = new Son("louis",5);
instance1.colors.push("black");
console.log(instance1.colors);//"red,blue,green,black"
instance1.sayName();//louis
instance1.sayAge();//5

var instance1 = new Son("zhai",10);
console.log(instance1.colors);//"red,blue,green"
instance1.sayName();//zhai
instance1.sayAge();//10
```



① 基本思想：

- 使用**原型链**实现对**「原型对象属性和方法」**的继承。
- 通过借用**构造函数**来实现对**「实例属性」**的继承。

② 优点：

- 在原型对象上定义的方法实现了函数的复用。
- 每个实例都有属于自己的属性。

③ 缺点：

- 组合继承调用了两次父类的构造函数，造成了不必要的消耗。



##### 3、原型继承

```javascript
function object(o){
	function F(){}
	F.prototype = o;
    // 每次返回的 new 是不同的
	return new F();
}

var person = {
	friends : ["Van","Louis","Nick"]
};

// 实例 1
var anotherPerson = object(person);
anotherPerson.friends.push("Rob");

// 实例 2
var yetAnotherPerson = object(person);
yetAnotherPerson.friends.push("Style");

// 都添加至原型对象的属性(所共享)
alert(person.friends); // "Van,Louis,Nick,Rob,Style"
```

**① 基本思想：**创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。

**② 浅拷贝：**

> `object` 所产生的对象是不相同的，但是原型对象都是 `person` 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 `Person` 所拥有，而且被子类生成的实例所共享。

③ **object.create()：**在 ECMAScript5 中,通过新增 **object.create()** 方法规范化了上面的原型式继承.。

- 参数一：新对象的原型的对象。
- 参数二：先对象定义额外的属性（可选）。



##### 4、寄生式继承

```javascript
function createAnother(original){
	var clone = object(original); //通过调用object函数创建一个新对象
	clone.sayHi = function(){ //以某种方式来增强这个对象
		alert("hi");
	};
	return clone; //返回这个对象
}
```

**① 基本思想：**同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。

**② 缺点：**寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。



##### 5、寄生组合式继承

```javascript
// 参数分别为子类和父类的构造函数
function extend(subClass,superClass){
	var prototype = object(superClass.prototype);//创建对象
    // 下面这两部为子类的构造函数指定原型对象
    // 让原型对象的 constructor 指向子类
	prototype.constructor = subClass;
    // 为子类构造函数指定原型对象
	subClass.prototype = prototype;
}
```

① 基本思想：不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。

② 优点：寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。



#### 19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？

> new 操作符的过程其实就是一个创建空对象，为空对象添加属性，为对象链接原型链，返回对象。



###### ▉ new 的原理：

① 新生成一个对象；

② 链接到原型；

③ 绑定 this；

④ 返回新对象。



###### ▉  new 创建对象和字面量创建对象的区别

**共同点：**

- 对于对象，其实都是通过 `new Object()` 产生的。

**不同点：**

> 推荐使用字面量的方式创建对象，简单，方便。

- 通过 `new Object()` 的方式创建对象需要通过作用域链一层层的找到 `Object` 。
- 字面量的方式创建对象就没有以上问题。

```javascript
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
```



###### ▉ Object.create(null) 创建对象

```javascript
Object.create(proto, [propertiesObject]);
```

- proto：新创建对象的原型对象。
- propertiesObject：（可选）可为创建的新对象设置属性和值。



###### ▉  Object.create() 一般用于继承

```javascript
var People = function (name){
  this.name = name;
};

People.prototype.sayName = function (){
  console.log(this.name);
}

function Person(name, age){
  this.age = age;
  People.call(this, name);  // 使用call，实现了People属性的继承
};

// 使用Object.create()方法，实现People原型方法的继承，并且修改了constructor指向
Person.prototype = Object.create(People.prototype, {
  constructor: {
    configurable: true,
    enumerable: true,
    value: Person,
    writable: true
  }
});

Person.prototype.sayAge = function (){
  console.log(this.age);
}

var p1 = new Person('person1', 25);
 
p1.sayName();  //'person1'
p1.sayAge();   //25
```



###### ▉  new/字面量 与 Object.create() 创建对象的区别

- new  和 字面量创建的对象的原型指向 Object.prototype，会继承Object的属性和方法。
- 而通过 Object.create(null) 创建的对象，其原型指向 null，null作为原型链的顶端，没有也不会继承任何属性和方法。



###### ▉  手写实现一个 new 操作符

```javascript
// new 生成对象的过程
// 1、生成新对象
// 2、链接到原型
// 3、绑定 this
// 4、返回新对象
// 参数：
// 1、Con: 接收一个构造函数
// 2、args：传入构造函数的参数
function create(Con, ...args){
    // 创建空对象
    let obj = {};
    // 设置空对象的原型(链接对象的原型)
    obj._proto_ = Con.prototype;
    // 绑定 this 并执行构造函数(为对象设置属性)
    let result = Con.apply(obj,args)
    // 如果 result 没有其他选择的对象，就返回 obj 对象
    return result instanceof Object ?  result : obj;
}
// 构造函数
function Test(name, age) {
    this.name = name
    this.age = age
}
Test.prototype.sayName = function () {
    console.log(this.name)
}

// 实现一个 new 操作符
const a = create(Test,'小鹿','23')
console.log(a.age)
```



#### 20、instanceof 的原理是什么？

> `instanceof` 可以正确的判断**对象的类型**，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。



###### ▉ 手写实现一个 instanceof

```javascript
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
```

 

#### 21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？

###### ▉ 原因

① 因为 JS 采用的是 IEEE 754 双精度版本（64）位，采用该版本的语言都存在问题。

② 计算机是通过二进制来存储东西的，那么 0.1 会在二进制内表示的是无限循环的一些数，不只是 0.1 。还有很多的十进制小数用二进制表示的是无限循环的。

③ 但是 js 采用的是浮点数标准却会裁减掉循环的数据而失去精度。也就造成了 `0.1` 不再是 `0.1` 了。而是变成了 `0.100000000000000002`。

④ 那么同样的，`0.2` 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`。

⑤ 所以这两者相加不等于 `0.3` 而是 `0.300000000000000004`。

⑥ 既然 `0.1` 不是 `0.1`，那为什么 `console.log(0.1)` 却是正确的呢？在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值。

```
// (0011) 表示循环
0.1 = 2^-4 * 1.10011(0011)
```

```javascript
0.100000000000000002 === 0.1 // true
```



###### ▉ 解决问题

```javascript
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```



## ES6 知识点总结

#### 1、什么是提升？什么是暂时性死区？var、let 及 const 区别？

**※ 答✔：什么是提升？**

1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。

2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。

3）`var` 的变量会被提升到作用域的顶部。



**※ 答✔：什么是暂时性死区？**

1）如果使用 `let`、`const` 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 `var` 是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。



**※ 答✔：var、let 及 const 区别？**

1）`var` 在全局作用域下声明变量会导致变量挂载在 `window` 上，其他两者不会

2）`let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值。



**※ 扩展✔：为什么或存在提升？**

1）根本原因就是为了解决函数间互相调用的情况。



#### 2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？ 

**※ 答✔：原型如何实现继承？**

1）组合继承、寄生组合继承、Class 继承  原文链接：[JavaScript 中的原型链和继承](http://luxiangqiang.xn--6qq986b3xl/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/)



**※ 答✔：Class 如何实现继承？**

1）`Class` 实现继承主要使用 `extends` 来明确继承自哪个父类，并且再子类中调用 `super`，可以将这段代码看做 `Parent.call(this,value)`。

```javascript
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```



**※ 答✔：Class 本质是什么？**

1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。



#### 3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

**※ 答✔：为什么使用模块化？**

> 通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 

- 解决命名冲突
- 提供复用性
- 提高代码可维护性



**※ 答✔：都有哪几种方式可以实现模块化？**

**① 立即执行函数（IIFE）**

> 立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。**通过函数作用域解决了命名冲突、污染全局作用域的问题** 。



**② AMD 和 CMD**

- **AMD** 

  > AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， `require.config()` 指定引用路径等，用 `define()` 定义模块，用 `require()` 加载模块。

- **CMD **

  > CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。



**③ CommonJS**

-  `CommonJS` 的规范主要用在 `Node.js` 中，为模块提供了四个接口：`module、exports、require、global`。

- `CommonJS` 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。

```javascript
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
// 对外暴露接口
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
```

```javascript
// 加载外部模块
var mod = require('./lib');

console.log(mod.counter);  // 3
mod.incCounter();
// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）
console.log(mod.counter); // 3
```



**④ ES6 模块**

> ES6 实现的模块非常简单，用于浏览器和服务器端。`mport`命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：`export`和`import`:

- `export`命令用于规定模块的**对外接口**。
- `import`命令引入其他模块的功能。 

```javascript
// 指定指定的值暴露对外的接口
export let counter = 3;
export function incCounter() {
  counter++;
}

// 加载模块中的某个值
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。
console.log(counter); // 4
```



**⑤ ES6 模块与 CommonJS 模块的区别**

**1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。**

- 所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。
- ES6 模块是**动态引用**，**不缓存值**，模块内外是**绑定**的，而且是**只读引用**，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 `import` ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。

**2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。**

- **运行时加载**：`CommonJS` 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 
- **编译时加载：**ES6 模块不是对象，而是通过 `export` 命令「显式指定输出的代码」。`import` 时采用静态命令的形式，即在`import `指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 

**⑥ 总结**

- CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
- AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
- CMD 规范与 AMD  规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。
- **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。



#### 4、map、filter、reduce 各自有什么作用？

**※ map 有什么作用？** 

> map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。

###### 1）该函数存在三个参数：

- element :  对应数组的每个元素。
- index : 数组元素的下标。
- arr : 原数组。

###### 2）代码实现

```javascript
let arr = [2,3,4]
arr = arr.map(function(element,index,arr){
    return arr[index]+1;
}) // [3,4,5]
```



**※ filter 有什么作用？** 

> `filter` 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。

###### 1）该函数存在三个参数：

- element :  对应数组的每个元素。
- index : 数组元素的下标。
- arr : 原数组。

###### 2）代码实现

```javascript
let array = [1, 2, 4, 6]
let arr = array.filter(function(element){
	return element != 6;
})// [1,2,4]
```



**※ reduce 有什么作用？** 

> reduce 可以将数组中的元素通过回调函数最终转换为一个值。

###### 1）传入 reduce 两个参数：

- 回调函数
  - accum：累计值(第一次的值代表初始化的值)。
  - element：当前元素。
  - index：当前索引。
  - arr：原数组。
- 初始值



###### 2）代码实现

```javascript
let arr = [1,2,3]
let sum = arr.reduce(function(acc,element){
    return acc + element;
},0) // 6
```



###### 3）reduce 的执行过程

- 初始值为 0 ，该值会传入第一次回调函数。
- 回到函数接收四个值，第一个值是累计值。
- 第一次执行回调函数将「初始值」和「当前值」做运算。
- 然后将结果值传入第二次执行的回调函数。
- 第二次回调函数会和当前值再做运算。



#### 5、Proxy 可以实现什么功能？

> Proxy 中文意思代理，可以用来自定义对象中的操作。
>
> ① 如果设置了拦截操作，那么访问目标对象时被拦截。
>
> ② 如果没有设置拦截操作，但是生成了 Proxy 的实例，那么可以正常访问到原始值。



###### ▉ 格式

```javascript
var proxy = new Proxy(target, handler);
```

- target：所要拦截的目标对象。
- handle：设置拦截的行为。





















































