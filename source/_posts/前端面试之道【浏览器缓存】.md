---
title: 前端面试之道【浏览器缓存机制】
categories: 
- 前端
- 面试
tags: 
- 前端
- 面试
---

浏览器的缓存机制涉及到性能优化领域！

<!--more-->



## 浏览器缓存机制

> **缓存是性能优化中最高效的一种方式，可以较少网络传输所带来的损耗**。



一个数据请求分为三个阶段，发起网络请求、后台处理、浏览器响应。浏览器的缓存优化主要是在网络请求和浏览器响应这两个步骤中优化性能。第一种情况，直接使用缓存，不发起请求；第二种情况，发起请求，发现后端存储的数据和前端一致，就没必要传回来了。



### 一、缓存位置

> 缓存位置分为大体分为四种，会依次查看当前数据是否在缓存中，如果没有则会请求网络。

- **Service Worker**
- **Memory Cache**
- **Disk Cache**
- **Push Cache**
- **网络请求**



#### 1、Service Worker

> Service 是运行在浏览器背后**独立的线程**，一般可用来实现缓存功能。因为 Service Worker 中涉及到请求拦截，所以必须使用 **HTTPS** 协议来保证安全。



###### ▉ 如何使用？

> 注册 `Service Worker`，然后监听到 `install` 事件之后就可以缓存需要的文件，用户在下次访问的时候就会拦截请求，然后查询是否已缓存，缓存的话就直接读取缓存文件，否则就去请求数据。

```javascript
// index.js
// 注册 Service Worker
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register('sw.js')
    .then(function(registration) {
      console.log('service worker 注册成功')
    })
    .catch(function(err) {
      console.log('servcie worker 注册失败')
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll(['./index.html', './index.js'])
    })
  )
})

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response
      }
      console.log('fetch source')
    })
  )
})
```

































