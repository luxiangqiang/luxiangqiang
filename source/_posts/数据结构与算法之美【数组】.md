---
title: 数据结构与算法之美【数组】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
---

 小鹿带你走进数据结构与算法之美的数组。

<!--more-->

## 目录

[TOC]

### 一、数组的基本知识

#### 1、什么是数组？

> 数组（Array）是一种**线性表数据结构**。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。



#### 2、数组有什么特点？

###### ▉ 优点

> 1）快速实现「**随机访问**」



**◆ 问题一：**数组如何实现下标随机访问的 ？

> 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当我们进行下标随机访问某个元素的时候，通过寻址公式来计算该元素的位置。

```
// base_address 首地址，data_type_size 每个元素的大小，int 类型为 4 个字节。
a[i]_address = base_address + i * data_type_size
```



###### ▉ 缺点

> **1）低效的插入和删除操作。**
>
> **2）不支持动态扩容**。
>
> (数组的缺点是大小固定，如果数组的声明过大，内存没有连续的内存空间；如果数组声明过小，内存空间不够用，必须进行数据搬移，耗费时间)



**◆ 问题一：**数组插入、删除数据为什么会低效 ？

> 数组为了「**保持内存空间的连续性**」，会导致插入、删除这两个操作比较低效。



**◆ 问题二：**数组插入数据低效的具体原因？

> 1）如果在数组的末尾插入元素，那就不需要移动数据了，**最好时间复杂度为 O(1)**。
>
> 2）如果在数组开头插入元素，那就将所有的数据往后移动一个，**最坏时间复杂度为 O(n)**。
>
> 3）因为在每个地方插入数据的概率是相同的，所以**平均时间复杂度为 O(n)**。
>
> **改进**：数组插入新数据，**直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。**





**◆ 问题三：**数组删除数据低效的具体原因？

> 1）如果删除末尾的数据，最好时间复杂度为 O(1)；
>
> 2）如果删除的头部的数据，最坏时间复杂度为 O(n)；
>
> 3）平均时间复杂度为 O(n)；
>
> **改进：**为了避免数据的移动，我们可以先标记要删除的数据，而不是真正的删除。等内存空间不足的时候，我们一次性删除数据，大大较少了数据的搬移（**JVM 标记清除垃圾回收机制算法的核心**）。



### 二、数组使用的注意事项

#### 1、警惕数组的访问越界

> 1）在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。
>
> 2）根据数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。
>
> 3）其他高级语言 ` java` 越界会抛出异常，而 `javascript` 会返回 `undefined` ，js 的数组长度是动态的。

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n"); // 无限循环打印 Hello Word
    }
    return 0;
}
```



### 三、ArrayList 与 数组

#### 1、ArrayList 的特点

> 1）ArrayList 最大的优势就是可以将很多数组操作的**细节封装**起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。
>
> 2）支持动态扩容。每次存储空间不够的时候，它都会将空间**自动扩容为 1.5 倍大小**。
>



#### 2、数组适用条件

> 1）`Java ArrayList` 无法存储基本类型，比如 `int`、`long`，需要封装为 `Integer`、`Long` 类，而 `Autoboxing`、`Unboxing` 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
>
> 2）如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
>
> 3）当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList array。
>



#### 3、数组使用总结

> **1）**一般的业务开发用 `ArrayList`  就足够了，性能的丢失的一小部分，几乎可以忽略。
>
> **2）**做一些非常底层的开发，比如开发网络框架，**性能的优化需要做到极致，这个时候数组就会优于容器，成为首选**。



### 四、代码实现

```java
/**
 * 1) 数组的插入、删除、按照下标随机访问操作；
 * 2）数组中的数据是int类型的；
 *
 * Author:zheng
 * 注释人：小鹿
 */

public class Array05 {
	
	//声明变量
	  private int data[];
	  private int n;
	  private int count;

	 /**
	  * @param capacity:用户传参，数组的大小
	  * 功能：构造函数（初始化数据）
	  */
	  public Array05(int capacity) {
		//定义一个大小为 capacity 的数组
	    data = new int[capacity];
	    n = capacity;
	    count = 0;
	  }
	
	  /**
	   * 功能：下标随机访问
	   * @param index:用户传参下标
	   * @return
	   */
	  public int find(int index) {
		//索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1）
	    if (index < 0 || index >= count ) return -1;
	    //否则返回该索引对应的数据
	    return data[index];
	  }
	  
	  /**
	   * 功能:小鹿改进数组下标随机访问
	   * 改进内容:index 与上述函数不同，该  index 一般表示用户访问的位于数组的第几个元素
	   * 		对应的索引数据下标应该 -1 ，比如，访问第1个元素，在数组中对应的数据下标就是
	   * 		data[0],1 就是相当于用户输入的index。上述用户输入访问第一个元素直接输入0，
	   * 		index就是0，个人认为改进的更为符合实际操作罢了，原理还是一样的，改进如下代码。
	   * @param index
	   * @return
	   */
	  public int improvmentFind(int index) {
		   //索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1）
	       if (index-1 < 0 || index-1 >= count ) return -1;
	       //否则返回该索引对应的数据
	       return data[index-1];
	  }
	  
	  /**
	   * 功能：根据用户输入索引删除数组中数据。
	   * 补充：这个索引也是可以改进的，自己可以仿照上边改进一下
	   * @param index
	   * @return
	   */
	  public boolean delete(int index) {
		//首先判断删除的索引值是否在数组索引范围内（边界问题）
	    if (index < 0  || index >= count) return false;
	    //将删除元素的后边元素都向前依次移动
	    for(int i = index + 1; i < count; ++i) {
	      data[i-1] = data[i];
	    }
	    //删除一个元素后，数组长度 -1
	    --count;
	    return true;
	  }
	
	  /**
	   * 功能：数组插入元素
	   * @param index:数组下标索引
	   * @param value:要插入的元素值
	   * @return
	   */
	  public boolean insert(int index, int value) {
		//首先判断删除的索引值是否在数组索引范围内（边界问题）
	    if (index < 0 || index >= count) return false;
	    //还要考虑到一种情况就是，如果你一直删除元素知道把元素全部删除完，数组长度为0，无法进行插入元素，对于这种情况就需要进行判断
	    if (count == n) return false;
	    //数组中数据从最后一依次向后移动，直到将用户指定索引元素空出空间
	    for (int i = count - 1; i >= index; --i) {
	      data[i+1] = data[i];
	    }
	    //将元素插入到数组中
	    data[index] = value;
	    //数组长度+1
	    ++count;
	    return true;
	  }
	
	  /**
	   * 功能：插入的另一种情况，当我们向一个数组的尾部插入元素时，上述的插入方法就不适合了，所以我们单独写一个将元素插入到数组尾部的方法。
	   * @param value:要插入的元素值
	   * @return
	   */
	  public boolean insertToTail(int value) {
	    if (count == n) return false;
	    //在数组尾部追加空间，将新元素插入到数组尾部
	    data[count++] = value;
	    return true;
	  }
	
	  /**
	   * 通过for循环输出数组所有元素
	   */
	  public void printAll() {
	    for (int i = 0; i < count; ++i) {
	      System.out.print(data[i] + " ");
	    }
	    System.out.println();
	  }
}
```



### 五、思考题

#### 1、为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1开始？

###### ▉ 从 0 开始编号

> 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

```
a[k]_address = base_address + k * type_size
```



###### ▉ 从 1 开始编号

> 如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

```
a[k]_address = base_address + (k-1)*type_size
```



###### ▉ 具体原因

> 1）对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。
>
> 2）数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。**所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。**
>

> **补充：**以上证明并不是压倒性证明，更有可能是历史原因，其他语言都效仿 C 语言，编号从 0 开始。



#### 2、 JVM 的标记清除垃圾回收算法的核心理念，说一说 JAVA 的标记清除垃圾回收算法？

> 目前最基本的垃圾收集算法有四种。
>
> - **标记-清除算法(mark-sweep)**
> - 标记-压缩算法(mark-compact)
> - 复制算法(copying)
> - 引用计数算法(reference counting)
>

> **标记-清除算法(mark-sweep)：**先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。



#### 3、二维数组的内存寻址公式是怎样的呢？

> 1） C语言中，对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址如下。
>
> 2） java 二维数组是**分块连续的** 。

```
address = base_address + ( i * n + j) * type_size
```



### 六、面试问题

#### 1、数组和链表的区别

> **1、错误表述：**“ 链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1) ”。实际上，数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。
>
> **2、正确表述：**数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。



### 七、练习题

#### 1、实现一个动态扩容的数组

```java
import javax.xml.crypto.Data;

/**
 * 功能：实现一个支持动态扩容的数组
 * 方法一:System.arraycopy()
 * 最好时间复杂度为O(1),最坏时间复杂度为 O(n),平均时间复杂度为 O(1).
 * 
 * 方法二:ArrayList 实现自动扩容
 * @author 小鹿
 *
 */


public class Array01 {
	private int count;
	private int[] array;
	private int num;
	private int n;
	
	//初始化
	public Array01(int number) {
		count = 0;
		array = new int[number];
		num = number;
		n = 1;
	}
	
	
	public static void main(String[] args) {
		Array01 data = new Array01(5);
		data.insert(1);
		data.insert(2);
		data.insert(3);
		data.insert(4);
		data.insert(5);
		data.insert(6);
		data.insert(7);
		data.insert(8);
		data.insert(9);
		data.insert(10);
		data.insert(11);
		data.insert(12);
		data.print();	
	}
	
	//插入数据
	public void insert(int value) {
		if(count>=num*n) {
			//动态扩容
			int[] newArray = new int[array.length*2];
			//数组数据搬移
			for(int j =0;j<array.length;j++) {
				newArray[j] = array[j];
			}
//			System.arraycopy(array, 0, newArray, 0, array.length);
			
			array = newArray;
			//然后再插入数组
			array[count] = value;
			//下标移动
			count++;
			//扩容计数
			n++;
		}else {
			//插入数据
			array[count] = value;
			//下标移动
			count++;
		}
	}
	
	//打印数组内容
	public void print() {
		for(int i=0;i<array.length;i++) {
			System.out.print(array[i]+" ");
		}
	}
}
```



### 八、数组掌握程度

> 一定要自己动手练习哦！



#### 一、入门基础

- 实现一个支持动态扩容数组
- 实现一个大小固定的有序数组，支持动态增删改查操作
- 实现两个有序数组合并为一个有序数组