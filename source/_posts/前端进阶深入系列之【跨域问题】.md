---
title: 前端进阶深入系列之【跨域问题】
categories: 
- 前端
- javascript
- 前端深入系列
tags: 
- 前端
- javascript
- 前端深入系列
---

AJAX 以及跨域问题完整详细解析，面试、日常项目常用点。

<!--more-->

[TOC]



# 跨域问题

## 一、同源策略                           

#### 1.1 同源策略的由来

> 为了防止网站遭到恶意攻击，这里所谓恶意攻击就是从自己服务器的页面代码 js 中通过别人的 URL 去请求别人的服务器资源，这样通俗一点。这会导致信息被窃取，所以浏览器设计了同源策略。

例如：A 网站的服务器存有 A 网站用户的登录、账户等信息，该信息通常是由 A 网站的用户可获取的，但是如果没有同源策略，那么 B 网站的用户可以通过 AJAX 请求 A 网站服务器的资源，从而获取到用户的信息，导致用户信息被窃取。



#### 2.2 什么是同源策略

> 1995年，同源政策由 Netscape 公司引入浏览器。 所谓的「同源」，浏览器规定 AJAX 做请求时，请求的服务器的 URL 的域名必须和当前页面的 URL 「域名相同」浏览器才会让你做请求（同源才会进行通信）。相同包括三个部分：

- 域名相同
- 协议相同
- 端口号相同

举例：假设网址为 http://www.xiaolu.com/example/index.html ，请求的服务器 URL 必须在一下三个方面做到相同才可以请求：

```javascript
//协议
如果服务器使用 https 的协议： https://www.xiaolu.com/example/index.html （不同源，不能请求）

//端口号
如果服务器使用 8016 端口号：http://www.xiaolu.com：8016/example/index.html （不同源，不能请求）

//域名
如果服务器使用其他域名：http://www.lu.xiaolu.com：8016/example/index.html （不同源，不能请求）

//三者必须都相同
http://www.xiaolu.com/example/index.html （同源，可以请求）
```



#### 2.3 同源策略的问题

> 虽然浏览器引入了同源策略，防止了恶意网站获取资源导致信息泄露。但是，会导致一下几个问题。

- Cookie、LocalStorage 和 IndexDB 无法读取。 
- DOM 无法获得。 
- AJAX 请求不能发送。 



##### 1、不同源获取 Cookie

> 同源策略导致不同源的页面是不可以获取 Cookie 值的，如果有存在不同源的两个页面（一级域名相同，二级域名不同），想要共享 Cookie ，怎么做呢？

```javascript
//假设两个共享 Cookie 的网址
A 网址：http://v1.xiaolu.com/index.html
B 网址：http://v2.xiaolu.com/index.html

// 同源策略导致不同源的页面是不可以获取 Cookie 值的
// 注意：只是适用于二级域名不同 Cookie 和 iframe,对于 LocalStorage 和 IndexDB 不适用。 
document.domain = '.xiaolu.com'

//方法二：服务器设置 Cookie 的时候，指定 Cookie 所属一级域名，上述如果一级域名不同也不会存在限制
Set-Cookie: key=value; domain=.xiaolu.com; path=/
```



## 二、AJAX 跨域共享

### 2.1 架设代理服务器

> 同源域名下架设代理服务器，JavaScript负责把请求发送到代理服务器，代理服务器将结果返回，准守了浏览器的同源策略。
>
> **缺点：需要额外的服务器做开发**

```
'/proxy?url=http://www.baidu.com.cn'
```



### 2.2 domain

> 同一主域的不同子域可以设置 document.domain 为主域来让他们同域,并且子域的协议和端口都要一致。
>
> document.domain 只能设置往上设置域名,需要载入 iframe 来相互操作。



### 2.3 JSONP

> 一些带 src 的 html 标签都可以实现跨域，link、font-face、img、video、audio、script等。 



#### 1、本质

> 利用浏览器允许跨域引用  JavaScript 资源的功能。



#### 2、缺点

> 只能用 Get 请求，并且返回 javascript。



#### 3、优点

> 简单适用，老式浏览器全部支持，服务器改造非常小 



#### 4、基本流程

> JSONP 通常以函数的形式返回，需要在页面写好返回的函数，页面动态的添加一个`<script>`节点，动态读取外域的 javascript 资源，然接受回调。（在外域的 javascript 文件中返回一个函数，函数中有我们需要的数据，我们在本地触发该函数就可以完成跨域）。

```javascript
<script>
    function addScriptTag(src) {
      var script = document.createElement('script');
      script.setAttribute("type","text/javascript");
      script.src = src;
      document.body.appendChild(script);
    }

    window.onload = function () {
      addScriptTag('http://ip.jsontest.com/?callback=ip');
    }
	
	// 触发外域函数
    ip();
</script>
```



#### 5、安全性

> 当这个接口没有验证Referer头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。
>
> 当接口返回的是一些敏感数据时(如 CSRF TOKEN,用户个人信息等),危害是很大的。



### 2.4 WebSocket

#### 1、概念

> WebSocket是一种通信协议，使用`ws://`（非加密）和`wss://`（加密）作为协议前缀。该协议不实行同源政策，**只要服务器支持**，就可以通过它进行跨源通信。 



#### 2、基本流程

> 浏览器发出的WebSocket请求的头信息。

```javascript
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

> 因为请求头部信息中的 origin 字段，所以 websocket 没有同源策略。服务器根据这个字段进行相应。

```javascript
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```



### 2.5 CORS 

> CORS 是 “跨域资源共享” （Cross-origin resource sharing ）的缩写，解决 AJAX 只能同源通信的限制问题。



#### 1、简介

> **1）基本流程 ：**整个 CORS 是浏览器自动完成的，浏览器一旦发现 AJAX 是跨域请求，自动添加一些信息在头部，只要服务器端能够识别在头部的信息，就可以完成跨域通信。
>
> **2）设计思想：**CORS 的设计思想就是使用自定义 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还应该是失败。



#### 2、兼容性

> CORS 需要浏览器和服务器同时支持，IE 不能低于 IE10。



#### 3、CORS 两种请求方式

> CORS 分为两种请求方式：

- **普通请求:** 简单的进行 AJAX 跨域请求，不需要服务器设置对请求的一些限制条件。
- **高级请求 :** 服务器对 AJAX 跨域请求设置限制条件，如：请求方法必须使用 Get 或者 Post、SSL 认证等。



#### 4、请求流程

> 当浏览器发现是 AJAX 跨域请求时，就会识别此次跨域请求是普通请求还是高级请求，怎么识别普通请求和高级请求呢？根据浏览器发现 ajax 进行跨域请求时自动添加上的头部信息进行识别，如果头部信息符合一下两个条件就为「普通请求」，如果不符合一下两个条件，就判断为「高级请求」。

```javascript
// 1）普通请求使用一下请求方法之一
● HEAD 
● GET
● POST

// 2）自动添加的头部信息小于等于一下几个字段
● Accept
● Accept-Language
● Content-Language
● Last-Event-ID
● Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain 三个类型之一
```



##### 4.1 普通请求

###### ▉ 判断请求方式

> AJAX 发送跨域请求，通过以上几个条件判断该请求是否为普通请求，如果满足条件，此次跨域请求为普通求请求。



###### ▉ 普通请求的基本流程

> 浏览器发现 AJAX 是跨域请求，然后再请求的头部添加一个 `Origin` 字段信息（发出请求的源地址）。然后浏览器检查请求信息确定此次的跨域的请求方式，如果为普通请求，请求信息相关字段如下：

```javascript
GET /cors HTTP/1.1         //请求方法
Origin: http://xiaolu.com  //跨域字段（该字段的值为请求的源地址信息，包括域名、端口号、协议）
Host: api.alice.com        //主机地址
Accept-Language: en-US     //语言类型
Connection: keep-alive     //连接方式
User-Agent: Mozilla/5.0... //浏览器版本
```



###### ▉ 服务器端

> 请求到达服务器，服务器提取 `Origin `信息，看是谁给我发来的请求信息，判断 `Origin ` 是否为之前在服务器设置好的 `Origin ` 字段信息，如果没有此信息，就返回一个正常的 HTTP 响应。如果有此信息，就在 HTTP 回应的头部添加几个字段，让浏览器根据服务器添加的几个字段再判断此次跨域请求是否同意了。

如果此次请求被允许，HTTP 响应的头部添加一下几个字段：

```javascript
// 1) 用来让浏览器判断该信息服务器是否允许了此次请求。
// 2) 如果值为 * ，表示服务器可以接收任意域名的请求。
// 3）否则，代表服务器之允许设置好的域名进行跨域请求。
Access-Control-Allow-Origin:  http://xiaolu.com 

// 1）该字段表示浏览器是否可以向服务器发送 Cookie，默认情况 Cookie 不存在 CORS 请求中的。
// 2) 设置为 true，允许 Cookie 信息包含在请求中的。
// 3) 如果服务器不要浏览器发送Cookie，删除该字段即可
Access-Control-Allow-Credentials: true

// 1）如果不设置此字段，浏览器接受到请求之后，只能通过 XMLHttpRequest 对象的 getResponseHeader()拿到最基本的 6 个字段。
// 2）如果想要拿到其他字段，需要在下面字段中指定。(下面设置了允许获取取 name 字段信息,通过 getResponseHeader('FooBar') 获取字段的值)
Access-Control-Expose-Headers: name

//1）响应类型和字符编码
Content-Type: text/html; charset=utf-8
```



###### ▉ 客户端（AJAX 请求端）

> 当浏览器接收到服务器的响应信息后，判断响应头中是否包含 `Access-Control-Allow-Origin ` 字段，如果没有包含，浏览器就不会将响应信息让开发人员做处理，直接抛出一个错误，回调 `XMLHttpRequest`的`onerror` 方法（虽然服务器返回的状态码可能是 200，但是被浏览器拦截了，就会被 onerror 所捕获）。



###### ▉ withCredentials 属性

> CORS 请求默认不发送 Cookie 等认证信息。如果要发送 Cookie 信息，需要分别在服务器和 AJAX 请求中设置。

```javascript
//服务器端响应头部添加一下字段
//注意：发送 Cookie ,服务器的 Access-Control-Allow-Origin 的字段不能设置为 * 。必须指定明确的、与请求网页一致的域名。只有这样，服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传。
Access-Control-Allow-Credentials: true

//客户端在 AJAX 请求中设置（即使服务器统一发送 Cookie ，但是浏览器不统一发送 Cookie 必须设置下字段）
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```



##### 4.2 高级请求

###### ▉ 判断请求方式

> 发送 AJAX 跨域请求，浏览器检测请求信息中存在 PUT 或 DELETE 方法，或者 `Content-Type`字段的类型是`application/json`  ，就将此次跨域请求定义为「高级请求」。



###### ▉ 高级请求的基本流程

> 高级请求会在真正的请求之前，先和服务器“打电话”，问一下服务器当前网页的域名，以及请求方法能够进行此次通信。服务器说，这次通信可以使用 PUT 或 DELETE 方法，那么浏览器才会发出 AJAX 的正式请求，否则就会报错。

```javascript
//Ajax 跨域请求的正式内容：
var url = 'http://xiaolu.com ';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```



###### ▉ preflight 预请求

> 上述中，在真正的请求之前，「浏览器」先和服务器“打电话”，打电话的过程称为 “preflight 请求“。preflight 预请求的内容如下：

```javascript
OPTIONS /cors HTTP/1.1
Origin: 'http://xiaolu.com '    // 源地址 
Access-Control-Request-Method: PUT  //请求方法
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```



**步骤一：浏览器发出请求**

> 该预请求信息通过浏览器的 OPTIONS 方法来询问服务器，发送该预请求的内容，就是用来让服务器接受判断这些信息是否符合服务器端的要求。



**步骤二：服务器响应请求**

> 服务器接受到信息之后，取出字段进行以预先设置好的字段值进行判断，然后做出回应。如果与服务器设置的不符合条件，此次拒绝了 preflight 预先请求，就会返回一个正常的 HTTP 响应给浏览器。否则响应以下信息给浏览器。

```javascript
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin:  'http://xiaolu.com '
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Max-Age: 1728000 //服务器运行此源地址请求的时间，一旦超过这个时间，就重新进行预请求
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```



**步骤三：浏览器接收请求 **

> 1）浏览器接收到服务器的响应之后，发现只有简单的 HTPP 响应头部，没有任何的 CORS 请求信息，浏览器就知道了服务器拒绝这次 preflight 预请求，然后返回给开发人员一个错误信息，被 `XMLHttpRequest`对象的`onerror ` 回调函数捕获 。
>
> 2）如果浏览器发现服务器返回的请求带有 CORS 请求头部，就获取字段判断，此次服务器允许了此次请求。



**步骤四：AJAX 正常请求和回应**

> preflight 预请求一旦通过，浏览器就会向服务器发送正式的 AJAX 请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样。



#### 5、安全性

> **安全漏洞：**因为 `Access-Control-Allow-Origin`  设置成通配符”*”时,表示允许任何域名跨源，如果再把 `Access-Control-Allow-Credentials` 设置为 true,允许客户端带上 cookie 的话,无疑此时是非常危险的.因为攻击者很容易就能窃取到用户个人的数据。 
>
> **保护机制：**客户端不带 cookie 请求的话还是会正常呈现的,因为 cookie 是一种身份标识,一旦浏览器标识了用户身份,那么返回的数据必然属于用户个人,所以浏览器设计了这种措施来保护用户数据不被泄露。 



###### ▉ 配置错误

> 尽管 CORS 在设计上考虑到安全问题，但是在用户配置时经常出现很多错误，如设置 ”Access-Control-Allow-Origin”的白名单时,正则写的不正确,导致预期外的域名可以跨域。 



### 2.5 CORS 与 JSONP 比较

> 1、JSONP 只支持 GET 请求。CORS 支持所有的 HTTP 请求。
>
> 2、JSONP 支持老式浏览器以及向不支持 CORS 的服务器请求数据。CORS 只支持 IE10 版本以上浏览器。



### 2.6 IE 对 CORS 的实现

> 通过 XHR 实现 AJAX 通信是一个主要限制，默认情况下，XHR 对象只能访问与包含它页面在同一域下的资源



#### 1、简介

> 微软在 IE8 中引入了 XDR 类型，部分实现了 CORS 的规范，使得 IE 可以完成跨域处理。             



#### 2、XDR 与 XHR 的不同

- Cookie 不能随请求发送，也不会随响应返回。
- 只能设置请求头部的 Content-Type 字段。
- 不能访问响应头部的信息。
- 只支持 GET 和 POST 请求。



#### 3、XDR 的使用

> 1、XDR 与 XHR 的 open 方法稍有不同，XDR 的 open 函数只有两个参数（只有异步操作），请求返回后，会触发 onload 事件，可以获取到返回的文本内容。
>
> 2、响应只能访问文本文件，没有状态码可用，如果缺少 Access-Control-Allow-Origin 头部就会触发 onerror 事件。（所有的请求错误只能用 onerror 来捕获） 

```javascript
var xdr = new XDomainRequest();
xdr.onload = function(){
    alert(xdr.responseText);
};
xdr.onerror = function(){
    alert('响应错误');
}
xdr.open('get','http://xiaolu.com/index.html');
xdr.send(null);
```



#### 4、POST 请求

> XDR 为了支持 post 请求，XDR 提供了 contentType 属性，用来表示发送数据的格式，

```javascript
xdr.Content-Type = "application/x-www-form-urlencoded"
xdr.send("name1=value1&name2=value2")
```



### 2.7 其他浏览器对 CORS 的实现

> Firefox 3.5+、Safari 4+、Chrome、iso 和 Android 平台中的 webKit 都通过了 XMLHttpRequest 对象实现了对 CORS 的原生支持。



#### 1、XHR 

> 在尝试打开不同来源的资源时，无序额外的编码触发这个行为，只需在 open 中传入绝对的 URL 就可以触发浏览器的跨域。

```javascript
// 跨域的绝对 URL 路径
xhr.open("get","http://www.xiaolu2.com/page/index.html")
```



#### 2、XHR 的限制

- 不能使用 setRequestHeader() 设置自定义的头部。
- 不能发送和接受 Cookie。
- 调用 getAllResponseHeaders() 方法总返回空字符串。



### 2.7 跨浏览器的 CORS

> 浏览器对 CORS 的支持程度不一样，但是都能实现简单（不带 preflight）的请求，所以要实现一个跨浏览器的方案。
>
> 1、检测 XHR 是否支持 CORS ：检测是否存在 `withCredentials` 属性(该属性只存在 IE 10 以上版本)。
>
> 2、检测 XDomain 对象是否存在：该属性只存在 IE 8 以上浏览器中。

```javascript
function createCORSRequest(method,url){
    var xhr = new XMLHttpRequest();
    if("withCredentials" in xhr){ // IE 10+
       xhr.open(method,url,true)
    }else if(typeof XDomainRequest != "undefined"){ // IE 8+
        var xhr = new XDomainRequest();
        xhr.open('get','http://xiaolu.com/index.html');
    }else{
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest("get","http://www.xiaolu.com");
if(request){
    request.onload = function(){
        // 对 request.responseText 进行处理
    }
     request.send
}
```

> 无论是 Firefox 3.5+、Safari 4+、Chrome 中的 XMLHttpRequest 对象还是 IE 中的XDomainRequest 对象，都可以使用以上的方法。

- onerror：用于替代 `onreadystatechange` 检测错误。
- onload：用于替代 `onreadystatechange` 检测成功。



## 三、跨域存在的两种攻击（XSS/CSRF）

### 3.1 跨站请求伪造（CSRF）

> 跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。CSRF 利用的是网站对用户网页浏览器的信任来进行恶意攻击的。



#### 1、攻击原理

> 攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：**简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。**攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。



#### 2、防御措施

###### ▉ 检查 Referer 字段

> HTTP 头有一个 Referer 字段，用来标记请求来源于哪个地址。Referer字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。
>
> **局限性：**设置 Referer 有本身的局限性，攻击者可以篡改 Referer 字段来达到攻击的目的。



###### ▉ 添加校验 token

> **本质：**CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 Cookie 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。
>
> **随机校验：**服务器为客户端的窗体设置一个伪随机数，客户端在提交请求的时候，将随机数与请求内容一并提交服务器，正常访问时，客户端将会收到正确得到并传回这个伪随机数。CSRF 攻击无从事先知道这个伪随机数，所以导致 token 值为空，拒绝请求。



###### ▉ JSONP 劫持漏洞

> 如果 JSONP 没有验证 Referer 头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 



#### 参考资料：

- Javascript 高级程序设计
- https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000
- http://www.ruanyifeng.com/blog/2016/04/cors.html







































