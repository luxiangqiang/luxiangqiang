---
title: 前端进阶深入系列之【事件循环】
categories: 
- 前端
- javascript
- 前端深入系列
tags: 
- 前端
- javascript
- 前端深入系列
---

深入 JS 内部的事件循环机制！

<!--more-->



## 什么是进程和线程？

**※ 答✔：进程和线程的区别是什么？**

> **1）进程：**进程是 CPU **资源分配**的最小单位，系统会为每个进程进行分配内存空间。比如一个 Tab 页面就是一个进程。
>
> **2）线程：**线程是 CPU **调度**的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成，比如：渲染线程、Js 引擎线程、HTTP 请求线程等）。



## 为什么 JS 会选择单线程？

**※ 答✔：js为什么会用单线程？**

> 1）js 单线程的特点就是同一时刻只能执行一个任务，js 的任务基本都是与用户互动，以及操作 DOM，所以使用单线程，否则会带来复杂的同步问题。
>
> 2）如果为多线程，多个线程同时操作 DOM 就会造成浏览器不知道以哪个为标准的问题。
>
> 3）如果执行同步问题的话，多线程需要加锁，执行任务造成非常的繁琐。
>
> 4）H5 新的规定。允许 JavaScript 脚本创建多个线程，但是子线程完全**受主线程控制**，且**不得操作DOM**。



## 为什么会有事件循环?

**※ 答✔：为什么会有事件循环？**

> 由于 JS 的代码是单线程执行的，所以为了保证 **js 同步代码**的执行顺序以及**异步代码的执行顺序**，内部引入了事件循环机制。



## 什么是微观任务和宏观任务？

> **宏观任务：**从浏览器的角度看，宏观任务就是代表一个离散的、独立工作单元。如：各种事件、执行主线程、setTimeout、解析 HTML 等。
>
> **微观任务：**所谓的微观任务就是更小的任务，主要是为了更新应用程序的状态，必须保证它在页面重新渲染 UI 之前执行。如:promise。



## 事件循环的运行机制（具体实现）？

**※ 答✔：事件循环的运行机制（具体实现）？**

> 1）所有同步任务都在主线程上执行，形成一个执行栈。
>
> 2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
>
> 3）不同的任务源分配到不同的 Task 队列中，任务源分为微任务和宏任务。
>
> 4）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
>
> 5）只要主线程空了，就会去读取"任务队列"。



#### 4、事件循环原理

**※ 答✔：事件循环的原理？**

> 1）当主线程没有执行任务时，事件迭代循环去任务队列查看是否有已完成的异步任务。
>
> 2）事件每循环一次就是一次迭代循环，每一次迭代循环最多在宏观任务队列中取出一个宏观任务加入到执行栈中执行，完成后就会执行微观队列中的任务，直到微观队列中的微观任务全部执行完成才会新渲染一次UI，然后进入下一次的迭代循环中。
>
> 3）每个微任务都会在下一次渲染 UI 之前执行完成，为了保证渲染前更新应用程序状态
>
> 4）浏览器每秒渲染 60 次页面，达到每秒 60 帧的速度，也就是说每 16 ms 完成一次刷新，所以执行单个宏任务和附带的微任务不能超过这个时间，否则会影响平滑流畅度，甚至页面会产生无响应。



### 三、Node 中的事件循环

> Node.js 是基于事件驱动型、非阻塞的 IO 模型。
>
> 1）所谓的事件驱动模型，当服务器接受到请求时，将其关闭进行处理，然后去接受下一个请求。当这个请求执行完成，就会被放到消息队列，当达到队列头部的时候，就会将结果返回给用户。
>
> 3）所谓的非阻塞 IO 操作，因为 webserver 一直接受请求而不等待任何读写操作。



### 四、两种计时器

> 延迟计时器可以可以延迟一段代码的执行，可以将长时间运行的任务分解为不阻塞事件循环的小任务，以阻止浏览器渲染，浏览器的过程会使得程序运行缓慢、没有反应。

- 延迟计时器（setTimeout)
- 间隔计时器（setInterval)



#### 1、延迟计时器（setTimeout）

> 延迟计时器会在设定的时间内延迟执行回调函数。

**注意：**

① 由于 javascript 是单线程执行的，**只能控制计时器何时被加入队列，而无法控制计时器何时执行**。

② 使用 0 ms 作为超时时间并不代表将在 0 ms 执行回调，这意味着使用 0 ms 尽快执行回调，在回调之前可以进行 UI 渲染的。



#### 2、间隔计时器（setInterval）

> 每一间隔就会执行一次回调。



#### 3、H5 新增定时器

> 传统的动画是由 setTimeout 或者 setInterval 完成的，但是存在两个问题：

- 动画的循环时间间隔不好确定，设置过长动画不够平滑，过短不够浏览器重绘达到瓶颈。
- 定时器设置的时间只是加入队列的时间，而不是立即执行的时间。

所以 H5 新增加了 `requestAnimationFrame `。



###### ▉ 优点

1、 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。

2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。

3、requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。



## 常用定时器面试题

> 面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？



#####  ※ 答✔：setTimeout 的特点？

> setTimeout 并不是设置了多久执行就是多久执行，因为 js 是单线程的，如果前边的任务执行的时间长，就会导致`setTimeout` 不会按期执行。



#####  ※ 答✔：setInterval的特点？

> setInterval 该函数是每隔一段时间执行一次回调函数。通常来说不建议使用 `setInterval`，因为

- 第一，不能保证在预期的时间执行任务。

- 第二，它存在执行累积的问题：如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。

> **补充：**如果有循环定时器的需求，其实完全可以通过 `requestAnimationFrame` 来实现。



#####  ※ 答✔：requestAnimationFrame  的特点？

[点击查看详细教程](<https://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html>)

> 1、ruestAnimationFrame 是浏览器用于定时循环操作的一个接口，主要用途是按帧对网页进行重绘。设置这个API的目的是为了让各种网页动画效果能够有一个统一IDE刷新机制，节省资源，提高系统的性能。
>
> 2、`requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。



### 五、处理复杂任务

> 在开发中，js 单线程的特性是最大的问题，因为当 js 忙于执行时，浏览器和用户的交互会变的很迟钝，甚至无响应，这是由于 js 执行任务时，重新更新 UI 渲染就会暂停，导致浏览器出现卡顿现象。可以通过 setTimeout 将大任务分割成小块任务循环渲染 UI 转化为非阻塞的操作。



###### ▉ setTimeout 解决

```javascript
const rowCount = 2000; // 行
const divdeInto = 4;   // 分 4 个阶段渲染
const chunkSize = rowCount / divdeInto; // 每个阶段渲染 500 行
let iteration = 0;

let table = document.querySelectorAll('tbody')[0];
setTimeout(function generateRows(){
    // 计算上次渲染的位置
    const base = chunkSize * iteration;
    
    for(let i = 0; i < chunkSize; i++){
        const tr = document.createElement("tr");
        for(let t = 0; t < 6;t++){
            const td = document.createElement("td");
            td.appendChild(document.createTextNode((i + base) + "," + t + "," + iteration));
            tr.appendChild(td);
        }
        table.appendChild(tr)
    }
    
    iteration ++;
    if(iteration < divdeInto){
        setTimeout(generateRows,0)
    }
},0)
```



###### ▉ 虚拟滚动解决

```

```









