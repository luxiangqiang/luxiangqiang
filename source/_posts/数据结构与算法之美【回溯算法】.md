---
title: 数据结构与算法之美【回溯算法】
categories:
- 数据结构
tags:
- 数据结构
password: lxqwan915816816
copyright: true
---

![](/images/回溯算法.png)

小鹿带你走进数据结构与算法之美中的10大算法之一回溯算法。

<!--more-->



### 一、如何理解“回溯算法”？

#### 1、回溯思想

> 深度优先搜索用到的就是回溯算法思想，当我们某一条路行不通时，我们就退回上一个岔口选择其他路径。



#### 2、举例

**① 八皇后问题**

> 有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。

![](/images/八皇后问题.png)

**② 问题解答**

> 将此问题分为八个阶段，我们拿着八个棋子从第一行开始开始放，每放一次，我们就不停的检查是否满足条件，如果满足，我们就放置下一个棋子；如果不满足，我们就尝试另一种方法。



**③ 代码实现**

```java
// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列
int[] result = new int[8];

// 调用方式：cal8queens(0);
public void cal8queens(int row) { 
  if (row == 8) { // 8 个棋子都放置好了，打印结果
    printQueens(result);
    return; // 8 行棋子都放好了，已经没法再往下递归了，所以就 return
  }
  for (int column = 0; column < 8; ++column) { // 每一行都有 8 中放法
    if (isOk(row, column)) { // 有些放法不满足要求
      result[row] = column; // 第 row 行的棋子放到了 column 列
      cal8queens(row+1); // 考察下一行
    }
  }
}

// 判断 row 行 column 列放置是否合适
private boolean isOk(int row, int column) {
  int leftup = column - 1, rightup = column + 1;
  for (int i = row-1; i >= 0; --i) { // 逐行往上考察每一行
    if (result[i] == column) return false; // 第 i 行的 column 列有棋子吗？
    if (leftup >= 0) { // 考察左上对角线：第 i 行 leftup 列有棋子吗？
      if (result[i] == leftup) return false;
    }
    if (rightup < 8) { // 考察右上对角线：第 i 行 rightup 列有棋子吗？
      if (result[i] == rightup) return false;
    }
    --leftup; ++rightup;
  }
  return true;
}

// 打印出一个二维矩阵
private void printQueens(int[] result) { 
  for (int row = 0; row < 8; ++row) {
    for (int column = 0; column < 8; ++column) {
      if (result[row] == column) System.out.print("Q ");
      else System.out.print("* ");
    }
    System.out.println();
  }
  System.out.println();
}

```



### 二、回溯算法的应用

#### 1、0 - 1 背包

**① 问题**

> 有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？



**② 分析**

> 1、我们第一想到的就是贪心算法，但是贪心算法前提条件是物品可以分割的，可以装某一物品的一部分放进背包，但是这个问题不能分割的，要么装下，要么不装，我们用回溯算法来解决。
>
> 2、每个物品我们有两种状态，总的装法就有 2^n 种，怎么才能不重复的穷举这些可能呢？



**③ 解决**

> 我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。



**④ 代码实现**

```java
// 存储背包中物品总重量的最大值
public int maxW = Integer.MIN_VALUE; 
// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；
// w 背包重量；items 表示每个物品的重量；n 表示物品个数
// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：
// f(0, 0, a, 10, 100)
public void f(int i, int cw, int[] items, int n, int w) {
  // cw==w 表示装满了 ;i==n 表示已经考察完所有的物品
  if (cw == w || i == n) { 
    if (cw > maxW) maxW = cw;
    return;
  }
    
  // 已经超过可以背包承受的重量的时候，就不要再装了(已改)
  if (cw + items[i] <= w) {
    f(i+1,cw + items[i], items, n, w);
  }else{
    f(i+1, cw, items, n, w); 
  }
}
```



#### 2、正则表达式

**① 问题**

> 假设正表达式中只包含“* ”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？



**② 分析**

> 我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。



**③ 解决**

> 如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。



**③ 代码实现**

```java
public class Pattern {
  private boolean matched = false;
  private char[] pattern; // 正则表达式
  private int plen; // 正则表达式长度

  public Pattern(char[] pattern, int plen) {
    this.pattern = pattern;
    this.plen = plen;
  }

  public boolean match(char[] text, int tlen) { // 文本串及长度
    matched = false;
    rmatch(0, 0, text, tlen);
    return matched;
  }

  private void rmatch(int ti, int pj, char[] text, int tlen) {
    if (matched) return; // 如果已经匹配了，就不要继续递归了
    if (pj == plen) { // 正则表达式到结尾了
      if (ti == tlen) matched = true; // 文本串也到结尾了
      return;
    }
    if (pattern[pj] == '*') { // * 匹配任意个字符
      for (int k = 0; k <= tlen-ti; ++k) {
        rmatch(ti+k, pj+1, text, tlen);
      }
    } else if (pattern[pj] == '?') { // ? 匹配 0 个或者 1 个字符
      rmatch(ti, pj+1, text, tlen);
      rmatch(ti+1, pj+1, text, tlen);
    } else if (ti < tlen && pattern[pj] == text[ti]) { // 纯字符匹配才行
      rmatch(ti+1, pj+1, text, tlen);
    }
  }
}
```



#### 补充

> 剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。



### 三、思考

#### 问题

> 现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？



#### 解答

>