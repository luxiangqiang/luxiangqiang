---
title: 重学前端之浏览器如何工作的【浏览器】
categories:
- 前端
- 浏览器
tags:
- 前端
- 浏览器
---



浏览器是如何工作的？

<!--more--> 

# 浏览器是如何工作的？



## 第一阶段：（通讯部分）HTTP 的请求过程

### 一、浏览器的请求过程

> DOM 树构建、CSS 计算、渲染、合成、绘制。



- 浏览器使用 HTTP 协议或者 HTTPS  协议，向服务器发送请求。
- 把请求回来的 HTML 代码经过解析，**构成 DOM 树**；
- 最后根据 CSS 属性对元素进行逐个**渲染**，得到内存中的位图。
- 一个可选的步骤是对位图进行**合成**，极大地增加后续绘制的速度；
- 合成之后，再**绘制**到界面上。



### 二、HTTP 协议

> 1、HTTP 是纯粹的文本协议，基于 TCP 协议出现的。TCP 是双向通信通道，HTTP 规定了 Request-Response 的模式，必须是由客户端首先发起。
>
> 2、浏览器是只需要 tcp 库或者现成的 http 库就能搞定网络通讯部分。



#### 1、HTTP 请求

- 请求的方法
- 请求的路径
- 请求的协议
- 请求的版本



#### 2、HTTP 响应

- 响应的协议
- 响应的版本
- 响应的状态
- 响应的文本



### 三、HTTP 协议格式

![](/images/HTTP格式.png)



#### 1、Method（方法）

- ##### GET

> 通过浏览器访问的都是 GET 方法。



- ##### POST

> 表单提交使用 POST 方法。



- ##### HEAD

> HEAD 则是跟 GET 类似，只返回请求头，多数由 Js 发起。



- ##### PUT

- ##### DELETE

> PUT 和 DELETE 分别表示**添加**资源和**删除**资源。



- ##### CONNECT

> 现在多用于 HTTPS 和 WebSocket。



- ##### OPTIONS

- ##### TRACE

> OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。



#### 2、Status code(状态码) 和 Status text(状态文本)

- ##### 1XX ：临时回应，表示客户端请继续。

> 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。



- ##### 2XX ：请求成功。

  - 200 ：请求成功



- ##### 3XX ：表示请求的目标有变化，希望客户端进一步处理。

  - 301 && 302：永久性与临时性跳转。

  > 实际上 301 更接近于一种报错，提示客户端下次别来了。

  - **304 ：跟客户端缓存没有更新。**

  > 客户端本地已缓存资源，发送条件请求判断是否为最新版本，如果为最新版本，返回 304 状态码，读取本地缓存。



- ##### 4XX ：客户端请求错误。

  - 403 : 无权限。
  - 404：表示请求的页面不存在。
  - 418：超文本咖啡壶控制协议。



- ##### 5XX :服务端请求错误。

  - 500：服务端错误。
  - 503：服务器暂时性错误，可以一会再试。



#### 3、HTTP Head(HTTP 头)

- ##### Request Header。

![](/images/requestheader.png)

- ##### Response Header。

![](/images/responseheader.png)



#### 4、HTTP Request Body

> HTTP 请求的 body 主要用于提交表单场景。



- application/json
- application/x-www-form-urlencoded  (form 标签提交默认格式)
- multipart/form-data （文件上传）
- text/xml





## 第二阶段：DOM树是如何构建的？     

> 第一阶段用 HTTP/HTTPS 请求服务器，服务器返回数据进行第二阶段构建 DOM 树。
>

![](/images/构建DOM树.png)



### 一、词（token）的拆分

> 这部分内容正是 HTTP 的 Response 的 body 部分内容，词（token）是最小的有意义的单元。就是将各类标签和属性拆分。
>



我们就收到字符串之后并不知道那个词，每读入一个字符都要进行决策，要想把字符流解析成词，我们就是用状态机。



### 二、状态机

#### 1、状态机的定义

> 大部分语言的**词法部分**都是使用状态机实现的。

![](/images/状态机.png)

> HTML 共规定 80 个状态：https://html.spec.whatwg.org/multipage/parsing.html#tokenization



#### 2、状态机的原理

> 状态机把每个词的特征字符逐个拆分开，然后再把所有词的特征字符链合并起来，形成联通图结构。

- 如果获得的是一个非 < 字符，那么可以认为进入了一个文本节点；
- 如果获得的是一个 < 字符，那么进入一个标签状态。
- 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。
- 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。
- 如果下一个字符是字母，那么可以确定进入了一个开始标签。
- 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。



#### 3、状态机的实现

> 每个函数就是一种状态，参数是接受的字符，返回值是下一个状态函数。

```javascript
var data = function(c){
    if(c=="&") {
        return characterReferenceInData;
    }
    if(c=="<") {
        return tagOpen;
    }
    else if(c=="\0") {
        error();
        emitToken(c);
        return data;
    }
    else if(c==EOF) {
        emitToken(EOF);
        return data;
    }
    else {
        emitToken(c);
        return data;
    }
};
var tagOpenState = function tagOpenState(c){
    if(c=="/") {
        return endTagOpenState;
    }
    if(c.match(/[A-Z]/)) {
        token = new StartTagToken();
        token.name = c.toLowerCase();
        return tagNameState;
    }
    if(c.match(/[a-z]/)) {
        token = new StartTagToken();
        token.name = c;
        return tagNameState;
    }
    if(c=="?") {
        return bogusCommentState;
    }
    else {
        error();
        return dataState;
    }
};
```



#### 4、字符流转换成词

> 每一个状态是一个函数，通过 "if else" 来区分下一个字符做状态迁移。状态迁移，将当前状态函数返回下一个状态函数。

```javascript
function HTMLLexicalParser(){

    // 状态函数们……
    function data() {
        // ……
    }

    function tagOpen() {
        // ……
    }
    // ……
    var state = data;
    this.receiveInput = function(char) {
        state = state(char);
    }
}

```



### 三、构建 DOM 树

> DOM 树的构建，利用数据结构中的栈来实现。



- 接受字符串，转换成词，开始构建 DOM 树；
- 栈顶的最后为根元素，DOM 树的第一项就是 stack[0]；
- 不同的 HTML 节点对应不同的  Node 子类。



#### 1、利用栈来构建 DOM 树

> 源代码完全遵守 xhtml，html 具有很强的容错能力，当栈顶和栈尾不匹配的时候，又有一套复杂的规则。
>
> 链接：http://w3c.github.io/html/syntax.html#tree-construction

- 栈顶元素就是当前节点；

- 遇到属性，就添加到当前节点；

- 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；

- 遇到注释节点，作为当前节点的子节点；

- 遇到 tag start 就入栈一个节点，当前节点就是这个节...

- 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。





## 第三阶段：CSS 的计算

> 当我们构建 DOM 树的时候，这个过程会被浏览器流式的处理，从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上，CSS属性也会同步计算。这一过程拿到元素会一次匹配规则，根据规则的优先级进行覆盖和调整，
>



### 一、选择器的各种符号

> 那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。

- 空格

- < 

- \+ 

- ~ 

- ||


#### 二、匹配规则

#### 1、后代选择器“空格”

> **匹配规则：**后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。

```javascript
a#b .cls {
    width: 100px;
}
```

```html
<a id=b>
    <span>1<span>
    <span class=cls>2<span>
</a>
<span class=cls>3<span>

```



#### 2、后继选择器“~”

> **匹配规则：**后继选择器只作用于一层，上述的激活或者关闭规则不适用了。所以给选择器的激活，带上一个条件：父元素。这里的父元素是 <div>。

```html
.cls~* {
    border:solid 1px green;
}
<div>
    <span>1<span>
    <span class=cls>2<span>
    <span>
        3
        <span>4</span>
    <span>
    <span>5</span>
</div>

```

> “后继”：cls 的后继有 2, 3, 5。



#### 3、子代选择器“>”

> 拿当前节点作为父元素，然后激活后边的 .cls 选择条件，并且指定了父元素必须是当前div，后续的构建 DOM 中就选中了相应的标签。



#### 4、直接后继选择器“+”

> 直接对唯一元素生效，不用反复的激活和关闭规则。匹配到之后让其失效。



#### 5、逗号分隔

> 逗号分隔看做是两条规则来处理。为了提高效率，可以把选择器构造成一课树：

```
#a .cls {

}

#a span {

}
#a>span {

}
```

- #a

  - <空格>.cls

  - <空格>span

  - > span





## 第四阶段：排版（确定元素位置）

> 所谓的排版，就是确定每一个文字的位置。



### 一、浏览器的排版

> 浏览器最基本的排版就是**正常流排版**（跟平时书写文字一样，所以叫正常溜），包括**顺次排版**和**折行排版**。



#### 1、正常流排版

> 文字排版遵循公认的文字排版模型，包括**行模型**（行顶、行底、文字区域、基线）和**文字在行模型中的排布**。



■ **浏览器所支持的元素**

- 双向文字系统（不同语言文字书写顺序不同）
- 盒模型（元素和文字混排）—— 元素被定义为长方形区域（边框、留白、边距）
- 绝对定位元素 —— 不参加排版计算，直接由 top 和 left 等属性确定自身的位置，**position** 属性控制
- 浮动元素元素 —— 在正常流的位置向左或向右移动到边界，并占据一块排版空间，float 元素控制



■ **正常流 —— 文字和盒混排**

**① 文字**

> 浏览器支持文字书写的方向为主轴，跟主轴垂直的叫做交叉轴。

![](/images/横向文字排版.png)

- advance 代表每一个文字排布后在主轴上的前进距离，文字之间的间距，文字中的重要属性。

- 多数元素被当做长方形盒来排版的，而 dispaly 为 inline 的元素，是被拆分成文本来排版的。


**■ 正常流中的盒**





■ **绝对定位元素**





■ **浮动元素排版**



### 二、思考：打造自己的排版方式

> 课后练习。





## 第五阶段：在内存中进行渲染、合成、绘制

### 一、渲染

> **渲染（render）**:特指把模型变成位图的过程。



■ **位图**

> 内存中的一张二维表格，把一张图片每个像素的颜色值保存进去（位图是 DOM 树中占据浏览器内存中最多的信息，做内存优化应优先考虑）。



■ **渲染过程**

> 把每个元素对应的盒变成位图，元素包括 HTML元素 和伪元素，每一个盒对应一张位图。



-  **图形**

> 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类，需要一个底层库来支持。



- **文字**

> 盒中的文字也需要底层库来支持，叫做字体库，最常用的字体库（Freetype）。



### 二、 **合成**

> 渲染过程不会把子元素渲染到位图上面，合成的过程，就是为元素创建一个 “合成后的位图”，也称为合成层。



### 三、 **绘制**

> 绘制就是把位图按照 z-index 绘制到屏幕上，变成页面上的图像的过程。



- **过程**

> ① 重绘的频率过快，性能会下降，应该部分区域 重绘。
>
> ② 脏矩形算法：就是把屏幕均匀的分为若干个矩形区域。
>
> ③ 重绘部分的矩形区域就可以。





### 四、思考：js 实现一个浏览器













