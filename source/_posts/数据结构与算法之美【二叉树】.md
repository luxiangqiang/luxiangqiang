---
title: 数据结构与算法之美【二叉树】
categories:
- 数据结构
tags:
- 数据结构
password: 小鹿
---

什么样的二叉树适合用数组来存储！

<!--more-->



## 二叉树（上）

> 什么样的二叉树适合用数组来存储！



### 一、树（tree）

#### 1、树的定义

> 树中的每个元素叫做“**节点**”；用来连线的关系叫做“**父子关系”**；没有父节点的节点叫做**根节点**；我们没有子节点的节点叫做**叶子节点**。



#### 2、树的三个概

> 高度(Height)、深度(Depth)、层(Level)。

![](/images/树的概念举例.png)

- 节点的**高度** = **节点**到**叶子节点**的最长路径（边数）。
- 节点的**深度** = **根节点**到**这个节点**所经历的边的个数。
- 节点的**层数** = 节点**深度** + **1**。
-  树的高度 = 根节点的高度。



### 二、二叉树（Binary Tree）

#### 1、特点

> 二叉树，最多只有两个节点。



#### 2、两种二叉树

![](/images/二叉树例子.png)

##### ■ 满二叉树

> 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。（上图二号树） 



##### ■ 完全二叉树

① 叶子节点都在最底下**两层 **，最后一层的叶子节点都靠左排列。

② 并且除了最后一层，**其他层的节点个数都要达到最大**。

③ 数组存储中最省内存的一种方式。



### 三、如何存储一棵二叉树

> 理解完全二叉树，先理解如何存储一棵树。



#### 1、两种存储方法

- 基于指针或者引用的二叉链式存储法。
- 基于数组的顺序存储法。



##### ■ 链式存储法

![](/images/二叉树的链式存储.png)



##### ■ 顺序存储法

![](/images/非完全二叉树.png)

> ① **根节点**存储在下标 **i = 1** 的位置。
>
> ② **左子节点**存储在下标 **i * 2 = 2** 的位置。
>
> ③ **右子节点**存储在 **i * 2 + 1 = 3** 的位置。



##### ■ 链式和顺序的区别

> 1、**完全二叉树可以节省存储空间**，而下边这种情况浪费了大量的存储空间。
>
> 2、数组的存储方式不像链表一样需要额外的存储指针的空间。



### 四、二叉树的遍历

#### 1、三种方式（递归）

> 二叉树的前、中、后遍历就是一个递归的过程。

- **前序遍历：** 根节点 ——> 左子树 ——> 右节点
- **中序遍历:**    左子树 ——> 根节点 ——> 右子树
- **后序遍历:**     左子树 ——> 右节点 ——> 根节点



#### 2、递归公式

※ 递归章节链接：[如何写递归代码？]()

> 写递归代码看是否能写出递归公式，递归公式的关键就是，解决 A 问题就要假设子问题 B、C已经解决，然后看利用 B、C来解决 A。

```java
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

```



#### 3、递归代码

```java
//前序遍历
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}
//中序遍历
void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}
//后序遍历
void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```



#### 4、二叉树遍历的时间复杂度

> 每个树的结点需要遍历一遍，所以二叉树遍**历时间复杂度为 O(n)**。



### 五、扩展思考

#### 1、给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？

> 放到数组中存储有多少种存储方式，n! 种方式。



#### 2、二叉树按照层的遍历方式是怎么实现的？

> 图的广度优先遍历（※ 章节链接：[图的广度优先遍历]()）的问题。





## 二叉树（下）

> 有高效的散列表（※ 章节链接：[散列表]()）为何还需要二叉树？



### 一、二叉查找树

#### ■ 定义

> 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。



#### ■ 特点

> 在树的任意节点，其**左子树**的每个节点的值，都要**小于这个节点的值**，而**右子树**节点的值都**大于这个节点的值。**



#### ■ 优点

> **实现快速的增删改查。**



### 二、二叉查找树的操作

#### 1、查找操作

##### ■ 查找思想

> 要查找数据与根节点对比，如果等于要查找的数据，返回该数据。如果数据小于根节点，左子树进行递归。否则右子树进行递归查询。



##### ■ 代码实现

```java
    public class BinarySearchTree {
  //声明一课树
  private Node tree;
    
  //定义树结点
  public static class Node {
    //树的数据节点
    private int data;
    //树的左子树
    private Node left;
    //树的右子树
    private Node right;
	//构造传值
    public Node(int data) {
      this.data = data;
    }
  }

  //查找树操作
  //参数为要查找的数据
  public Node find(int data) {
    //给树赋值
    Node p = tree;
    //如果这棵树不为空
    while (p != null) {
      //树的根节点与要查找数据进行比较
      //如果小于根节点，就在左子树查找
      if (data < p.data) p = p.left;
      //如果大于节点，就在右子树查找
      else if (data > p.data) p = p.right;
      //否则等于根节点
      else return p;
    }
    //如果次树为空，则返回null
    return null;
  }
}
```



#### 2、插入操作

##### ■ 插入思想

> 如果插入的数据比结点大，并且节点的右子树为空，就将新数据插到右节点的位置，否则就递归遍历右子树，查找插入位置。如果数据小于根节点，那么就插入到左子树。



##### ■ 代码实现

```java
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }

  Node p = tree;
  //如果树不为空
  while (p != null) {
    //如果插入的数据大于根节点的数据
    if (data > p.data) {
      //且根节点的右子树为空
      if (p.right == null) {
        //将数据插入到右子树
        p.right = new Node(data);
        return;
      }
      //遍历下一个节点
      p = p.right;
    // data < p.data
    } else { 
      if (p.left == null) {
        p.left = new Node(data);
        return;
      } 
      p = p.left;
    }
  }
}
```



#### 3、删除操作

##### ■ 情况一：如果删除的结点没有子节点

> 在父节点将指向删除结点的指针为 null。



##### ■ 情况二：如果删除的结点只有一个节点（左子节点或右子节点）

> 将父节点直接指向删除节点的子节点。



##### ■ 情况三：要删除的节点有两个子节点

> 1、首先找到该节点的右子树中最小的结点。将最小节点与删除节点进行替换。
>
> 2、删除这个最小节点，因为最小节点没有左子树。



##### ■ 删除节点改进

> 单纯的将将要删除的结点标记为已删除，但不是真正的删除，单数删除的结点还是存储到内存空间中，比较浪费内存，但是删除操作就变得很简单了。



##### ■ 代码实现

```java
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```



#### 4、查找最大节点和最小节点

##### ■ 查找最大节点

```java
/**
* 时间:2019/2/24
* 功能:寻找最大节点
*/
public Node findMax() {
    //如果树为空树,直接返回
    if(tree == null) return null;
    //否则遍历右子树寻找最大点
    Node p = tree;
    while(p.right != null) {
   		p = p.right;
    }
    return p;
}
```



##### ■ 查找最小节点

```java
/**
* 时间:2019/2/24
* 功能:寻找最小节点
*/
public Node findMin() {
    if(tree == null) return null;
    //否则遍历左子树寻找最大点
    Node p = tree;
    while(p.left != null) {
    	p = p.left;
    }
return p;
}
```



#### 5、查找前驱结点和后继节点

##### ■ 代码实现

```

```



#### 6、输出有序数据序列

> 二叉查找树(二叉排序树)，中序遍历二叉树。时间复杂度为 O(n)。



### 三、二叉查找树存储对象

> 在实际开发，用二叉查找树存储多个字段的对象，以对象的某个值来构建二叉查找树，其他字段叫做**卫星数据**。



#### 1、存储相同的值

■ **方法一：**

> 二叉查找树中每一个节点不仅会存储一个数据，因此通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储到同一个节点上。



■ **方法二：**

> ① **插入数据时，**将相同的值作为大于根节点的值，放在该结点的右子树，继续遍历，直到结束为止。
>
> ② **查找数据时**，遇到相同值的结点，我们并不停止查找操作，我们继续在右子树进行查找，直到遇到叶子节点，停止。这样才能把键值等于要查找值的所有节点都找出来。
>
> ③ **删除数据时，**需要先查找到每个要删除的节点，然后再按前面讲的删除操作方法，依次进行删除。



### 四、二叉查找树的时间复杂度

#### 1、时间复杂度分析

##### ■ 最糟糕的情况

> 二叉查找树插入数据失去平衡，退化成单链表，查找的时间复杂度为 O(n)。



##### ■ 最理想的情况

> **完全二叉树：**求查找、插入、删除操作的时间复杂度，时间复杂度其实都跟树的高度成正比，也就是O(height)，**如何求n个节点的完全二叉树的高度？**



##### ■ 具体分析

> ① 高度 = 层数 - 1，转化成层来计算，第一层一个结点，第二层两个节点，第三层四个结点...... 第 K 层结点数为 2^(K-1)。
>
> ② 完全二叉树最后一层的节点个数在 1 个到 2^(L-1) 个之间（假设最大层数是 L），把每层的节点加起来就等于 n。

```java
//完全二叉树
n >= 1+2+4+8+...+2^(L-2)+1
n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
```

> ③ 等比数列求和，可以计算出范围 [log2(n+1), log2n +1] ，所以完全二叉树的高度小于等于 log2n 。



##### ■ 改进

> **平衡二叉树:**搭建一种平衡的二叉树，树的高度接近于 logn ,插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。



### 五、相对于散列表，为什么还用二叉查找树呢？

> 1、散列表中的**数据无序**存储的，输出数据需要先排序。而二叉查找树直接中序遍历，在 O(n）时间复杂度内，输出有序的数据序列。
>
> 2、散列表**扩容耗时**，遇到**散列冲突**时。性能不稳定。二叉查找树尽管不稳定，工程中最常用的是平衡二叉查找树性能非常稳定，时间复杂度稳定在 O(logn)。
>
> 3、笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为**哈希冲突**的存在，这个**常量不一定比 logn 小**，所以实际的查找速度可能不一定比 O(logn) 快。加上**哈希函数的耗时，**也不一定就比平衡二叉查找树的效率高。
>
> 4、 **散列表的构造比二叉查找树要复杂**，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
>
> 5、**浪费大量内存空间。**为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。



### 六、扩展思考：如何通过编程，求出一棵给定二叉树的确切高度呢？

>

















