---
title: 数据结构与算法之美【跳表1】
categories:
- 数据结构
tags:
- 数据结构
password: tiaobiao
---

![](/images/跳表.png)

为什么 Redis 一定要用跳表来实现有序集合？而不是红黑树？

<!--more-->



## 跳表的实现

![](/images/跳表示意图.png)

### 一、什么是跳表？

> 用单链表来实现二分查找进行稍加修改，支持类似于“二分”的查找算法。我们把改造之后的数据结构叫做跳表。



### 二、优点是什么？

> **支持快速的增、删、改、查**，写起来也不复杂，可以完全代替红黑树。



### 三、怎么实现跳表？

> 对单链表进行添加索引层，能够快速的实现查找某一个结点。



#### 1、快速查找的原因

> 加上一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查询效率提高了不少。



#### 2、改进

> 为了再改进查询效率，我们会再添加二级索引、三级索引...



#### 3、举例

![](/images/跳表举例子.png)

> 原本 65 个结点需要遍历 65 次进行查找，现在建立了五层索引，查找次数只用了 11 次。数据越多，效果越来越明显。



### 三、跳表的时间复杂度

> 跳表的时间复杂度。



#### 1、 索引个数的计算

> 假设每两个结点设置一个索引，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。



#### 2、时间复杂度分析

> 1、假设索引有 h 级，最高级的索引有 2 个结点，可得 n/(2^h)=2，h=log2n - 1如果包含原来的这一层，跳表的高度就是 log2n 。
>
> 2、查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn）。
>
> 3、按照前边的错音，只需要遍历 3 个就可以了，也就是 m=3



#### 3、m = 3 是怎么来的？

我们规定每层索引的节点与节点之间的只有三个结点。

![](/images/跳表中m.png)



#### 4、时间复杂度

> 跳表的时间复杂度为 O(logn) ,和二分查找的时间复杂度是相同的。



### 四、跳表的空间复杂度

> 跳表的实现，需要存储多级索引，会消耗掉更多的存储空间。



#### 1、结点空间分析

> 每个索引层需要额外的存储空间，以三个结点为例，一级索引需要 n/3 ,二级索引需要 n/9 ,以此类推。

![](/images/跳表的空间复杂度.png)

> **跳表的时间复杂度为：O(n) 。**



#### 2、怎么降低跳表的空间复杂度？

> 增加结点之间的间距，尽管时间复杂度没有改变，但是索引的存储空间减少了一半。不用过多的在乎这些，当单链表中的存储有很大对象的时候，索引额外的空间就可以忽略了。
>



### 五、跳表高效的动态插入和删除

#### 1、插入数据

> 会以时间复杂度为 O(logn) 进行查找，然后以 O(1) 进行插入数据。



#### 2、删除数据

> 删除也是使用同样的方法来解决，删除的同时一定要获取前驱结点，但是记住，**删除数据的同时要删除索引**。



### 六、跳表索引动态更新

> 我们不断的往跳表中添加数据，导致某一个结点数据很多。极端情况下，会退化成单链表。



#### 1、动态更新

> 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第K 级这 K 级索引中。

![](/images/跳表的随机函数.png)



#### 2、代码实现

```java
/**
 * 跳表的一种实现方法。
 * 跳表中存储的是正整数，并且存储的是不重复的。
 *
 * Author：ZHENG
 */
public class SkipList {

  private static final int MAX_LEVEL = 16;

  private int levelCount = 1;

  private Node head = new Node();  // 带头链表

  private Random r = new Random();

  public Node find(int value) {
    Node p = head;
    for (int i = levelCount - 1; i >= 0; --i) {
      while (p.forwards[i] != null && p.forwards[i].data < value) {
        p = p.forwards[i];
      }
    }

    if (p.forwards[0] != null && p.forwards[0].data == value) {
      return p.forwards[0];
    } else {
      return null;
    }
  }

  public void insert(int value) {
    int level = randomLevel();
    Node newNode = new Node();
    newNode.data = value;
    newNode.maxLevel = level;
    Node update[] = new Node[level];
    for (int i = 0; i < level; ++i) {
      update[i] = head;
    }

    // record every level largest value which smaller than insert value in update[]
    Node p = head;
    for (int i = level - 1; i >= 0; --i) {
      while (p.forwards[i] != null && p.forwards[i].data < value) {
        p = p.forwards[i];
      }
      update[i] = p;// use update save node in search path
    }

    // in search path node next node become new node forwords(next)
    for (int i = 0; i < level; ++i) {
      newNode.forwards[i] = update[i].forwards[i];
      update[i].forwards[i] = newNode;
    }

    // update node hight
    if (levelCount < level) levelCount = level;
  }

  public void delete(int value) {
    Node[] update = new Node[levelCount];
    Node p = head;
    for (int i = levelCount - 1; i >= 0; --i) {
      while (p.forwards[i] != null && p.forwards[i].data < value) {
        p = p.forwards[i];
      }
      update[i] = p;
    }

    if (p.forwards[0] != null && p.forwards[0].data == value) {
      for (int i = levelCount - 1; i >= 0; --i) {
        if (update[i].forwards[i] != null && update[i].forwards[i].data == value) {
          update[i].forwards[i] = update[i].forwards[i].forwards[i];
        }
      }
    }
  }

  // 随机 level 次，如果是奇数层数 +1，防止伪随机
 private int randomLevel() {
    int level = 1;
    for (int i = 1; i < MAX_LEVEL; ++i) {
      if (r.nextInt() % 2 == 1) {
        level++;
      }
    }

    return level;
  }

  public void printAll() {
    Node p = head;
    while (p.forwards[0] != null) {
      System.out.print(p.forwards[0] + " ");
      p = p.forwards[0];
    }
    System.out.println();
  }

  public class Node {
    private int data = -1;
    private Node forwards[] = new Node[MAX_LEVEL];
    private int maxLevel = 0;

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      builder.append("{ data: ");
      builder.append(data);
      builder.append("; levels: ");
      builder.append(maxLevel);
      builder.append(" }");

      return builder.toString();
    }
  }

}
```



### 七、为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

#### 1、Redis 中的有序集合支持的核心操作主要有下面这几个

- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
- 迭代输出有序序列。



#### 2、跳表比红黑树的优势

> 1、查找操作比红黑树要快。
>
> 2、插入、删除和红黑树差不多，但是**按照区间查找**O(logn)就能完成。
>
> 2、跳表更容易代码实现，意味着可读性好，不容易出错。
>
> 3、跳表更加灵活，它可以通过改变索引构建策略，**有效平衡执行效率和内存消耗。**



#### 3、红黑树的优势

> 红黑树直接拿来用就可以了，跳表必须自己实现。





