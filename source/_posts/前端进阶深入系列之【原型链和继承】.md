---
title: 前端进阶深入系列之【原型链和继承】
categories: 
- 前端
- javascript
- 前端深入系列
tags: 
- 前端
- javascript
- 前端深入系列 
---

一篇让你完全明白 js 中原型链和继承！

<!--more-->



### 一、原型链

> 回顾上一节的内容《原型》，我们知道了构造函数与实例以及原型对象之间的关系，下面我们来看原型链。



#### 1、概念

> 所谓的原型链就是，一个构造函数的原型对象是另一个构造函数的实例。·



#### 2、实现

> 要在引用的对象（实例 instance）中引用某个属性，首先在对象内部查找，然后再到原型对象中查找（instance.\__proto__ (constructor1.prototype)），如果这个原型对象是另一构造函数的实例的话，就会继续沿着这个实例的原型对象继续查找。



#### 3、原型链

> 这种实例与原型的链条叫做原型链。

```
搜索轨迹: instance1--> instance2 --> （instance2.__proto__ ）constructor2.prototype…-->Object.prototype 
```

> **补充：**所有的对象都继承与 Object 对象。



#### 4、原型和实例的关系

###### ▉ instanceof （实例 —> 原型）

> 用于测试实例（instance）在原型链中出现的构造函数。

```javascript
alert(instance instanceof Object);// true
alert(instance instanceof Father);// true
```



###### ▉ isPrototypeOf()（原型 —> 实例）

> 只要该实例出现在原型链中，就会返回 true。

```
alert(Object.prototype.isPrototypeOf(instance));//true 
```



#### 5、原型链的问题

> 问题一：当原型链中包含引用类型值的原型（实例）时,该引用类型值会被所有实例共享; 
>
> 问题二：在创建子类型(例如创建 Son 的实例) ,不能向超类型(例如 Father )的构造函数中传递参数. 



### 二、继承

> 为了能够解决上面的问题，所以使用一下几种继承的方式。



#### 1、经典继承（构造函数）

###### ▉ 基本思想

> 在子类型构造函数的内部调用超类型构造函数. 



###### ▉ 代码实现

> 1）保证了原型链中引用类型值（实例）的独立，不被所有实例共享。
>
> 2）子类创建的时候可以向父类进行传参。

```javascript
// 详细解析
// 1、当用调用 call 方法时，this 代表 son 。
// 2、此时 Father 构造函数中的 this 指向 son。
// 3、也就是说 son 有了 colors 的属性。
// 4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。
function Father(){
	this.colors = ["red","blue","green"];
}
function Son(){
	Father.call(this);//继承了Father,且向父类型传递参数
}
var instance1 = new Son();
instance1.colors.push("black");
console.log(instance1.colors);//"red,blue,green,black"

var instance2 = new Son();
console.log(instance2.colors);//"red,blue,green" 可见引用类型值是独立的

```



###### ▉ 缺陷

> 1）继承的方法都在构造函数中定义，构造函数不能够复用了（Father 的 this 已经绑定到 son，this 只能用于 son ，所以说 Father 构造函数不能复用了 ）
>
> 2）父类中定义的方法对于子类型而言是不可见的。



#### 2、组合继承（最常见的继承模式）

> 上述的构造函数模式因为存在的两个缺点，所以不经常被使用。组合继承是将**原型链技术**和**构造函数**来实现对实例属性的继承。



###### ▉ 基本思想

> 使用**原型链**实现对**「原型属性和方法」**的继承,通过借用**构造函数**来实现对**「实例属性」**的继承. 



###### ▉ 代码实现

> 1）在原型对象上定义的方法实现了函数的复用。
>
> 2）每个实例都有属于自己的属性。

```javascript
function Father(name){
	this.name = name;
	this.colors = ["red","blue","green"];
}
// 方法定义在原型对象上（共享）
Father.prototype.sayName = function(){
	alert(this.name);
};
function Son(name,age){
    // 子类继承父类的属性  
	Father.call(this,name);     //继承实例属性，第一次调用 Father()
    // 每个实例都有自己的属性r
	this.age = age;
}
// 将父类的实例变为子类的原型对象                                 
Son.prototype = new Father();   //继承父类方法,第二次调用 Father()
Son.prototype.sayAge = function(){
	alert(this.age);
}

var instance1 = new Son("louis",5);
instance1.colors.push("black");
console.log(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //louis
instance1.sayAge();  //5

var instance1 = new Son("zhai",10);
console.log(instance1.colors); //"red,blue,green"
instance1.sayName(); //zhai
instance1.sayAge();  //10

```



###### ▉ 缺陷

> 1）组合继承调用了两次父类的构造函数，造成了不必要的消耗。



###### ▉ 改进

> 也就是寄生组合式继承。

```javascript
function Father(name){
	this.name = name;
	this.colors = ["red","blue","green"];
}
Father.prototype.sayName = function(){
	alert(this.name);
};
function Son(name,age){
	Father.call(this,name);//继承实例属性，第一次调用Father()
	this.age = age;
}
extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()
Son.prototype.sayAge = function(){
	alert(this.age);
}
var instance1 = new Son("louis",5);
instance1.colors.push("black");
console.log(instance1.colors);//"red,blue,green,black"
instance1.sayName();//louis
instance1.sayAge();//5

var instance1 = new Son("zhai",10);
console.log(instance1.colors);//"red,blue,green"
instance1.sayName();//zhai
instance1.sayAge();//10
```



#### 3、原型继承

###### ▉ 基本思想

> 创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。



###### ▉ 代码实现

> 对传入的 o 对象进行了一次浅拷贝。

```javascript
function object(o){
	function F(){}
	F.prototype = o;
	return new F();
}
```

> 浅拷贝。
>
> 1）object 所产生的对象是不相同的，但是原型对象都是 person 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 Person 所拥有，而且被子类生成的实例所共享。

```javascript
var person = {
	friends : ["Van","Louis","Nick"]
};
// 实例 1
var anotherPerson = object(person);
anotherPerson.friends.push("Rob");
// 实例 2
var yetAnotherPerson = object(person);
yetAnotherPerson.friends.push("Style");
// 都添加至原型对象的属性(所共享)
alert(person.friends); // "Van,Louis,Nick,Rob,Style"
```



###### ▉ **object.create()**  

> 在 ECMAScript5 中,通过新增 **object.create()** 方法规范化了上面的原型式继承.。
>
> 两个参数：
>
> 1）参数一：新对象的原型的对象。
>
> 2）参数二：先对象定义额外的属性（可选）。

```javascript
var person = {
	friends : ["Van","Louis","Nick"]
};
var anotherPerson = Object.create(person);
anotherPerson.friends.push("Rob");
var yetAnotherPerson = Object.create(person);
yetAnotherPerson.friends.push("Style");
alert(person.friends);//"Van,Louis,Nick,Rob,Style"
```

```javascript
var person = {
	name : "Van"
};
var anotherPerson = Object.create(person, {
	name : {
		value : "Louis"
	}
});
alert(anotherPerson.name);//"Louis"
```



####  4、寄生式继承

> 寄生继承对原型继承的改进，原型继承生成的子类实例是通过 create 的第二个参数设定的；而寄生式继承是靠函数的封装，将封装好的对象实例进行返回。



###### ▉ 基本思想

> 同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。



###### ▉ 代码实现

```javascript
function createAnother(original){
	var clone = object(original); //通过调用object函数创建一个新对象
	clone.sayHi = function(){ //以某种方式来增强这个对象
		alert("hi");
	};
	return clone; //返回这个对象
}
```



###### ▉ 缺陷

> 寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。



#### 5、寄生组合式继承

> 寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。



###### ▉ 基本思想

> 不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。



###### ▉ 代码实现

> F 的构造函数指向父类的原型对象，让 F 的实例的 constructor 指向子类构造函数，子类的构造函数的原型指向 F 的实例对象。
>
> 1）这样做避免了在 F 的实例上创建不必要的属性，也没有调用 superClass 构造函数。

```javascript
// subClass:子类构造函数
// superClass:父类构造函数
function extend(subClass,superClass){
	var prototype = object(superClass.prototype);//创建对象
	prototype.constructor = subClass;//增强对象
	subClass.prototype = prototype;//指定对象
}
```

```javascript
subClass.prototype = superClass.prototype;//直接指向超类型prototype
```

> **注意：**之所以没有进行如上操作，就是因为如上操作只不过是子类和父类共享原型对象，并没有实现继承。



###### ▉ extend 有效扩展

> 将 object() 里边的内容扩展开，将整体封装成函数。

```javascript
function extend(subClass, superClass) {
  var F = function() {};
  F.prototype = superClass.prototype;
  subClass.prototype = new F(); 
  subClass.prototype.constructor = subClass;

  subClass.superclass = superClass.prototype;
  if(superClass.prototype.constructor == Object.prototype.constructor) {
    superClass.prototype.constructor = superClass;
  }
}
```





### 三、new 运算符

> new 运算符创建对象的过程中，新创建一个对象，然后对对象进行一系列的关联。

- 创建一个空对象。
- 将空对象的原型指向构造函数的原型对象。
- 对构造函数的属性和方法进行浅拷贝到新对象中。

```javascript
var obj  = {};
obj.__proto__ = F.prototype;
F.call(obj);
```







































