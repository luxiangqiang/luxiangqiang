---
title: 前端设计模式之【单例模式】
categories:
- 设计模式
tags:
- 设计模式
---

前端设计模式之单例模式！

<!--more-->



## 一、什么是单例模式？

> **保证一个类仅有一个实例，并提供一个访问它的全局访问点**，这样的模式就叫做单例模式。



#### 1、单例模式的实现思路

当我们通过一个构造函数 new 一个对象的时候，每次生成的对象都不是同一个。我们单例模式要做的就是，无论 new 多少个对象，都要返回同一个。

设计思路：

- 创建一个类，声明一些类属性和方法。
- 在类的内部判断是否有已经 new 过实例了，通过一个变量标识。
- 如果没有 new，则新 new 一个对象，进行返回。
- 如果 new 过了，就返回之前保存的 new 对象。 

```javascript
class SingleDog {
    show() {
        console.log('我是一个单例对象')
    }
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!SingleDog.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            SingleDog.instance = new SingleDog()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return SingleDog.instance
    }
}

const s1 = SingleDog.getInstance()
const s2 = SingleDog.getInstance()

// true
s1 === s2
```

**闭包的实现方式：**

```javascript
SingleDog.getInstance = (function() {
    // 定义自由变量instance，模拟私有变量
    let instance = null
    return function() {
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new SingleDog()
        }
        return instance
    }
})()
```



## 应用：Vuex 中的单例模式

无论是 React 的 Redux 还是 Vue  的 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。所说的 Store 正是单例模式的典型应用。



#### 1、为什么使用 vuex？

我们都知道，为了在项目中做到解耦，不得不使用模块化和组件化，组件化在Vue 中得到应用，虽然组件化简化了项目的开发和维护，但是组件化的使用也带了了数据的传输问题。

如果我们父子组件可以通过 props，如果兄弟组件之间的通信，我们通过函数监听的方式也能解决。如果我们的组件层层递进，传递数据需要好几层，我们怎么办呢？我们将这些共享的数据进行抽离，放在一个全局中，按照我们指定的规则去存储，于是就有了状态管理 Vuex。



#### 2、Vuex 如何确保 Store 的唯一性？

我们通常使用 Vuex 在项目中的引入方式为：

```javascript
// 安装vuex插件
Vue.use(Vuex)

// 将store注入到Vue实例中
new Vue({
    el: '#app',
    store
})
```



`Vuex` 插件是一个对象，它的内部有一个 `install` 方法来进行安装，然后通过 `Vue.use()` 方法注入到 `Vue` 实例中去。每 install 都要进行注入 Vue,那我们怎么保证每次都是注入相同的 Store 实例？其实和我们上述的方法是一样的。



```javascript
let Vue // 这个Vue的作用和楼上的instance作用一样
...

export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```



#### 3、如果没有单例模式会怎么样？

失去了单例判断能力的 install 方法，会为当前的Vue实例重新注入一个新的 Store，也就是说你中间的那些数据操作全都没了，一切归 0。因此，单例模式在此处是非常必要的。



## 单例模式面试题：

### 1、实现一个 Storage 

> 实现一个` Storage`，使得对象为单例模式，基于` localStorage` 进行封装。实现方法 `setItem(key，value) `和 `getItem(key)`。



#### 实现思路

> 单例模式的实现有两种方法，第一种实现就是**类**实现 ，另一种方法是通过**闭包**的方式。

```javascript
class Storage {
    static getInstance () {
        // 判断是否已经 new 过一个对象
        if(!Storage.instance){
            Storage.instance = new Storage();
        }
        // 否则直接返回
        return Storage.instance
    }

    // 获取项
    getItem (key) {
        return localStorage.getItem(key);
    }

    // 设置项
    setItem (key,value) {
        return localStorage.setItem(key, value)
    }
}

const storage1 = Storage.getInstance()
const storage2 = Storage.getInstance()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

**闭包实现：**

```javascript
// 先实现一个基础的 StorageBase 类，把 getItem 和 setItem 方法放在它的原型链上
function StorageBase () {}

StorageBase.prototype.getItem = function (key){
    return localStorage.getItem(key)
}

StorageBase.prototype.setItem = function (key, value) {
    return localStorage.setItem(key, value)
}

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function(){
    let instance = null
    return function(){
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new StorageBase()
        }
        return instance
    }
})()

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 
const storage1 = Storage()
const storage2 = Storage()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```



### 2、实现一个全局的模态框

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>打开弹框</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    const Modal = (function() {
    	let modal = null
    	return function() {
            if(!modal) {
            	modal = document.createElement('div')
            	modal.innerHTML = '我是一个全局唯一的Modal'
            	modal.id = 'modal'
            	modal.style.display = 'none'
            	document.body.appendChild(modal)
            }
            return modal
    	}
    })()
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
    	const modal = new Modal()
    	modal.style.display = 'block'
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
    	const modal = new Modal()
    	if(modal) {
    	    modal.style.display = 'none'
    	}
    })
</script>
</html>
```













## 单例模式

> 在真实项目当中，为了实现模块化开发或者团队开发，我们经常应用单例模式（一般业务逻辑部分的代码都是依托单例模式设计规划的）。



#### 1、单例模式的由来

> 在之前，JS 中只有原始数据类型。由于一个相同的类型的属性会被替换掉，所有有了对象类型。

我们把对象数据类型的实现把 “**描述同一件事务的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题**” 的方式和思想叫做：**‘单例设计模式’**。

```javascript
// => 单例模式
// 1、singleton 不仅仅是对象名了，在单利模式中，singleton 称之为 “命名空间（namespace）”
var singleton={
    xxx:xxx
    ...
}
```

> 把描述同一件事务的属性或者方法存放在某一个命名空间下，多个命名空间中的属性和方法是互不干扰的。



#### 2、使用单例模式实现模块化开发

> 模块化开发：在团队协作开发的时候，我们经常会把一个复杂的页面，按照具体的功能划分称为几大块，然后分别去开发，这种模块化的思想就是模块化开发。

```javascript
// =>项目主管（开发人员）：公共模块
var utils = {
    trim:function () {
        
    }
}

// => 小鹿：搜索模块
var searchModel = {
    submit:function(){}
    ...
}

// => 小强：天气模块
var weatherModel = {
    setWeather:function(){}
    ...
}

// => 小李：频道模块
var channelModel = {
    show:function(){
        //=> 在当前命名空间下调取其他命名空间的方法，制定好对应的命名空间名字即可，
        //使用[namespace].[property] 就可以操作了
        searchModel.sumit(); 
        
        // 调取本模块的方法，可以直接使用 THIS 处理即可：此方法的 THIS 一般都是当前模块的命名空间
        this.setChannel();
    }
    ...
}
```

> 补充：
>
> - 单例模式：既方便私有，也方便共有。
> - 闭包：只方便私有，不方便共有。



### 3、高级单例模式

> 基于 JS 高阶编程技巧 ‘惰性思想’ 来实现的单例模式，并且可以把常用的设计模式（命令模式、发布订阅模式、promise 模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期的开发和维护,这种设计思想综合体就是高级单例模式，也是项目中最常应用的（把很多东西融合在一起，扩展性比较好）。

```javascript
// 利用了闭包保存的思想
var searchModel = (function(){
    var $searchPlan = $.Callbacks();
    
	function sumit(){
		...
	}
    // 高级单例模式融合了发布订阅模式
    $searchPlan.add(submit);
        
    function fn(){
		...
	}
    
    $searchPlan.add(fn);
	
	return {
        // 当前模块的唯一入口(高级单例模式融合了命令模式)
		init:function(参数配置){
        	this.submit();
        	this.fn();
            
            // 发布订阅模式
            $searchPlan
    	}
	}
})()

searchModel.init();
```



### 4、面向对象（OOP）

> 面向对象是编程思想（面向过程编程思想：C 语言是面向过程的），JAVA、PHP、C#、C++、.net。
>
> 注意：HTML 和 CSS 是标记语言，不是编程语言，没有所谓的面向对象编程。
>
> 后期学习的 less、sass 属于 CSS 预编译语言，旨在把 CSS 变为编程语言（面向对象）



#### `对象、类、实例`

- 对象：编程语言中的对象是一个泛指，万物皆对象（我们所要研究和学习以及适用的都是对象）。

- 类：对象的具体细分（按照属性或者特征细分为一些类别）

- 实例：某一类中具体的事物。



#### `JS`

> 整个 JS 都是基于面向对象开发的，里边有很多的内置类，每个对象都是其中某个类的一个实例。



### 5、学习面相对象对于我们的意义

> 研究数组：
>
> 1、创建一个数组类的实例，研究其基础语法和结构。
>
> 2、如果想要研究数据具备的功能方法，我们只需要看 `Array/Object` 这些类上都赋予了它什么样的方法。



[问题]

document.getElementById 它的上下文只能是 document，其他不可以？

> 因为 getElementById  这个方法只有 Document 这个类才有，其他的类没有，所以只有 document 这个作为 Document 的实例才能使用这个方法。









