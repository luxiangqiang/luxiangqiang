<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-01T10:42:12.602Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化与原理实践之【性能检测的工具】</title>
    <link href="http://yoursite.com/2020/01/01/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E3%80%91/"/>
    <id>http://yoursite.com/2020/01/01/前端性能优化与原理实践之【性能检测工具】/</id>
    <published>2020-01-01T10:04:33.330Z</published>
    <updated>2020-01-01T10:42:12.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之防抖和节流！</p><a id="more"></a><h3 id="一、Performance-面板"><a href="#一、Performance-面板" class="headerlink" title="一、Performance 面板"></a>一、Performance 面板</h3><blockquote><p>Performance 面板是谷歌浏览器自带性能检测工具，它可以运用到实时运行的网页中测试性能。</p></blockquote><p>当我们检测某一个交互操作时，我们直接点击实心的按钮就可以，圆箭头的按钮是重新加载页面。为了避免其他谷歌插件对页面的影响，我们一般开启<strong>无痕模式</strong>。</p><p><strong>三个参数的作用：</strong></p><ul><li><strong>FPS</strong>：这是一个和动画性能密切相关的指标，它表示每一秒的帧数。图中绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。图中以绿色为主，偶尔出现红块，说明网页性能并不糟糕，但仍有可优化的空间。</li><li><strong>CPU</strong>：表示CPU的使用情况，不同的颜色片段代表着消耗CPU资源的不同事件类型。这部分的图像和下文详情面板中的Summary内容有对应关系，我们可以结合这两者挖掘性能瓶颈。</li><li><strong>NET</strong>：粗略的展示了各请求的耗时与前后顺序。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d6a13652f0db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>主要去看 <code>Main</code> 栏目下的火焰图和 <code>Summary</code> 提供给我们的饼图——这两者和概述面板中的 <code>CPU</code> 一栏结合</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d9d24ee5bd4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><p><code>CPU</code> 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲。</p></li><li><p><code>Summary</code> 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。</p></li></ul><p><strong>火焰图：</strong></p><blockquote><p>它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等），Main 火焰图则将粒度细化到了每一个函数的调用。</p></blockquote><ul><li>x 轴表示随时间的记录。</li><li>每个长条就代表一个活动。</li><li>y 轴表示调用堆栈，我们可以看到事件是相互堆叠的，上层的事件触发了下层的事件。</li></ul><h3 id="二、LightHouse"><a href="#二、LightHouse" class="headerlink" title="二、LightHouse"></a>二、LightHouse</h3><blockquote><p>Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dc4798ee8992?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>页面性能</li><li>PWA（渐进式 Web 应用）</li><li>可访问性（无障碍）</li><li>最佳实践</li><li>SEO 五项指标的跑分。</li></ul><p>命令行使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g lighthouse</span><br><span class="line">lighthouse https:<span class="comment">//juejin.im/books</span></span><br></pre></td></tr></table></figure><h3 id="三、Performance-API"><a href="#三、Performance-API" class="headerlink" title="三、Performance API"></a>三、Performance API</h3><blockquote><p>W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.performance</span><br></pre></td></tr></table></figure><p>时间戳和整个页面流程的加载一一对应关系如下：求两个时间戳的差值就可以求出某个过程花费的时间。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dddde131e37a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664ddd4e3df9a14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// firstbyte：首包时间</span></span><br><span class="line">timing.responseStart – timing.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// fpt：First Paint Time, 首次渲染时间 / 白屏时间</span></span><br><span class="line">timing.responseEnd – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// tti：Time to Interact，首次可交互时间</span></span><br><span class="line">timing.domInteractive – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// ready：HTML 加载完成时间，即 DOM 就位的时间</span></span><br><span class="line">timing.domContentLoaded – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// load：页面完全加载时间</span></span><br><span class="line">timing.loadEventStart – timing.fetchStart</span><br></pre></td></tr></table></figure><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank" rel="noopener">Performance 官方文档</a></li><li><a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="noopener">使用 Lighthouse 审查网络应用</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">MDN Performance API 介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之防抖和节流！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【防抖和节流】</title>
    <link href="http://yoursite.com/2019/12/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/31/前端性能优化与原理实践之【防抖和节流】/</id>
    <published>2019-12-31T07:17:10.103Z</published>
    <updated>2019-12-31T10:03:18.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之防抖和节流！</p><a id="more"></a><h3 id="一、防抖（Debounce）"><a href="#一、防抖（Debounce）" class="headerlink" title="一、防抖（Debounce）"></a>一、防抖（Debounce）</h3><blockquote><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将debounce处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, better_scroll)</span><br></pre></td></tr></table></figure><h3 id="二、节流（Throttle）"><a href="#二、节流（Throttle）" class="headerlink" title="二、节流（Throttle）"></a>二、节流（Throttle）</h3><blockquote><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用throttle来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, better_scroll)</span><br></pre></td></tr></table></figure><h3 id="三、防抖的优化"><a href="#三、防抖的优化" class="headerlink" title="三、防抖的优化"></a>三、防抖的优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间, timer是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">    <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的throttle包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, better_scroll)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之防抖和节流！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【首屏渲染优化】</title>
    <link href="http://yoursite.com/2019/12/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/31/前端性能优化与原理实践之【首屏渲染优化】/</id>
    <published>2019-12-31T06:43:24.473Z</published>
    <updated>2019-12-31T07:17:03.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之首屏渲染优化！</p><a id="more"></a><h3 id="一、首屏渲染"><a href="#一、首屏渲染" class="headerlink" title="一、首屏渲染"></a>一、首屏渲染</h3><blockquote><p>尤其是在电商网站中，大量的图片会在首次展示会造成卡屏情况，所以为了能够加快首屏的渲染，所以要进行优化，采取一种懒加载的方式进行加载，等用户下拉的瞬间再即时去请求、即时呈现给他。</p></blockquote><p>这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是<strong>懒加载</strong>。</p><h3 id="二、懒加载的实现"><a href="#二、懒加载的实现" class="headerlink" title="二、懒加载的实现"></a>二、懒加载的实现</h3><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h4><ul><li><p>首先，在 <code>HTML</code> 中预设 <code>img</code> 的图片路径。</p></li><li><p>然后获取两个高度：</p><ul><li><strong>当前可视区域的高度</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure><ul><li><strong>元素距离可视区域顶部的高度（getBoundingClientRect() ）</strong>。</li></ul><blockquote><p>该方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的 CSS 边框集合 。</p><p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664360c6ceda200?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><h4 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h4><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazy-Load<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.img</span> &#123;</span></span><br><span class="line"><span class="undefined">      width: 200px;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="undefined">      background-color: gray;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pic</span> &#123;</span></span><br><span class="line"><span class="undefined">      // 必要的img样式</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      // 注意我们并没有为它引入真实的src</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/1.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/2.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/3.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/4.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/5.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/6.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/7.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/8.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/9.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/10.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 获取所有的图片标签</span></span><br><span class="line">    <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// 获取可视区域的高度</span></span><br><span class="line">    <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="comment">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = num; i&lt; imgs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 用可视区域高度减去元素顶部距离可视区域顶部的高度</span></span><br><span class="line">            <span class="keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top</span><br><span class="line">            <span class="comment">// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span></span><br><span class="line">            <span class="keyword">if</span>(distance &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// 给元素写入真实的src，展示图片</span></span><br><span class="line">                imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">                <span class="comment">// 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span></span><br><span class="line">                num = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听Scroll事件</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, lazyload, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、懒加载性能优化"><a href="#3、懒加载性能优化" class="headerlink" title="3、懒加载性能优化"></a>3、懒加载性能优化</h3><p>scroll 事件会频繁的导致触发事件，所以对性能有一定的影响，所以为了优化这种情况，我们对其进行优化。</p><p>就要进行防抖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之首屏渲染优化！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【回流和重绘】</title>
    <link href="http://yoursite.com/2019/12/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/31/前端性能优化与原理实践之【回流和重绘】/</id>
    <published>2019-12-31T05:12:30.836Z</published>
    <updated>2019-12-31T05:35:01.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之回流和重绘！</p><a id="more"></a><h3 id="一、什么是回流和重绘？"><a href="#一、什么是回流和重绘？" class="headerlink" title="一、什么是回流和重绘？"></a>一、什么是回流和重绘？</h3><h4 id="1、回流与重绘发生的原理"><a href="#1、回流与重绘发生的原理" class="headerlink" title="1、回流与重绘发生的原理"></a>1、回流与重绘发生的原理</h4><p>我们通过 JS 来改变 DOM 的结构和样式，<strong>就会触发 CSSOM 渲染树的重新构建</strong>，此时就引起来回流和重绘。</p><ul><li><strong>回流:</strong> 如果对 DOM 的<strong>几何属性（高、宽）</strong>进行改变时，浏览器就会对元素的几何属性进行重新绘制，这个过程叫做<strong>回流</strong>。</li><li><strong>重绘：</strong>修改元素的样式属性进行改变，却没对几何属性进行改变，浏览器不需要重新计算几何属性，只为元素绘制新的样式就可以了，这个过程叫做<strong>重绘</strong>。</li></ul><blockquote><p>PS：重绘不一定导致回流，回流一定导致重绘。</p></blockquote><h3 id="二、造成回流和重绘的操作"><a href="#二、造成回流和重绘的操作" class="headerlink" title="二、造成回流和重绘的操作"></a>二、造成回流和重绘的操作</h3><h4 id="1、改变-DOM-的集合属性（最高）"><a href="#1、改变-DOM-的集合属性（最高）" class="headerlink" title="1、改变 DOM 的集合属性（最高）"></a>1、改变 DOM 的集合属性（最高）</h4><blockquote><p>当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p></blockquote><p><strong>常见的几何属性有 width、height、padding、margin、left、top、border 等等</strong></p><h4 id="2、改变-DOM-的结构（适中）"><a href="#2、改变-DOM-的结构（适中）" class="headerlink" title="2、改变 DOM 的结构（适中）"></a>2、改变 DOM 的结构（适中）</h4><blockquote><p>主要指的是节点的增减、移动等操作。</p></blockquote><h4 id="3、获取特定的值（被忽略）"><a href="#3、获取特定的值（被忽略）" class="headerlink" title="3、获取特定的值（被忽略）"></a>3、获取特定的值（被忽略）</h4><blockquote><p>这些属性值都是需要实时计算才能得到的，因此浏览器得到这些值需要进行回流。</p></blockquote><p>ffsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight </p><h3 id="三、避免回流与重绘"><a href="#三、避免回流与重绘" class="headerlink" title="三、避免回流与重绘"></a>三、避免回流与重绘</h3><h4 id="1、频繁获取某些属性值"><a href="#1、频繁获取某些属性值" class="headerlink" title="1、频繁获取某些属性值"></a>1、频繁获取某些属性值</h4><blockquote><p>避免频繁的获取到某些引起回流的属性，我们通过给 JS 分压，将数据缓存起来，最后一次性进行操作 DOM。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">      el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">      el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.style.left = offLeft + <span class="string">"px"</span></span><br><span class="line">el.style.top = offTop  + <span class="string">"px"</span></span><br></pre></td></tr></table></figure><h4 id="2、合并改变样式的操作"><a href="#2、合并改变样式的操作" class="headerlink" title="2、合并改变样式的操作"></a>2、合并改变样式的操作</h4><blockquote><p>我们改变样式避免逐条的改变，这样会频繁的引起重绘，我们通过一次性设置样式，从而只进行一次重绘。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"> container.classList.add(<span class="string">'basic_style'</span>)</span><br></pre></td></tr></table></figure><h4 id="3、将-DOM-离线化"><a href="#3、将-DOM-离线化" class="headerlink" title="3、将 DOM 离线化"></a>3、将 DOM 离线化</h4><blockquote><p>我们通常所说的回流和重绘都是在线上引起的，如果我们操作不在线的 DOM 就不会引起回流和重绘，我们将这种情况叫做离线化。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.display = <span class="string">'none'</span></span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.style.display = <span class="string">'block'</span></span><br></pre></td></tr></table></figure><h3 id="四、Flush-队列"><a href="#四、Flush-队列" class="headerlink" title="四、Flush 队列"></a>四、Flush 队列</h3><p>现在的浏览器非常的聪明，会知道频繁的改动 DOM 会引起重绘和回流，那么于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。</p><p>不得已的情况就是之前获取一些属性会引起回流和重绘的，因为需要实时的获取属性，所以提前在 Flush 中出队。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之回流和重绘！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【异步更新策略】</title>
    <link href="http://yoursite.com/2019/12/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/31/前端性能优化与原理实践之【异步更新策略】/</id>
    <published>2019-12-31T02:35:15.548Z</published>
    <updated>2019-12-31T05:12:22.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之异步更新策略！</p><a id="more"></a><h3 id="一、Event-Loop"><a href="#一、Event-Loop" class="headerlink" title="一、Event Loop"></a>一、Event Loop</h3><blockquote><p>事件循环中的异步队列有两种：<code>macro</code>（宏任务）队列和 <code>micro</code>（微任务）队列。</p></blockquote><ul><li><strong>宏任务</strong>： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。</li><li><strong>微任务</strong>:    process.nextTick、Promise、MutationObserver 等。</li></ul><h4 id="1、Event-Loop-过程"><a href="#1、Event-Loop-过程" class="headerlink" title="1、Event Loop 过程"></a>1、Event Loop 过程</h4><ul><li>初始化状态：调用栈为空。微任务队列为空，宏任务队列只有一个 <code>script</code> 脚本。</li><li><code>script</code>（全局上下文） 进入调用栈，同步执行代码，在执行代码的过程，会产生新宏任务和微任务，然后分别被推入调用栈中。</li><li><code>script</code> 同步代码执行完成之后，就会被推出宏任务栈。<strong>这个过程就是宏任务队列中的任务执行和出队的过程。</strong></li><li>每当宏任务执行完一个，接着就去微任务队列执行所有的微任务，直到微任务队列为空为止。</li><li>然后接着会<strong>渲染操作</strong>，<strong>更新界面</strong>。</li><li>检查是否存在 <code>Web worker</code> 任务，如果有，则对其进行处理。</li></ul><h4 id="2、渲染过程"><a href="#2、渲染过程" class="headerlink" title="2、渲染过程"></a>2、渲染过程</h4><blockquote><p>假设：打算将更新 DOM 作为一个宏任务去处理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(task, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>setTimeout 作为一个宏任务被推入宏任务队列中，因为 script 也是一个宏任务队列的任务，所以执行完 script 之后，会执行所有的微任务，所有微任务执行完成之后，直接更新页面，刚刚加入的更新 DOM 的宏任务只能等下一轮执行了。<strong>只不过是执行了一遍  script 的无效渲染。</strong></p><blockquote><p>假设：打算将更新 DOM 作为一个微任务去处理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(task)</span><br></pre></td></tr></table></figure><p>作为一个微任务，在执行完 script 任务的时候，就会立马得到执行，然后进行渲染。<strong>对于用户来说，不用等待下一次的更新。</strong></p><h3 id="二、Vue-的异步更新策略"><a href="#二、Vue-的异步更新策略" class="headerlink" title="二、Vue 的异步更新策略"></a>二、Vue 的异步更新策略</h3><blockquote><p><strong>异步更新：</strong>当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被<strong>批量触发</strong>。这就是异步更新。</p></blockquote><h4 id="1、异步更新的优点"><a href="#1、异步更新的优点" class="headerlink" title="1、异步更新的优点"></a>1、异步更新的优点</h4><p>同一时间修改 DOM 多次，此时不会采取同步的策略，因为如果采取同步的策略会操作三次 DOM 。</p><p>我们把这三个任务塞进异步更新队列里，它们会先在 JS 的层面上被<strong>批量执行完毕</strong>。当流程走到渲染这一步时，它仅仅需要针对有意义的计算结果操作一次 DOM——这就是异步更新的妙处。</p><h4 id="2、Vue-状态更新：nextTick"><a href="#2、Vue-状态更新：nextTick" class="headerlink" title="2、Vue 状态更新：nextTick"></a>2、Vue 状态更新：nextTick</h4><blockquote><p>Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。等到了一定的时机，然后对操作进行异步的更新。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 检查上一个异步任务队列（即名为callbacks的任务数组）是否派发和执行完毕了。pending此处相当于一个锁</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    <span class="comment">// 若上一个异步任务队列已经执行完毕，则将pending设定为true（把锁锁上）</span></span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 是否要求一定要派发为macro任务</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不说明一定要macro 你们就全都是micro</span></span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// macro首选setImmediate 这个兼容性最差</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 兼容性最好的派发方式是setTimeout</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴 不是ios全都给我去Promise 如果不兼容promise 那么你只能将就一下变成macro了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果无法派发micro，就退而求其次派发为macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派发任务队列中的任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// callbacks在nextick中出现过 它是任务数组（队列）</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 将callbacks中的任务逐个取出执行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code> 中每产生一个状态更新任务，它就会被塞进一个叫 <code>callbacks</code> 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 <code>micro</code> 或 <code>macro</code> 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 <code>pending</code> 锁是开着的（false），就把它设置为锁上（<code>true</code>），然后对当前 <code>callbacks</code> 数组的任务进行派发（丢进 <code>micro</code> 或 <code>macro</code> 队列）和执行。设置 <code>pending</code> 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之异步更新策略！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【DOM 优化原理与实践】</title>
    <link href="http://yoursite.com/2019/12/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90DOM%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/28/前端性能优化与原理实践之【DOM优化原理与实践】/</id>
    <published>2019-12-28T12:06:18.003Z</published>
    <updated>2019-12-31T05:14:21.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之 <code>DOM</code> 优化原理与实践！</p><a id="more"></a><h3 id="一、DOM-优化思路"><a href="#一、DOM-优化思路" class="headerlink" title="一、DOM 优化思路"></a>一、DOM 优化思路</h3><h4 id="1-1-问题：为什么操作-DOM-那么慢？"><a href="#1-1-问题：为什么操作-DOM-那么慢？" class="headerlink" title="1.1 问题：为什么操作 DOM 那么慢？"></a>1.1 问题：为什么操作 DOM 那么慢？</h4><p><code>JS</code> 引擎和渲染引擎是独立实现的，当我们使用 <code>JS</code> 去操作 <code>DOM</code> 的时候，本质上就是“跨界”操作。每次“跨界“的操作过程性能的<strong>开销是非常大的</strong>，同时<strong>修改 DOM 的过程也是非常慢的</strong>。所以我们要尽量减少 DOM 的操作。</p><h4 id="1-2-优化：减少访问-DOM-次数"><a href="#1-2-优化：减少访问-DOM-次数" class="headerlink" title="1.2 优化：减少访问 DOM 次数"></a>1.2 优化：减少访问 DOM 次数</h4><blockquote><p>优点：通过字符串先将 DOM 结点进行拼接，拼接好之后，再插入一次，只会发生一次重绘。</p><p>缺点：但是本地的字符串操作不是非常的快。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> count=<span class="number">0</span>;count &lt; <span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).innerHTML+=<span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  container.innerHTML += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-进一步优化：DOM-Fragment"><a href="#1-3-进一步优化：DOM-Fragment" class="headerlink" title="1.3 进一步优化：DOM Fragment"></a>1.3 进一步优化：DOM Fragment</h4><p>考虑 JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是<strong>让 JS 去给 DOM 分压</strong>。<code>DomcumentFragment</code> 的实现更加的优雅。</p><blockquote><p>DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="comment">// 创建一个DOM Fragment对象作为容器</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count = <span class="number">0</span>;count &lt; <span class="number">10000</span>;count++)&#123;</span><br><span class="line">  <span class="comment">// span此时可以通过DOM API去创建</span></span><br><span class="line">  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>)</span><br><span class="line">  oSpan.innerHTML = <span class="string">'我是一个小测试'</span></span><br><span class="line">  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span></span><br><span class="line">  content.appendChild(oSpan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span></span><br><span class="line">container.appendChild(content)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之 &lt;code&gt;DOM&lt;/code&gt; 优化原理与实践！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【浏览器的运行机制】</title>
    <link href="http://yoursite.com/2019/12/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/27/前端性能优化与原理实践之【浏览器的运行机制】/</id>
    <published>2019-12-27T13:01:32.201Z</published>
    <updated>2019-12-28T12:06:50.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化与原理实践之浏览器的运行机制！</p><a id="more"></a><h3 id="一、渲染过程"><a href="#一、渲染过程" class="headerlink" title="一、渲染过程"></a>一、渲染过程</h3><ul><li><p><strong>DOM 树：</strong>解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</p></li><li><p><strong>CSSOM 树：</strong>解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是<strong>并行的</strong>。</p></li><li><p><strong>渲染树：</strong>CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</p></li></ul><h3 id="二、CSS-选择器优化"><a href="#二、CSS-选择器优化" class="headerlink" title="二、CSS 选择器优化"></a>二、CSS 选择器优化</h3><blockquote><p>CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 </p></blockquote><h4 id="2-1-优化建议"><a href="#2-1-优化建议" class="headerlink" title="2.1 优化建议"></a>2.1 优化建议</h4><ul><li>避免使用通配符，只对需要用到的元素进行选择。</li><li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li><li>不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。</li><li>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</li></ul><h3 id="三、CSS-JS-加载顺序优化"><a href="#三、CSS-JS-加载顺序优化" class="headerlink" title="三、CSS/JS 加载顺序优化"></a>三、CSS/JS 加载顺序优化</h3><blockquote><p>HTML、CSS 和 JS，都具有<strong>阻塞渲染</strong>的特性。</p></blockquote><h4 id="3-1-CSS-阻塞优化"><a href="#3-1-CSS-阻塞优化" class="headerlink" title="3.1 CSS 阻塞优化"></a>3.1 CSS 阻塞优化</h4><p><code>DOM</code> 和 <code>CSSOM</code> 才会生成渲染树，当 DOM 解析到 style 的时候，此时 CSS 会阻塞渲染。只有当 CSS 完全下载下来的时候，才会开始渲染 CSSOM 树。（尽早的完成 CSS 下载就会加快渲染页面速度）</p><ul><li><strong>放在最前边 head 中。</strong></li><li><strong>启用 CDN 实现静态资源加载速度的优化</strong></li></ul><blockquote><p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p></blockquote><h4 id="3-2-JS-阻塞"><a href="#3-2-JS-阻塞" class="headerlink" title="3.2 JS 阻塞"></a>3.2 JS 阻塞</h4><blockquote><p>JS 本质上是对 <code>DOM</code> 和 <code>CSSOM</code> 的修改，所以 JS 会阻塞 DOM 和 CSSOM。</p></blockquote><p>浏览器中有两种引擎，一种是 JS 引擎，另一种是渲染引擎。两者是相互独立的存在的。当渲染 DOM 时，遇到 script 就会将控制权交给 JS 引擎去执行。执行完之后再交给渲染引擎去执行，是 JS 把 CSS 和 HTML 阻塞了。</p><p>所以，一般 JS 的加载方式有两种：</p><ul><li><p><strong>正常加载</strong></p></li><li><p><strong>defer</strong></p></li><li><strong>async</strong></li></ul><p><strong>1、正常加载：</strong>JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p><p><strong>2、defer:</strong> defer 模式下，JS 的加载是异步的，执行是<strong>被推迟的</strong>。</p><p><strong>3、async:</strong> JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会<strong>立即执行</strong>。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><blockquote><h4 id="一般当我们的脚本与-DOM-元素和其它脚本之间的依赖关系不强时，我们会选用-async；当脚本依赖于-DOM-元素和其它脚本的执行结果时，我们会选用-defer。"><a href="#一般当我们的脚本与-DOM-元素和其它脚本之间的依赖关系不强时，我们会选用-async；当脚本依赖于-DOM-元素和其它脚本的执行结果时，我们会选用-defer。" class="headerlink" title="一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。"></a>一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</h4></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化与原理实践之浏览器的运行机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【服务器端渲染】</title>
    <link href="http://yoursite.com/2019/12/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/25/前端性能优化与原理实践之【服务器端的渲染】/</id>
    <published>2019-12-25T03:21:43.757Z</published>
    <updated>2019-12-25T05:11:14.236Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化之服务器端渲染！</p><a id="more"></a><h3 id="一、客户端渲染"><a href="#一、客户端渲染" class="headerlink" title="一、客户端渲染"></a>一、客户端渲染</h3><p>客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据  JS  的运行结果，生成相应的 DOM。</p><blockquote><p>PS：<strong>页面上呈现的内容，你在 html 源文件里里找不到</strong></p></blockquote><h3 id="二、服务器端渲染"><a href="#二、服务器端渲染" class="headerlink" title="二、服务器端渲染"></a>二、服务器端渲染</h3><p>当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。</p><blockquote><p>PS：<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。</p></blockquote><h3 id="三、服务器渲染的性能优化"><a href="#三、服务器渲染的性能优化" class="headerlink" title="三、服务器渲染的性能优化"></a>三、服务器渲染的性能优化</h3><blockquote><p>服务器端渲染只不过是分担了客户端的压力给服务器一部分，同时加大了服务器的压力。</p></blockquote><p>服务器端渲染主要针对两个方向：</p><ul><li><strong>加快首屏渲染</strong></li><li><strong>有利于 SEO 优化。</strong></li></ul><h3 id="四、服务器端渲染的应用场景"><a href="#四、服务器端渲染的应用场景" class="headerlink" title="四、服务器端渲染的应用场景"></a>四、服务器端渲染的应用场景</h3><p>服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。对于小公司来说，我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。</p><p>优化首屏渲染和 SEO 优化首先采取其他优化的方法，其他方法用完之后效果不明显的话，再采取服务器端渲染，毕竟需要申请多台服务器进行服务器渲染。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之服务器端渲染！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【CDN的缓存与回源机制】</title>
    <link href="http://yoursite.com/2019/12/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90CDN%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%9B%9E%E6%BA%90%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/25/前端性能优化与原理实践之【CDN的缓存与回源机制】/</id>
    <published>2019-12-25T02:57:03.139Z</published>
    <updated>2019-12-25T03:22:02.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化之CDN的缓存与回源机制。</p><a id="more"></a><h3 id="一、什么是-CDN？"><a href="#一、什么是-CDN？" class="headerlink" title="一、什么是 CDN？"></a>一、什么是 CDN？</h3><blockquote><p>CDN 的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<strong>内容存储和分发技术。</strong> </p></blockquote><p><strong>CDN 有两个核心的点：</strong></p><ul><li><strong>缓存：把总服务器的资源放到 CDN 服务器上的过程称为 CDN 缓存。</strong></li><li><strong>回源：本地 CDN 服务器资源已失效，需要重新向总服务器进行请求的过程称为回源。</strong></li></ul><h3 id="二、为什么要用-CDN"><a href="#二、为什么要用-CDN" class="headerlink" title="二、为什么要用 CDN?"></a>二、为什么要用 CDN?</h3><p>在带宽流量非常大、网络带宽小的情况下，需要快速响应用户的请求，从而将部分的静态资源，存放在 CDN 服务器上，当用户去请求资源的时候，经过 CDN ，如果 CDN 有存储，会直接返回给用户资源，大大加快了资源响应的速度。</p><h3 id="三、CDN-的前端性能优化"><a href="#三、CDN-的前端性能优化" class="headerlink" title="三、CDN 的前端性能优化"></a>三、CDN 的前端性能优化</h3><p>CDN 的使用，经常来存放静态资源，原因有以下几个：</p><ul><li>存放静态的资源（CSS、JS、图片等），而不是动态生成的。 —— 动态生成的页面需要实时的在总服务器进行计算，CDN 只相当于一个仓库。</li><li>非纯静态资源也是不能放的，因为<strong>需要服务器在页面之外作额外计算的 HTML 页面</strong>，需要一系列的认证，页面和其他之间是有关联性的。</li></ul><h3 id="四、CDN-细节优化"><a href="#四、CDN-细节优化" class="headerlink" title="四、CDN 细节优化"></a>四、CDN 细节优化</h3><p>如何优化 CDN 也是一个技术难题，因为往往 CDN 服务器的选取和性能优化、结点选取有很大关系。</p><p>往往我们选择 CDN 和 主服务器是在不同域名下的。</p><p>因为同一域名会携带 COOKIE，尽管是不必要的请求，也会带着 Cookie 跑，如果这个网站足够的庞大，流量足够的多，对网站的性能大打折扣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之CDN的缓存与回源机制。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【图片性能优化】</title>
    <link href="http://yoursite.com/2019/12/18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E5%9B%BE%E7%89%87%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/18/前端性能优化与原理实践之【图片性能优化】/</id>
    <published>2019-12-18T02:28:24.595Z</published>
    <updated>2019-12-20T05:53:21.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网络篇：对图片的性能优化！</p><a id="more"></a><h3 id="一、图片优化"><a href="#一、图片优化" class="headerlink" title="一、图片优化"></a>一、图片优化</h3><p>JS 和 CSS 确实影响着图片的展示，最关键的就是对图片的展示方式影响最大。但是对于图片的显示，和图片大小有关，有时候我们做图片优化的同时，降低了图片的质量。所以我们图片优化的目标就是在<strong>图片质量和性能之间</strong>寻找一个平衡点。</p><h3 id="二、选择图片的方案"><a href="#二、选择图片的方案" class="headerlink" title="二、选择图片的方案"></a>二、选择图片的方案</h3><p>前端最常用的图片有  <code>JPEG/JPG 、PNG、WebP、Base64、SVG</code> 等。对于不同格式的图片，都有它的优势所在，也对于不同的业务场景中。</p><h4 id="2-1-JPEG-JPG"><a href="#2-1-JPEG-JPG" class="headerlink" title="2.1 JPEG/JPG"></a>2.1 JPEG/JPG</h4><p>关键字：<strong>有损压缩、体积小、加载快、不支持透明</strong></p><h5 id="JPG-优点："><a href="#JPG-优点：" class="headerlink" title="JPG 优点："></a>JPG 优点：</h5><p>虽然 JPG 是有损压缩，压缩至原来的 50% 以下，但是 JPG 仍然可以把持住 60% 的品质。此外的 JPG 的格式是以 24 位存储单个图，可呈现 1600 种颜色，对付大多数的场景完全可以，而且人的肉眼是察觉不出来的。（<strong>呈现大图保证质量，但又不会带来性能问题</strong>）</p><h5 id="JPG-缺点："><a href="#JPG-缺点：" class="headerlink" title="JPG 缺点："></a>JPG 缺点：</h5><ul><li><p>对于大图 JPG 完全没有问题，但是杜宇矢量图形和Logo等条纹、颜色对比度大的图片，图片就会变的模糊。</p></li><li><p>而且不支持透明度。</p></li></ul><h5 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h5><p>一般处理复杂的、色彩层次丰富的图片，比如：大的背景图、轮播图、Banner 图。</p><h4 id="2-2-PNG-8-和-PNG-24"><a href="#2-2-PNG-8-和-PNG-24" class="headerlink" title="2.2 PNG-8 和 PNG-24"></a>2.2 PNG-8 和 PNG-24</h4><p>对于这两种格式的图片，最好的办法就是输出图片，用肉眼进行对比，如果对图片质量要求不是太高，可以选择 PNG-8 ，因为 PNG-8 可以避免体积过大的问题，PNG 优势就是<strong>处理线条和颜色的对比度</strong>比较优秀。</p><h5 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h5><p>根据 PNG 的优势，我们用于处理一下<strong>小的 Logo、颜色对比度强烈</strong>的小图片。</p><h4 id="2-3-SVG"><a href="#2-3-SVG" class="headerlink" title="2.3 SVG"></a>2.3 SVG</h4><p>关键词：<strong>文本文件、体积小、不失真、兼容性好</strong></p><blockquote><p>SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。</p></blockquote><h5 id="SVG-优点："><a href="#SVG-优点：" class="headerlink" title="SVG 优点："></a>SVG 优点：</h5><blockquote><p>SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>   <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"文件名.svg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与 <code>PNG</code> 和 <code>JPG</code> 相比：</p><ul><li>体积更小</li><li>压缩性更强</li><li>无限放大不失真</li><li><code>SVG</code> 就是 <code>HTML</code> 文件，成为 DOM 的一部分，使用更加的灵活。</li></ul><h5 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h5><h4 id="2-4-Base64"><a href="#2-4-Base64" class="headerlink" title="2.4 Base64"></a>2.4 Base64</h4><p>关键字<strong>：文本文件、依赖编码、小图标解决方案</strong></p><blockquote><p><code>Base 64</code> 不是一种图片格式，而是一种编码方式。<code>Base64</code> 主要用于<strong>小图标</strong>解决方案。Base64 的出现为乐减少加载网页图片时对服务器的请求次数，从而优化网络请求，提高性能。一般使用  webpack 进行编码。</p></blockquote><p><strong>Base64 的优势：</strong></p><ul><li><code>Base64</code> 是图片的<code>8 bit</code>字节码编码方式，通过对图片的进行<code>Base64</code>编码，可以将编码结果写入 <code>HTML 和 CSS</code>。</li><li>减少了图片 <code>HTTP</code> 的请求次数</li><li>浏览器是可以识别<code>Base64</code>编码的，不会发起请求，而是直接将编码解析为图片。</li></ul><p><strong>应用场景：</strong></p><ul><li><p><code>Base64</code> 主要应用于小图片，比如非常小的 <code>Logo</code>、图片。</p></li><li><p>图片的实际尺寸很小（大家可以观察一下掘金页面的 <code>Base64</code> 图，几乎没有超过 2kb 的）</p></li><li>图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 <code>HTTP</code> 请求的途径，<code>Base64</code> 是雪碧图的补充）</li><li>图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）</li></ul><p><strong>PS：大图为什么不能转化为 Base64，大图的转化虽然减少了 HTTP 请求，不但整个文件的体积增加了，而且浏览器解析大图的时间效率也会增加，然而性能就会增加，得不偿失。</strong></p><h4 id="2-5-WebP"><a href="#2-5-WebP" class="headerlink" title="2.5  WebP"></a>2.5  WebP</h4><p><code>WebP</code> 旨在加快图片加载速度的图片格式，支持<strong>有损压缩和无损压缩。</strong></p><p><strong>优势：</strong></p><ul><li>和 JPEG 相比，支持细节丰富的图片。</li><li>和 PNG 相比，支持透明度。</li><li>可以显示 GIF 动态图片。</li></ul><blockquote><p>WebP 无损图像的尺寸缩小了 26％。</p><p>WebP 有损图像比同类 JPEG 图像小 25-34％。</p><p>对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。</p></blockquote><p><strong>局限性：</strong></p><ul><li><code>WebP</code> 兼容性很差，最低支持 <code>IE11</code>。</li><li><code>WebP</code> 和编码的 <code>JPG</code> 相比，占用很多的计算机资源。</li></ul><p><strong>适用条件：</strong></p><p>因为 WebP 的兼容性非常差，在 Safari  浏览器下无法显示图片的情况，我们通常做兼容性处理，通常设置两种形式的图片，在不同的浏览器中显示的图片格式也不同。</p><blockquote><p>PS：把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络篇：对图片的性能优化！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【本地储存】</title>
    <link href="http://yoursite.com/2019/12/16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/16/前端性能优化与原理实践之【本地储存】/</id>
    <published>2019-12-16T02:33:11.831Z</published>
    <updated>2019-12-18T02:28:15.301Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>存储：前端性能优化之本地储存 Cookie、Web Storage、IndexedDB！</p><a id="more"></a><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><p>因为 HTTP 是无状态的协议，所以客户端的请求，服务端返回一个响应，服务端并不会记录那个客户端发起过请求，所以要想记住客户端的请求，必须设置一个存储，所以 Cookie 诞生了。</p><h4 id="Cookie-的性能缺陷"><a href="#Cookie-的性能缺陷" class="headerlink" title="Cookie 的性能缺陷"></a>Cookie 的性能缺陷</h4><p>1、<code>Cookie</code> 存储大小：<code>Cookie</code> 是有体积上限的，它最大只能有 <code>4KB</code>。如果存储的超过 <code>4 kb</code>，就会被剪裁。</p><p>2、<code>Cookie</code> 性能浪费：每个 <code>Cookie</code> 都对应一个域名，<code>Set-Cookie: name=xiuyan; domain=xiaolu.com</code>，请求同一域名，都会带着 <code>Cookie</code>，如果 <code>Cookie</code> 过多，或多或少会带来性能问题。</p><h3 id="二、Web-Storage"><a href="#二、Web-Storage" class="headerlink" title="二、Web Storage"></a>二、Web Storage</h3><h4 id="2-1-Local-Storage-与-Session-Storage-的区别"><a href="#2-1-Local-Storage-与-Session-Storage-的区别" class="headerlink" title="2.1 Local Storage 与 Session Storage 的区别?"></a>2.1 Local Storage 与 Session Storage 的区别?</h4><ul><li><strong>生命周期：</strong><code>Local Storage</code> 是持久化的本地存储，只要不手动删除，存储的数据就不会消失；而 <code>Session Storage</code> 是临时性的本地存储，只存在于当前会话中的，一旦 <code>tab</code> 页面关闭，数据就会不存在。</li><li><strong>作用域：</strong><code>Local Storage</code>、<code>Session Storage</code> 和<code>Cookie</code>都遵循同源策略。<code>Session Storage</code> 不同，只要它们<strong>不在同一个浏览器窗口中</strong>打开，内容就无法共享。</li></ul><h4 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h4><ul><li><code>Local Storage</code>：Cookie 无法胜任的存储，都要交给它来完成，一般用于资源的持久化存储。用它来存储一些内容稳定的资源。比如，base64 的商店网站图片。</li><li><code>Session Storage</code>:   更适合用来存储生命周期和它同步的<strong>会话级别</strong>的信息。只用于本次页面会话使用。</li></ul><h3 id="三、IndexedDB"><a href="#三、IndexedDB" class="headerlink" title="三、IndexedDB"></a>三、IndexedDB</h3><blockquote><p>IndexedDB 是一个<strong>运行在浏览器上的非关系型数据库</strong>。理论上可以无限大，但是也是有限制的，可以存储字符串和二进制数据。</p></blockquote><h4 id="3-1-创建-IndexedDB"><a href="#3-1-创建-IndexedDB" class="headerlink" title="3.1 创建 IndexedDB"></a>3.1 创建 IndexedDB</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面的回调中，我们可以通过event.target.result拿到数据库实例</span></span><br><span class="line"><span class="keyword">let</span> db</span><br><span class="line"><span class="comment">// 参数1位数据库名，参数2为版本号</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">"xiaoceDB"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 使用IndexedDB失败时的监听函数</span></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'无法使用IndexedDB'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line">request.onsuccess  = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 此处就可以获取到db实例</span></span><br><span class="line">  db = event.target.result</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"你打开了IndexedDB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-创建一个表"><a href="#3-2-创建一个表" class="headerlink" title="3.2 创建一个表"></a>3.2 创建一个表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectStore</span><br><span class="line">  <span class="comment">// 如果同名表未被创建过，则新建test表</span></span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">'test'</span>)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(<span class="string">'test'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'id'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-创建事务操作数据库"><a href="#3-3-创建事务操作数据库" class="headerlink" title="3.3 创建事务操作数据库"></a>3.3 创建事务操作数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事务，指定表格名称和读写权限</span></span><br><span class="line">  <span class="keyword">const</span> transaction = db.transaction([<span class="string">"test"</span>],<span class="string">"readwrite"</span>)</span><br><span class="line">  <span class="comment">// 拿到Object Store对象</span></span><br><span class="line">  <span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">"test"</span>)</span><br><span class="line">  <span class="comment">// 向表格写入数据</span></span><br><span class="line">  objectStore.add(&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'xiuyan'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-4-监听完成操作"><a href="#3-4-监听完成操作" class="headerlink" title="3.4 监听完成操作"></a>3.4 监听完成操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作成功时的监听函数</span></span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"操作成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作失败时的监听函数</span></span><br><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"这里有一个Error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储：前端性能优化之本地储存 Cookie、Web Storage、IndexedDB！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【浏览器缓存机制与缓存策略】</title>
    <link href="http://yoursite.com/2019/12/13/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/13/前端性能优化与原理实践之【浏览器的缓存机制与缓存策略】/</id>
    <published>2019-12-13T00:57:04.944Z</published>
    <updated>2019-12-25T02:57:44.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端性能优化之浏览器缓存机制介绍与缓存策略剖析！</p><a id="more"></a><p>[TOC]</p><h3 id="一、浏览器的缓存介绍"><a href="#一、浏览器的缓存介绍" class="headerlink" title="一、浏览器的缓存介绍"></a>一、浏览器的缓存介绍</h3><p>缓存可以减少网络 IO（input/output IO数据流）消耗，提高访问速度。可通过浏览器中简单的操作，完成前端的性能优化。<strong>缓存是利用了重复在客户端和服务端两端网络通信的资源，减少了网络请求和数据处理的时间</strong>。</p><p>浏览器的缓存，主要从以下几个方面入手，按照请求资源的优先级排序如下：</p><ul><li><strong>Memory Cache</strong></li><li><strong>Service Worker Cache</strong></li><li><strong>HTTP Cache</strong></li><li><strong>Push Cache</strong></li></ul><h3 id="二、HTTP-缓存机制"><a href="#二、HTTP-缓存机制" class="headerlink" title="二、HTTP 缓存机制"></a>二、HTTP 缓存机制</h3><p>HTTP 缓存是日常开发最常用到的缓存机制，它分为<strong>强缓存</strong>和<strong>协商缓存</strong>。强缓存的优先级高，只有当强缓存失败的情况下，才会有协商缓存。</p><h4 id="2-1-强缓存"><a href="#2-1-强缓存" class="headerlink" title="2.1 强缓存"></a>2.1 强缓存</h4><p>强缓存是通过 HTTP  头部的 <code>Expires</code>和 <code>Cache-Control</code> 来控制的。强缓存中，当请求再次请求，浏览器就会检查请求头部的两个字段是否命中“强缓存”，如果有的话，直接在缓存中取出，不在进行网络请求。（下图为强缓存的请求）</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6a683fc021e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="2-2-强缓存：expire-到-cache-control"><a href="#2-2-强缓存：expire-到-cache-control" class="headerlink" title="2.2 强缓存：expire 到 cache-control"></a>2.2 强缓存：expire 到 cache-control</h4><h4 id="1、exprie"><a href="#1、exprie" class="headerlink" title="1、exprie"></a>1、<code>exprie</code></h4><p>当服务器返回响应的时候，会在 HTTP 的响应头部设置资源的过期时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires: Wed, 11 Sep 2019 16:12:18 GMT</span><br></pre></td></tr></table></figure><p>当我们浏览器再次发起请求的时候，就会拿本地时间和这个过期时间作对比，如果小于过期时间，则在本地缓存中提取资源。</p><blockquote><p><strong>局限性：</strong>但是存在一个问题就是，本地的时间和服务器的时间不对应，而且本地的时间可以修改。</p></blockquote><h4 id="2、Cache-Control"><a href="#2、Cache-Control" class="headerlink" title="2、Cache-Control"></a>2、<code>Cache-Control</code></h4><p>到了 HTTP1.1 新增加了 <code>Cache-Control</code> 字段，代替 <code>exprie</code> 的任务，<code>exprie</code> 能完成的 <code>Cache-Control</code> 都能完成。但是 <code>Cache-Control</code> 有一个好处如下：</p><p> 设置一个过期时间多少秒，资源会在这个秒数后消失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: max-age=31536000</span><br></pre></td></tr></table></figure><p><strong>总结：Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准</strong></p><h4 id="3、max-age-和-s-maxage"><a href="#3、max-age-和-s-maxage" class="headerlink" title="3、max-age 和 s-maxage"></a>3、<code>max-age</code> 和 <code>s-maxage</code></h4><p>但在依赖各种<strong>代理</strong>的大型架构中，我们不得不考虑<strong>代理服务器</strong>的缓存问题。<code>s-maxage</code> 就是用于表示 <code>cache</code>服务器上（比如 <code>cache CDN</code>）的缓存的有效时间的，并只对 <code>public</code> 缓存有效。</p><p><strong>s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容</strong></p><blockquote><p><strong>注意：s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。</strong></p></blockquote><h5 id="public-与-private"><a href="#public-与-private" class="headerlink" title="public 与 private"></a><code>public</code> 与 <code>private</code></h5><blockquote><p>两者的意思就是对资源<strong>是否缓存</strong>进行控制的。</p></blockquote><p>如果我们为资源设置了 <code>public</code>，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 <code>private</code>，则该资源只能被浏览器缓存，private 为<strong>默认值</strong>。</p><h5 id="no-store-与-no-cache"><a href="#no-store-与-no-cache" class="headerlink" title="no-store 与 no-cache"></a><code>no-store</code> 与 <code>no-cache</code></h5><ul><li><code>no-store</code>：不询问任何缓存，直接进行资源请求。</li><li><code>no-cache</code>：每次请求不会询问浏览器是否有缓存时间，而是直接向服务器确认缓存的资源是否过期。</li></ul><h4 id="4、协商缓存"><a href="#4、协商缓存" class="headerlink" title="4、协商缓存"></a>4、协商缓存</h4><blockquote><p>是<strong>浏览器直接向服务器询问缓存</strong>，然后得到服务器的响应，进而判断从本地提取资源还是再次请求资源。最常见的就是 <strong>304 状态</strong>。</p></blockquote><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a><code>Last-Modified</code></h4><p>我们第一次请求过资源后，这个字段的时间戳就会随着 <code>response Header</code> 响应返回，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT</span><br></pre></td></tr></table></figure><p>然后浏览器再次发起请求，就会携带这个时间戳，字段 <code>If-Modified-Since:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT</span><br></pre></td></tr></table></figure><p>服务器接收到之后，取出时间戳，判断与上次该资源修改的时间对比，如果资源改未改动，则返回 <code>304</code> 状态。<code>Response Headers</code> 不会再添加 <code>Last-Modified</code>字段。</p><h4 id="Last-Modified-局限性"><a href="#Last-Modified-局限性" class="headerlink" title="Last-Modified 局限性"></a><code>Last-Modified</code> 局限性</h4><p>对于一些特殊的应用场景 <code>Last-Modified</code> 有局限性：</p><ul><li>编辑文件，但是没有改动文件，服务器认为我们变动了，所以会更改最后修改的时间，导致浏览器重新发起不必要的请求。</li><li>在 100ms 发起改动，但是时间差的原因，感应不到 1 秒内的变动，所以改请求时却没有发起请求。</li></ul><blockquote><p>其实原因就是不能感应到文件内容的变化导致了上边的局限性。我们会使用 Etag 来进行代替。</p></blockquote><h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a><code>Etag</code></h4><p>Etag 是由服务器为每个资源生成的唯一的<strong>标识字符串</strong>，是由文件的编码组成的，一旦文件改变，该字符串就不同，所以 Etag 可以感应到文件的改变。</p><p>第一次请求返回的响应会在头部字段加上 Etag，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure><p>然后浏览器再次发起请求，加上一个字段，服务器接收到然后作比对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure><p><strong>弊端：</strong> 生成字符串需要一定的时间，消耗服务器的资源，所以两者要在实际中进行权衡。两者同时存在时，后者优先级更高。</p><h3 id="三、HTTP-缓存决策流程"><a href="#三、HTTP-缓存决策流程" class="headerlink" title="三、HTTP 缓存决策流程"></a>三、HTTP 缓存决策流程</h3><blockquote><p>在日常开发中，使用到的 HTTP 缓存解决图。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f701820fafcf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；</li><li>否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；</li><li>否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</li></ul><h3 id="四、MemoryCache-——-内存缓存"><a href="#四、MemoryCache-——-内存缓存" class="headerlink" title="四、MemoryCache —— 内存缓存"></a>四、MemoryCache —— 内存缓存</h3><blockquote><p>它是一种内存中的缓存，优先级最高的，响应速度最快，但是也是存储的时间最短的，一旦浏览器的 tab 关闭，缓存中的数据就不复存在了。</p></blockquote><h4 id="4-1-什么的资源会被存进去"><a href="#4-1-什么的资源会被存进去" class="headerlink" title="4.1 什么的资源会被存进去"></a>4.1 什么的资源会被存进去</h4><p>并没有硬性的规定，但是根据浏览器的选择，比较小的文件优先被送内存缓存中去——这样比较节约。</p><ul><li><code>Base64</code> 格式的图片，几乎永远可以被塞进 <code>memory cache</code>;</li><li>体积不大的 <code>JS、CSS</code> 文件，也有较大地被写入内存的几率;</li></ul><h3 id="五、Service-Worker-Cache"><a href="#五、Service-Worker-Cache" class="headerlink" title="五、Service Worker Cache"></a>五、Service Worker Cache</h3><blockquote><p><code>Service Worker</code> 是一种独立于主线程之外的 <code>Javascript</code> 线程。它脱离于浏览器窗体，因此无法直接访问 <code>DOM</code>。可以实现<strong>离线缓存、消息推送和网络代理</strong>等功能</p></blockquote><h4 id="5-1-Service-Worker-的生命周期"><a href="#5-1-Service-Worker-的生命周期" class="headerlink" title="5.1 Service Worker 的生命周期"></a>5.1 Service Worker 的生命周期</h4><p>Service Worker 的生命周期包括三个阶段：（要想停止，必须主动进行停止）</p><ul><li><p><strong>install</strong></p></li><li><p><strong>active</strong></p></li><li><strong>working</strong> </li></ul><blockquote><p><strong>PS：</strong>Server Worker 对协议是有要求的，必须以 https 协议为前提。</p></blockquote><h4 id="5-2-Push-Cache"><a href="#5-2-Push-Cache" class="headerlink" title="5.2 Push Cache"></a>5.2 Push Cache</h4><p>Chrome 工程师 Jake Archibald 的这篇 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a>。</p><blockquote><p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存，</p></blockquote><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li><li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之浏览器缓存机制介绍与缓存策略剖析！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化与原理实践之【webpack性能与Gzip原理】</title>
    <link href="http://yoursite.com/2019/12/11/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5%E4%B9%8B%E3%80%90webpack%E6%80%A7%E8%83%BD%E4%B8%8EGzip%E5%8E%9F%E7%90%86%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/11/前端性能优化与原理实践之【webpack性能与Gzip原理】/</id>
    <published>2019-12-11T06:26:20.764Z</published>
    <updated>2019-12-23T01:59:59.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>【网络篇】前端性能优化之 webpack 与 Gzip 原理！</p><a id="more"></a><h3 id="一、前端的性能优化思路"><a href="#一、前端的性能优化思路" class="headerlink" title="一、前端的性能优化思路"></a>一、前端的性能优化思路</h3><p>从输入 URL 到页面加载完成，这个过程进行不断的优化、反复的琢磨， 把优化做到极致：</p><ul><li>DNS 解析；</li><li>TCP 连接；</li><li>HTTP 请求抛出；</li><li>服务端处理请求，HTTP 响应返回；</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f5358f63c0f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="二、网络篇：webpack性能与Gzip原理"><a href="#二、网络篇：webpack性能与Gzip原理" class="headerlink" title="二、网络篇：webpack性能与Gzip原理"></a>二、网络篇：webpack性能与Gzip原理</h3><p>这输入 URL 到显示出页面这个过程中，网络部分有一下三个：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li><strong>HTTP 请求/响应（网络优化的核心）</strong></li></ul><h4 id="2-1-HTTP-优化"><a href="#2-1-HTTP-优化" class="headerlink" title="2.1 HTTP 优化"></a>2.1 HTTP 优化</h4><p>我们主要在 HTTP 请求有两个方面可以优化:</p><ul><li>减少资源的请求次数</li><li>减少单次请求的时间</li></ul><blockquote><p>要想减少资源的请求次数，就把资源进行<strong>合并</strong>；要想减少单次请求的时间，就要<strong>压缩</strong>请求的资源。这些都要交给 webpack 去处理。</p></blockquote><h4 id="2-2-webpack-的性能瓶颈"><a href="#2-2-webpack-的性能瓶颈" class="headerlink" title="2.2 webpack 的性能瓶颈"></a>2.2 webpack 的性能瓶颈</h4><p>但是 webpack 也存在性能瓶颈，所以我们要对 webpack 进行优化，优化方向主要有两个：</p><ul><li><strong>webpack 的构建过程消费时间长</strong></li><li><strong>webpack 打包后的体积还是太大</strong></li></ul><h4 id="2-3-webpack-的优化"><a href="#2-3-webpack-的优化" class="headerlink" title="2.3 webpack 的优化"></a>2.3 webpack 的优化</h4><blockquote><p>这一篇基本都是对 webpack 工具的使用优化，因为工具不断的进行迭代更新，所以并不作为重点进行优化，具体到实际项目中知道什么情况下要使用什么方法。工具永远在迭代，唯有掌握核心思想，才可以真正做到举一反三</p></blockquote><h4 id="1、提速构建过程"><a href="#1、提速构建过程" class="headerlink" title="1、提速构建过程"></a>1、提速构建过程</h4><ul><li><strong>不让 loader 做太多事情</strong></li><li><strong>不让第三方库参与构建</strong></li><li><strong>将 loader 有单进程转化为多进程</strong></li></ul><h4 id="1-1-不让-loader-做太多事情："><a href="#1-1-不让-loader-做太多事情：" class="headerlink" title="1.1 不让 loader 做太多事情："></a><strong>1.1 不让 loader 做太多事情：</strong></h4><p>loader 很强大，同时又很慢，所以优化的最佳方式就是使用 include 或 exclude 来让 loader 转义不必要的包，比如依赖包 node_modules。这样，帮我们规避了对庞大的 node_modules 文件夹或者 bower_components 文件夹的处理。—— 但是优化是有限的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启文件缓存，将转译的文件结果缓存到文件系统中，这个过程<strong>性能提升了 2 倍</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h4 id="1-2-不让第三方库参与构建："><a href="#1-2-不让第三方库参与构建：" class="headerlink" title="1.2 不让第三方库参与构建："></a><strong>1.2 不让第三方库参与构建：</strong></h4><p>除了 <code>loader</code> 之外，还有 <code>Plugin</code> 插件库，也是非常庞大的，比如：<code>node_modules</code>。</p><p>经常处理第三方库的方法：</p><ul><li><strong>Externals：</strong>一些情况下会引发重复打包的问题；</li><li><strong>CommonsChunkPlugin：</strong>每次构建时都会重新构建一次 vendor;</li></ul><h5 id="最佳方案：处于效率考虑，使用-DllPlugin："><a href="#最佳方案：处于效率考虑，使用-DllPlugin：" class="headerlink" title="最佳方案：处于效率考虑，使用 DllPlugin："></a>最佳方案：处于效率考虑，使用 DllPlugin：</h5><blockquote><p>DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。<strong>这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包</strong>。</p></blockquote><p>使用方法：</p><ul><li>基于 dll 专属的配置文件，打包 dll 库；</li><li>基于 webpack.config.js 文件，打包业务代码。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      <span class="comment">// 依赖的库数组</span></span><br><span class="line">      vendor: [</span><br><span class="line">        <span class="string">'prop-types'</span>,</span><br><span class="line">        <span class="string">'babel-polyfill'</span>,</span><br><span class="line">        <span class="string">'react'</span>,</span><br><span class="line">        <span class="string">'react-dom'</span>,</span><br><span class="line">        <span class="string">'react-router-dom'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      filename: <span class="string">'[name].js'</span>,</span><br><span class="line">      library: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">        <span class="comment">// DllPlugin的name属性需要和libary保持一致</span></span><br><span class="line">        name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">        <span class="comment">// context需要和webpack.config.js保持一致</span></span><br><span class="line">        context: __dirname,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vendor-manifest.json // 依赖文件</span><br><span class="line">vendor.js // 第三方库</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 里针对 dll 稍作配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 编译入口</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 目标文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist/'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// dll相关配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      <span class="comment">// manifest就是我们第一步中打包出来的json文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Happypack——将-loader-由单进程转为多进程"><a href="#1-3-Happypack——将-loader-由单进程转为多进程" class="headerlink" title="1.3 Happypack——将 loader 由单进程转为多进程"></a><strong>1.3 Happypack——将 loader 由单进程转为多进程</strong></h4><blockquote><p>webpack 是单线程的，再多的任务只能排序处理。但是我们的 CPU 是多核的，Happypack 利用 CPU 多核的优势，把任务分发给子线程并发去执行，提高了打包的效率。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 手动创建进程池</span></span><br><span class="line"><span class="keyword">const</span> happyThreadPool =  HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 问号后面的查询参数指定了处理这类文件的 HappyPack 实例的名字</span></span><br><span class="line">        loader: <span class="string">'happypack/loader?id=happyBabel'</span>,</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应</span></span><br><span class="line">      id: <span class="string">'happyBabel'</span>,</span><br><span class="line">      <span class="comment">// 指定进程池</span></span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">      loaders: [<span class="string">'babel-loader?cacheDirectory'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、构建结果体积压缩"><a href="#2、构建结果体积压缩" class="headerlink" title="2、构建结果体积压缩"></a>2、构建结果体积压缩</h4><blockquote><p>通过可视化打包工具查看各个模块打包后的大小，<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>。使用方式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1拆分资源"><a href="#2-1拆分资源" class="headerlink" title="2.1拆分资源"></a><strong>2.1拆分资源</strong></h4><blockquote><p> DllPlugin。</p></blockquote><h4 id="2-2-删除冗余的代码"><a href="#2-2-删除冗余的代码" class="headerlink" title="2.2 删除冗余的代码"></a><strong>2.2 删除冗余的代码</strong></h4><blockquote><p>使用 Tree-Shaking 来检测没有使用的模块，然后打包时自动会去除。</p></blockquote><p>Tree-Shaking 只针对于模块级别的，如下边，只引入，并没有使用，所以在编译的时候被感知，打包的时候会被直接删除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const page1 = xxx</span><br><span class="line"></span><br><span class="line">export const page2 = xxx</span><br></pre></td></tr></table></figure><p>如果针对于更细节的代码冗余，需要在整合到 CSS 和 JS 时候进行分析。下面是在压缩时候，对冗余代码（注释、console等）的自动化删除。看一下 UglifyJsPlugin 插件压缩的时候(webpack3)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> plugins: [</span><br><span class="line">   <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">     <span class="comment">// 允许并发</span></span><br><span class="line">     parallel: <span class="literal">true</span>,</span><br><span class="line">     <span class="comment">// 开启缓存</span></span><br><span class="line">     cache: <span class="literal">true</span>,</span><br><span class="line">     compress: &#123;</span><br><span class="line">       <span class="comment">// 删除所有的console语句    </span></span><br><span class="line">       drop_console: <span class="literal">true</span>,</span><br><span class="line">       <span class="comment">// 把使用多次的静态值自动定义为变量</span></span><br><span class="line">       reduce_vars: <span class="literal">true</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     output: &#123;</span><br><span class="line">       <span class="comment">// 不保留注释</span></span><br><span class="line">       comment: <span class="literal">false</span>,</span><br><span class="line">       <span class="comment">// 使输出的代码尽可能紧凑</span></span><br><span class="line">       beautify: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack4 使用  <code>uglifyjs-webpack-plugin</code> 对代码进行压缩。</p><h4 id="2-3-按需加载"><a href="#2-3-按需加载" class="headerlink" title="2.3 按需加载"></a><strong>2.3 按需加载</strong></h4><p>假如 React 使用单页应用，就会用 React-Router 来控制，一共十个页面，而且每个页面非常复杂，如果打包同时加载的时候，就会出现页面卡死状态，所以我们采用的方案就是用户需要显示哪一个就加载哪一个。</p><ul><li><strong>一次不加载完所有的文件内容，只加载此刻需要用到的那部分（会提前做拆分）</strong></li><li><strong>当需要更多内容时，再对用到的内容进行即时加载</strong></li></ul><p><strong>正常的路由组件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BugComponent <span class="keyword">from</span> <span class="string">'../pages/BugComponent'</span></span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">"/bug"</span> component=&#123;BugComponent&#125;&gt;</span><br></pre></td></tr></table></figure><p><strong>webpack 的配置文件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/../dist'</span>),</span><br><span class="line">    filename: <span class="string">'app.js'</span>,</span><br><span class="line">    publicPath: defaultSettings.publicPath,</span><br><span class="line">    <span class="comment">// 指定 chunkFilename</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>路由处理：</strong></p><p>这是一个异步的方法，<code>webpack</code> 在打包时，<code>BugComponent</code> 会被单独打成一个文件，只有在我们跳转 bug 这个路由的时候，这个异步方法的回调才会生效，才会真正地去获取 <code>BugComponent</code> 的内容。这就是按需加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onst getComponent =&gt; (location, cb) &#123;</span><br><span class="line">  require.ensure([], (require) =&gt; &#123;</span><br><span class="line">    cb(null, require(&apos;../pages/BugComponent&apos;).default)</span><br><span class="line">  &#125;, &apos;bug&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/bug&quot; getComponent=&#123;getComponent&#125;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>PS: 按需加载可以继续细化到每个更小的组件，或者某个功能点。</p></blockquote><p>没错，在 React-Router4 中，我们确实是用 Code-Splitting 替换掉了楼上这个操作。而且如果有使用过 React-Router4 实现过路由级别的按需加载的同学，可能会对 React-Router4 里用到的一个叫“Bundle-Loader”的东西印象深刻。我想很多同学读到按需加载这里，心里的预期或许都是时下大热的 Code-Splitting，而非我呈现出来的这段看似“陈旧”的代码。</p><p>但是，如果大家稍微留个心眼，去看一下 Bundle Loader 并不长的源代码的话，你会发现它竟然还是使用 require.ensure 来实现的——这也是我要把 require.ensure 单独拎出来的重要原因。所谓按需加载，根本上就是在正确的时机去触发相应的回调。理解了这个 require.ensure 的玩法，大家甚至可以结合业务自己去修改一个按需加载模块来用。</p><h3 id="三、HTTP-Gzip-压缩算法"><a href="#三、HTTP-Gzip-压缩算法" class="headerlink" title="三、HTTP Gzip 压缩算法"></a>三、HTTP Gzip 压缩算法</h3><blockquote><p><strong>HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程</strong>,一个简单又好用的 HTTP 压缩操作：开启 Gzip。</p></blockquote><p>只需在 HTTP 的头部，加上如下属性；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept-encoding:gzip</span><br></pre></td></tr></table></figure><h4 id="3-1-Gzip-的原理"><a href="#3-1-Gzip-的原理" class="headerlink" title="3.1 Gzip 的原理"></a>3.1 Gzip 的原理</h4><p>在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，<strong>文件中代码的重复率越高，那么压缩的效率就越高</strong>，使用 Gzip 的收益也就越大。反之亦然。</p><h4 id="3-2-什么情况下使用-Gzip"><a href="#3-2-什么情况下使用-Gzip" class="headerlink" title="3.2 什么情况下使用 Gzip"></a>3.2 什么情况下使用 Gzip</h4><p>通常很小的文件，不值得用 <code>Gzip</code>，压缩解压的时间都超过的传输的时间。如果用到比较大的项目文件，使用 <code>Gzip</code> 压缩，完全可以忽略压缩解压的过程。</p><h4 id="3-3-Gzip-的效率"><a href="#3-3-Gzip-的效率" class="headerlink" title="3.3 Gzip 的效率"></a>3.3 Gzip 的效率</h4><ul><li>优点：压缩后<strong>通常</strong>能帮我们减少<strong>响应 70% 左右的大小</strong>。</li><li>缺点：<code>Gzip</code>并不保证针对每一个文件的压缩都会使其变小。</li></ul><h4 id="3-4-权衡压缩负载"><a href="#3-4-权衡压缩负载" class="headerlink" title="3.4 权衡压缩负载"></a>3.4 权衡压缩负载</h4><p> <strong>Gzip 主要用于服务器端的操作，从而节省了传输的开销。</strong>但是服务器 CPU 承担的压力很大的时候，就会出现服务器崩溃或者压缩很慢，所以前后台要进行权衡，有必要的时候对后台的服务器进行分压，使用 webpack 中的 Gzip 进行压缩。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【网络篇】前端性能优化之 webpack 与 Gzip 原理！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式之【迭代器模式】</title>
    <link href="http://yoursite.com/2019/12/10/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/10/前端设计模式之【迭代器模式】/</id>
    <published>2019-12-10T03:13:18.625Z</published>
    <updated>2019-12-10T05:35:54.454Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式之迭代器模式！</p><a id="more"></a><h4 id="一、迭代器模式"><a href="#一、迭代器模式" class="headerlink" title="一、迭代器模式"></a>一、迭代器模式</h4><blockquote><p>迭代器模式主要的目的就是——遍历。</p></blockquote><p>我们一般通过 forEach 来遍历数组的数据，但是对于一些情况没有该遍历方法，比如在 NodeList 中，遍历所有的节点，并不能遍历出来。因为 NodeList 是一个类数组的对象，并没有提供任何的遍历方法。</p><p>那么问题来了，如果想让想让这种类数组的像数组一样提供遍历。那么迭代器就是解决的这种问题，<strong>我们不用关心数据集合的内部实现结构</strong>。都能通过一个迭代器遍历出来，这就是迭代器模式。</p><h4 id="二、jQuery-中的迭代器模式"><a href="#二、jQuery-中的迭代器模式" class="headerlink" title="二、jQuery 中的迭代器模式"></a>二、jQuery 中的迭代器模式</h4><p>jQuery 中的遍历器 each 方法就是一个很好的例子，它的设计就是封装了一套规则，可以遍历不同的集合对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> aNodes = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">$.each(arr, <span class="function"><span class="keyword">function</span> (<span class="params">index, item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`数组的第<span class="subst">$&#123;index&#125;</span>个元素是<span class="subst">$&#123;item&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.each(aNodes, <span class="function"><span class="keyword">function</span> (<span class="params">index, aNode</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`DOM类数组的第<span class="subst">$&#123;index&#125;</span>个元素是<span class="subst">$&#123;aNode.innerText&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jQNodes = $(<span class="string">'a'</span>)</span><br><span class="line">$.each(jQNodes, <span class="function"><span class="keyword">function</span> (<span class="params">index, aNode</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`jQuery集合的第<span class="subst">$&#123;index&#125;</span>个元素是<span class="subst">$&#123;aNode.innerText&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="三、ES6-中的迭代器"><a href="#三、ES6-中的迭代器" class="headerlink" title="三、ES6 中的迭代器"></a>三、ES6 中的迭代器</h4><p>我们知道迭代器模式的作用，到了 <code>ES6</code> 中，又扩展了很多的集合对象，<code>Set 、Map</code> 等，他们都有自己内部的实现方式，我们还是想要新的一套规则去设计它。ES6 在推出新数据结构的同时也推出了一套<strong>统一的接口机制</strong>——迭代器（<code>Iterator</code>）</p><p><code>ES6</code> 规定，每个迭代器对象都要有一个 <code>Symbol.iterator</code> 属性，该属性对应的方法本质上是当前数据结构默认的迭代器生成函数，可以被遍历，被 <code>for...of...</code> 循环和迭代器的 <code>next</code> 方法遍历。 事实上，<code>for...of...</code> 的背后正是对<code>next</code>方法的反复调用。</p><h5 id="3-1-iterator-的内部调用："><a href="#3-1-iterator-的内部调用：" class="headerlink" title="3.1 iterator 的内部调用："></a>3.1 iterator 的内部调用：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 通过调用iterator，拿到迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对迭代器对象执行next，就能逐个访问集合的成员</span></span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure><h5 id="3-2-for—-of—-借助-iterator-实现"><a href="#3-2-for—-of—-借助-iterator-实现" class="headerlink" title="3.2 for—-of— 借助 iterator 实现"></a>3.2 for—-of— 借助 iterator 实现</h5><blockquote><p>for…of… 其实就是 iterator 循环调用换了种写法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用iterator，拿到迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个迭代结果</span></span><br><span class="line"><span class="keyword">let</span> now = &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环往外迭代成员</span></span><br><span class="line"><span class="keyword">while</span>(!now.done) &#123;</span><br><span class="line">    now = iterator.next()</span><br><span class="line">    <span class="keyword">if</span>(!now.done) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`现在遍历到了<span class="subst">$&#123;now.value&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h5 id="3-3-生成器函数"><a href="#3-3-生成器函数" class="headerlink" title="3.3 生成器函数"></a>3.3 生成器函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个迭代器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">iteratorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'1号选手'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'2号选手'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'3号选手'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator()</span><br><span class="line"></span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure><h5 id="3-4-用-ES5-实现一个生成器"><a href="#3-4-用-ES5-实现一个生成器" class="headerlink" title="3.4 用 ES5 实现一个生成器"></a>3.4 用 ES5 实现一个生成器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义生成器函数，入参是任意集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorGenerator</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// idx记录当前访问的索引</span></span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="comment">// len记录传入集合的长度</span></span><br><span class="line">    <span class="keyword">var</span> len = list.length</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个迭代器对象，迭代器对象可以调用 next 方法进行执行（闭包）</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义next方法</span></span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果索引还没有超出集合长度，done为false</span></span><br><span class="line">            <span class="keyword">var</span> done = idx &gt;= len</span><br><span class="line">            <span class="comment">// 如果done为false，则可以继续取值</span></span><br><span class="line">            <span class="keyword">var</span> value = !done ? list[idx++] : <span class="literal">undefined</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前值与遍历是否完毕（done）返回</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = iteratorGenerator([<span class="string">'1号选手'</span>, <span class="string">'2号选手'</span>, <span class="string">'3号选手'</span>])</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式之迭代器模式！&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【正则表达式】</title>
    <link href="http://yoursite.com/2019/12/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/10/前端进阶深入系列之【正则表达式】/</id>
    <published>2019-12-10T00:57:47.927Z</published>
    <updated>2019-12-10T02:55:28.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>正则表达式。</p><a id="more"></a><h3 id="一、什么是正则表达式"><a href="#一、什么是正则表达式" class="headerlink" title="一、什么是正则表达式"></a>一、什么是正则表达式</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><h4 id="1-2-精准匹配"><a href="#1-2-精准匹配" class="headerlink" title="1.2 精准匹配"></a>1.2 精准匹配</h4><blockquote><p>输入的是什么，就匹配什么。</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">7</span>/g</span><br></pre></td></tr></table></figure><p>匹配文本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配数：4 个 7 </span></span><br><span class="line"><span class="number">707</span><span class="number">-827</span><span class="number">-7019</span></span><br></pre></td></tr></table></figure><h4 id="1-3-字符组匹配数字"><a href="#1-3-字符组匹配数字" class="headerlink" title="1.3 字符组匹配数字"></a>1.3 字符组匹配数字</h4><blockquote><p>【】是正则表达式中的元字符，方括号不参与匹配。</p></blockquote><p>【0-9】在正则表达式中叫做字符组，也叫字符集。主要用来限定匹配的字符集，如【12356】，或者【0-9】。</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[0-9]/g</span><br></pre></td></tr></table></figure><p>匹配文本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配文本中的所有数字（除 - 外的数字）</span></span><br><span class="line"><span class="number">707</span><span class="number">-827</span><span class="number">-7019</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配上述的电话字符串</span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]-[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]-[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]</span><br></pre></td></tr></table></figure><h4 id="1-4-字符组简写式"><a href="#1-4-字符组简写式" class="headerlink" title="1.4 字符组简写式"></a>1.4 字符组简写式</h4><blockquote><p>之前匹配数字使用到的 【0-9】字符组，我们也可以使用简式，照样可以进行数字的匹配，如：\d 就可以匹配所有的数字。我们称这种形式叫做字符简写式，也叫转义字符。</p></blockquote><ul><li>“[]” : 字符分组</li><li>“\d”      : 匹配数字</li><li>“\D”      : 匹配非数字</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配上述的字符串</span></span><br><span class="line">/\d\d\d-\d\d\d-\d\d\d\d/g </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 \D 代替非数字字符</span></span><br><span class="line">/\d\d\d\D\d\d\d\D\d\d\d\d/g</span><br></pre></td></tr></table></figure><h4 id="匹配非数字字符：-D"><a href="#匹配非数字字符：-D" class="headerlink" title="匹配非数字字符：(\D)"></a>匹配非数字字符：(\D)</h4><h4 id="1-5-匹配任意字符（-）"><a href="#1-5-匹配任意字符（-）" class="headerlink" title="1.5 匹配任意字符（.）"></a>1.5 匹配任意字符（.）</h4><blockquote><p>英文 . 号是一个<strong>通配符</strong>，可以匹配任意字符（某些情况不能匹配行起始符）</p></blockquote><ul><li>“.” : 匹配任意字符。</li></ul><p>我们还可以用（.） 来匹配任意的连字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d\d\d.\d\d\d.\d\d\d\d/g</span><br></pre></td></tr></table></figure><p>同时可以匹配的文本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">707</span>%<span class="number">827</span>%<span class="number">7019</span></span><br><span class="line"><span class="number">707</span>|<span class="number">827</span>|<span class="number">7019</span></span><br></pre></td></tr></table></figure><h4 id="1-6-捕获分组和后向引用"><a href="#1-6-捕获分组和后向引用" class="headerlink" title="1.6 捕获分组和后向引用"></a>1.6 捕获分组和后向引用</h4><ul><li>“()” : 为捕获分组。匹配括号内的内容。</li></ul><h4 id="1-7-使用量词"><a href="#1-7-使用量词" class="headerlink" title="1.7 使用量词"></a>1.7 使用量词</h4><blockquote><p>使用另外一种语法来匹配电话号码。{} 花括号就是一个量词，里边用来写匹配的次数。同时 ？ 号也是一个量词。</p></blockquote><p>PS：下面的正则表示的是都紧跟匹配的字符后生效。</p><ul><li>“{} “:  括号内填匹配的次数，可以是多个如：{2,3} 两次或三次;</li><li>“?”  : 表示可选可不选;</li><li>“+” : 表示一个或多个;</li><li>“*” : 零个或多个;</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续匹配上述的电话号</span></span><br><span class="line">\d&#123;<span class="number">3</span>&#125;-?\d&#123;<span class="number">3</span>&#125;-?\d&#123;<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>最简洁的匹配电话号码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版（但是不能正确匹配） 因为前两个分隔符数字可以是三位和四位—— 我们要控制前两组为三位</span></span><br><span class="line">(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-?)+</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进后的正则</span></span><br><span class="line">(\d&#123;<span class="number">3</span>&#125;-?)&#123;<span class="number">2</span>&#125;\d&#123;<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="1-8-括选文字符"><a href="#1-8-括选文字符" class="headerlink" title="1.8 括选文字符"></a>1.8 括选文字符</h4><blockquote><p>例子：(707)-827-7019 括号内的区号可选可不选。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\(\d&#123;<span class="number">3</span>&#125;\)|^\d&#123;<span class="number">3</span>&#125;[.-]?)?\d&#123;<span class="number">3</span>&#125;[.-]?\d&#123;<span class="number">4</span>&#125;$</span><br></pre></td></tr></table></figure><ul><li>“|” ： 表示选择。也就是从多个选项中选择一个。</li><li>“^”  : 脱字符，表示会出现在第一行的位置。</li><li>“$” ：美元匹配代表匹配行的结束位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(123)827-7019</span><br><span class="line">827-7019</span><br><span class="line">123-827-7019</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式之【观察者】</title>
    <link href="http://yoursite.com/2019/12/06/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/06/前端设计模式之【观察者模式】/</id>
    <published>2019-12-06T05:21:31.223Z</published>
    <updated>2019-12-09T08:45:54.117Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式之观察者模式！</p><a id="more"></a><h3 id="一、什么是观察者模式——发布订阅者模式？"><a href="#一、什么是观察者模式——发布订阅者模式？" class="headerlink" title="一、什么是观察者模式——发布订阅者模式？"></a>一、什么是观察者模式——发布订阅者模式？</h3><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察对象同时监听某一目标对象，当这一个对象的状态发生改变时，会通知所有的观察者对象，它们会自动更新。</p></blockquote><p>发布订阅者模式分为两种角色，分为发布者和订阅者。首先创建一个发布者，然后关联订阅者，发布者发送通知，订阅者就可以得到相应的通知。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/5/169ed4923a4f51b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="二、发布者"><a href="#二、发布者" class="headerlink" title="二、发布者"></a>二、发布者</h3><p>用面向对象的思想来说，发布者和订阅者就是两个类。</p><p>发布者的功能有以下几个：</p><ul><li>增加/移除订阅者</li><li>通知订阅者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义发布者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = []</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Publisher created'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加订阅者</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Publisher.add invoked'</span>)</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除订阅者</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Publisher.remove invoked'</span>)</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.splice(i, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有订阅者</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Publisher.notify invoked'</span>)</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.update(<span class="keyword">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、订阅者"><a href="#三、订阅者" class="headerlink" title="三、订阅者"></a>三、订阅者</h3><p>订阅者比较被动，被通知和被执行。</p><p>订阅者的功能如下：</p><ul><li>收到通知会更新响应的视图（任务）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义订阅者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Observer created'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Observer.update invoked'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h3><p>在实际的业务开发中，我们所有的定制化的发布者/订阅者逻辑都可以基于这两个基本类来改写。比如我们可以通过拓展发布者类，来使所有的订阅者来<strong>监听某个特定状态的变化</strong>。</p><p>发布者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个具体的需求文档（prd）发布类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrdPublisher</span> <span class="keyword">extends</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.prdState = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 订阅者聚集地</span></span><br><span class="line">        <span class="keyword">this</span>.observers = []</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'PrdPublisher created'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看当前的状态</span></span><br><span class="line">    getState() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'PrdPublisher.getState invoked'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prdState</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法用于改变prdState的值</span></span><br><span class="line">    setState(state) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'PrdPublisher.setState invoked'</span>)</span><br><span class="line">        <span class="comment">// prd的值发生改变</span></span><br><span class="line">        <span class="keyword">this</span>.prdState = state</span><br><span class="line">        <span class="comment">// 需求文档变更，立刻通知所有开发者</span></span><br><span class="line">        <span class="keyword">this</span>.notify()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅者:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeveloperObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 需求文档一开始还不存在，prd初始为空对象</span></span><br><span class="line">        <span class="keyword">this</span>.prdState = &#123;&#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'DeveloperObserver created'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写一个具体的update方法</span></span><br><span class="line">    update(publisher) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'DeveloperObserver.update invoked'</span>)</span><br><span class="line">        <span class="comment">// 更新需求文档</span></span><br><span class="line">        <span class="keyword">this</span>.prdState = publisher.getState()</span><br><span class="line">        <span class="comment">// 调用工作函数</span></span><br><span class="line">        <span class="keyword">this</span>.work()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// work方法，一个专门搬砖的方法</span></span><br><span class="line">    work() &#123;</span><br><span class="line">        <span class="comment">// 获取需求文档</span></span><br><span class="line">        <span class="keyword">const</span> prd = <span class="keyword">this</span>.prdState</span><br><span class="line">        <span class="comment">// 开始基于需求文档提供的信息搬砖。。。</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'996 begins...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、观察者模式在面试中的考点"><a href="#五、观察者模式在面试中的考点" class="headerlink" title="五、观察者模式在面试中的考点"></a>五、观察者模式在面试中的考点</h3><h4 id="5-1-Vue-数据双向绑定的原理"><a href="#5-1-Vue-数据双向绑定的原理" class="headerlink" title="5.1 Vue 数据双向绑定的原理"></a>5.1 Vue 数据双向绑定的原理</h4><blockquote><p>面试：说说你对 vue 双向绑定的理解。</p></blockquote><p>在 Vue 数据双向绑定的实现逻辑，分为以下三个角色：</p><ul><li><strong>Observer（监听器）—— 发布者：</strong> 在 <code>Vue</code> 的双向绑定中，<code>observer</code> 是一个监听器，不仅有<strong>接收</strong>作用还有<strong>转发</strong>的功能，所以不仅是“<strong>订阅者</strong>”也是“<strong>发布者</strong>”。</li><li><strong>watcher（订阅者）—— 订阅者：</strong> <code>observer</code> 会把监听到的数据转发给 <code>watcher</code> 对象（订阅者），<code>watcher</code> 接收到通知之后就会更新视图。</li><li><strong>complie（编译器）—— 初始化视图：</strong>MVVM 框架特有的角色，负责对每个节点元素<strong>指令</strong>进行<strong>扫描和解析</strong>，指令的数据初始化、订阅者的创建都交给 <code>complie</code> 来做。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><p>首先实现一个方法，先对监听的数据对象进行遍历，然后给它加上 <code>setter</code> 和 <code>getter</code> 方法，用来监听属性的改变。当对象的属性发生改变的时候，就会触发 setter 方法，然后就会通知订阅者做出视图更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的对象，对对象的每个属性进行设定 setter 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若target是一个对象，则遍历它</span></span><br><span class="line">    <span class="keyword">if</span>(target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">key</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// defineReactive方法会给目标属性装上“监听器”</span></span><br><span class="line">            defineReactive(target, key, target[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象属性安装监听器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅者实例</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听当前属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">        set: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 通知所有订阅者</span></span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发布者-Dep"><a href="#发布者-Dep" class="headerlink" title="发布者 Dep"></a>发布者 Dep</h5><p>主要用来增加订阅者、通知订阅者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化订阅队列</span></span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加订阅者</span></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知订阅者（是不是所有的代码都似曾相识？）</span></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>)=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-实现一个-Event-Bus-Vue-全局事件总线和-Event-Emitter（Node）"><a href="#5-2-实现一个-Event-Bus-Vue-全局事件总线和-Event-Emitter（Node）" class="headerlink" title="5.2 实现一个 Event Bus(Vue) 全局事件总线和 Event Emitter（Node）"></a>5.2 实现一个 Event Bus(Vue) 全局事件总线和 Event Emitter（Node）</h4><p>具体的说，Event Bus 是一种发布——订阅者模式。日常运用非常的广泛，也属于设计模式中的重中之重。</p><h5 id="1、-Event-Bus-在-Vue-中的应用"><a href="#1、-Event-Bus-在-Vue-中的应用" class="headerlink" title="1、 Event Bus 在 Vue 中的应用"></a>1、 Event Bus 在 Vue 中的应用</h5><blockquote><p>全局事件总线主要起到一个<strong>中心沟通转发</strong>作用，可以作为一个事件中心。如果组件 A 和组件 B 进行通信，除了使用 <code>Vuex</code> 外，可以使用 <code>Event Bus</code>。但是是通过事件中心来沟通，不能进行私下的通信。</p></blockquote><p>创建一个 Event Bus 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventBus</span><br></pre></td></tr></table></figure><p>主文件引入 Event Bus，挂在全局：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'EventBus的文件路径'</span></span><br><span class="line">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure><p>订阅事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里func指someEvent这个事件的监听函数</span></span><br><span class="line"><span class="keyword">this</span>.bus.$on(<span class="string">'someEvent'</span>, func)</span><br></pre></td></tr></table></figure><p>发布事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里params指someEvent这个事件被触发时回调函数接收的入参</span></span><br><span class="line"><span class="keyword">this</span>.bus.$emit(<span class="string">'someEvent'</span>, params)</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！</strong></p></blockquote><h5 id="2、实现一个-Event-Bus"><a href="#2、实现一个-Event-Bus" class="headerlink" title="2、实现一个 Event Bus"></a>2、实现一个 Event Bus</h5><p><img src="https://user-gold-cdn.xitu.io/2019/4/5/169ed4a77700d98e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// handlers是一个map，用于存储事件与回调之间的对应关系</span></span><br><span class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数</span></span><br><span class="line">  on(eventName, cb) &#123;</span><br><span class="line">    <span class="comment">// 先检查一下目标事件名有没有对应的监听函数队列</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.handlers[eventName]) &#123;</span><br><span class="line">      <span class="comment">// 如果没有，那么首先初始化一个监听函数队列</span></span><br><span class="line">      <span class="keyword">this</span>.handlers[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把回调函数推入目标事件的监听函数队列里去</span></span><br><span class="line">    <span class="keyword">this</span>.handlers[eventName].push(cb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数</span></span><br><span class="line">  emit(eventName, ...args) &#123;</span><br><span class="line">    <span class="comment">// 检查目标事件是否有监听函数队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[eventName]) &#123;</span><br><span class="line">      <span class="comment">// 如果有，则逐个调用队列里的回调函数</span></span><br><span class="line">      <span class="keyword">this</span>.handlers[eventName].forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">        callback(...args)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除某个事件回调队列里的指定回调函数</span></span><br><span class="line">  off(eventName, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="keyword">this</span>.handlers[eventName]</span><br><span class="line">    <span class="keyword">const</span> index = callbacks.indexOf(cb)</span><br><span class="line">    <span class="keyword">if</span> (index !== <span class="number">-1</span>) &#123;</span><br><span class="line">      callbacks.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为事件注册单次监听器</span></span><br><span class="line">  once(eventName, cb) &#123;</span><br><span class="line">    <span class="comment">// 对回调函数进行包装，使其执行完毕自动被移除</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      cb.apply(...args)</span><br><span class="line">      <span class="keyword">this</span>.off(eventName, wrapper)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(eventName, wrapper)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、观察者模式和订阅者模式的区别？"><a href="#六、观察者模式和订阅者模式的区别？" class="headerlink" title="六、观察者模式和订阅者模式的区别？"></a>六、观察者模式和订阅者模式的区别？</h3><p>观察者和订阅者之间最大的区别就是<strong>是否存在于第三方。</strong> </p><ul><li><strong>观察者模式：</strong> 发布者直接触及到订阅者的操作叫做观察者模式。</li><li><strong>发布—订阅者模式：</strong> 发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作叫做发布订阅者模式。</li></ul><h4 id="6-1-两者的适用条件"><a href="#6-1-两者的适用条件" class="headerlink" title="6.1 两者的适用条件"></a>6.1 两者的适用条件</h4><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><blockquote><p>观察者模式，解决的是模块间的耦合问题，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但是，<strong>观察者模式只是减少了耦合问题，但并没完全解决耦合。</strong> —— 被观察者还要维护观察者的集合，观察者必须提供统一的接口供被观察者调用。</p></blockquote><h5 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h5><blockquote><p>发布订阅者模式无序关心对方，而是都交给中心事件总线进行处理，实现了完全的解耦。</p></blockquote><h5 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h5><ul><li><p>在实际开发中，模块化的解耦诉求并非总是要进行完全解耦。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。</p></li><li><p>而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用发布-订阅模式。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式之观察者模式！&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式之【策略模式】</title>
    <link href="http://yoursite.com/2019/12/05/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/05/前端设计模式之【策略模式】/</id>
    <published>2019-12-05T07:27:25.210Z</published>
    <updated>2019-12-05T09:28:14.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式之策略模式！</p><a id="more"></a><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式主要注重良好代码的「<strong>编程习惯</strong>」和「<strong>重构意识</strong>」。</p><h3 id="一、最常见的场景——-if-else"><a href="#一、最常见的场景——-if-else" class="headerlink" title="一、最常见的场景——(if-else)"></a>一、最常见的场景——(if-else)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">askPrice</span>(<span class="params">tag, originPrice</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(tag === <span class="string">'1'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理的业务1</span></span><br><span class="line">    <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(tag === <span class="string">'2'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理的业务2</span></span><br><span class="line">    <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(tag === <span class="string">'3'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理的业务3</span></span><br><span class="line">    <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(tag === <span class="string">'4'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理的业务4</span></span><br><span class="line">    <span class="keyword">return</span> 结果</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下上边应用场景出现的问题：</p><ul><li>违背了设计模式中的“<strong>单一职责原则</strong>”。一个函数处理了多个功能的代码块，第一，导致除了问题无法快速定位，代码块的代码太零散，如果有函数，直接断点跳到该功能函数中；第二，单一的功能没有被抽离，代码从头一下撸到底。</li><li>违背了设计模式中的“<strong>开放封闭式原则</strong>”。第一，每次增加一个功能还是要修改原来的函数体，没有实现“对扩展开放，对修改封闭”的效果。第二，不仅自己开发麻烦，而且测试功能的时候会连累其他测试人员，进行一次回归测试要全部把该函数的功能全部测试一遍。</li></ul><h3 id="二、策略模式的重构"><a href="#二、策略模式的重构" class="headerlink" title="二、策略模式的重构"></a>二、策略模式的重构</h3><h4 id="2-1-单一职责改进"><a href="#2-1-单一职责改进" class="headerlink" title="2.1 单一职责改进"></a>2.1 单一职责改进</h4><blockquote><p>每个函数只负责一个功能实现。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function gongneng1()&#123;</span><br><span class="line">// 处理的业务1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gongneng2()&#123;</span><br><span class="line">// 处理的业务2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gongneng3()&#123;</span><br><span class="line">// 处理的业务3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gongneng4()&#123;</span><br><span class="line">// 处理的业务4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进优点：</p><ul><li>定位 bug 精准 —— 断点直接知道逻辑中那个函数出现了问题。</li><li>函数的复用 —— 每个功能函数都可以进行复用，不会出现整块代码的赋值粘贴。</li><li>最大程度的对该函数的功能进行了最大程度的解耦。</li></ul><h4 id="2-2-开放封闭式原则改造"><a href="#2-2-开放封闭式原则改造" class="headerlink" title="2.2 开放封闭式原则改造"></a>2.2 开放封闭式原则改造</h4><p>我们有新的功能需要添加到该函数中，一般我们先创建该功能函数，然后加到判断函数中去，这样做，修改了 if-else 的函数体，违背了“<strong>对扩展开放，对修改封闭</strong>”的效果。</p><p>其实在 if_else 函数中，完成的功能就是不同<strong>功能标签</strong>与<strong>不同功能</strong>之间的映射。我们在完成映射功能的同时也不改变代码的结构——<strong>对象映射</strong>。</p><p><strong>1、将单个的功能写到对象中去。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Processor = &#123;</span><br><span class="line">    gongneng1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//业务一</span></span><br><span class="line">    &#125;</span><br><span class="line">    gongneng2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//业务二</span></span><br><span class="line">    &#125;</span><br><span class="line">    gongneng3:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//业务三</span></span><br><span class="line">    &#125;</span><br><span class="line">gongneng4:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//业务四</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、然后将标签与功能对应上(映射)。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yingshe</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Processor[tag]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、新增加功能扩展</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Processor.gongneng5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 扩展的新功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写完新功能代码之后，老功能的测试代码完全不用全部测试，而是只测试新功能就可以了。代码瞬间变的容易阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式之策略模式！&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式之【代理模式】</title>
    <link href="http://yoursite.com/2019/12/02/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/12/02/前端设计模式之【代理模式】/</id>
    <published>2019-12-02T05:12:47.834Z</published>
    <updated>2019-12-03T06:10:49.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端设计模式之代理模式！</p><a id="more"></a><h3 id="一、最简单的代理-——-Proxy"><a href="#一、最简单的代理-——-Proxy" class="headerlink" title="一、最简单的代理 —— Proxy"></a>一、最简单的代理 —— Proxy</h3><h3 id="二、事件代理"><a href="#二、事件代理" class="headerlink" title="二、事件代理"></a>二、事件代理</h3><p>加入父元素下有多个子元素，该所有的子元素都要进行事件监听，如果给每一个子元素绑定监听事件，就会导致创建多个私有作用域，在性能上会有很大的开销。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ 假如不用代理模式，我们将循环安装监听函数</span><br><span class="line"><span class="keyword">const</span> aNodes = <span class="built_in">document</span>.getElementById(<span class="string">'father'</span>).getElementsByTagName(<span class="string">'a'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> aLength = aNodes.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;aLength;i++) &#123;</span><br><span class="line">    aNodes[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        alert(<span class="string">`我是<span class="subst">$&#123;aNodes[i].innerText&#125;</span>`</span>)                  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用代理模式，在其父容器上设置监听，则可以减少性能的开销，而且代码也简单了很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">const</span> father = <span class="built_in">document</span>.getElementById(<span class="string">'father'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给父元素安装一次监听函数</span></span><br><span class="line">father.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 识别是否是目标子元素</span></span><br><span class="line">    <span class="keyword">if</span>(e.target.tagName === <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="comment">// 以下是监听函数的函数体</span></span><br><span class="line">        e.preventDefault()</span><br><span class="line">        alert(<span class="string">`我是<span class="subst">$&#123;e.target.innerText&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p>通过父元素<strong>代理、分发</strong>的方式，间接的将其作用于子元素，这种模式叫做<strong>事件代理</strong>。</p><h3 id="三、虚拟代理"><a href="#三、虚拟代理" class="headerlink" title="三、虚拟代理"></a>三、虚拟代理</h3><p>在性能优化里边，图片的优化有两种加载方式，分别为<strong>懒加载</strong>和<strong>预加载</strong>。</p><ul><li><p><strong>懒加载：</strong>针对于图片加载时机的优化。在一些图片量比较大的网站，用户打开网页尝试把所有的页面加载完，会导致白屏和卡顿情况。所以采取“先占位，后加载”的策略。</p></li><li><p><strong>预加载：</strong>预加载主要为了避免网络不好、图片太大时，页面长时间给用户留空白。所以需要一个 img 的标签占位符，然后创建一个 images 实例，让 src 指向图片的真实地址。 —— 其对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将 DOM 上的 img 元素的 src 指向真实的目标图片地址。</p></li></ul><h4 id="3-1-预加载"><a href="#3-1-预加载" class="headerlink" title="3.1 预加载"></a>3.1 预加载</h4><blockquote><p>一下代码存在问题，就是 PreLoadImage 要做的事情太多，不仅要负责图片的加载，还要负责 DOM 层面的操作，严重违反了设计模式中的<strong>单一职责原则</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreLoadImage</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占位图的url地址</span></span><br><span class="line">    <span class="keyword">static</span> LOADING_URL = <span class="string">'xxxxxx'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(imgNode) &#123;</span><br><span class="line">        <span class="comment">// 获取该实例对应的DOM节点</span></span><br><span class="line">        <span class="keyword">this</span>.imgNode = imgNode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法用于设置真实的图片地址</span></span><br><span class="line">    setSrc(targetUrl) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// img节点初始化时展示的是一个占位图</span></span><br><span class="line">        <span class="keyword">this</span>.imgNode.src = PreLoadImage.LOADING_URL</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个帮我们加载图片的Image实例</span></span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image()</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 设置src属性，Image实例开始加载图片</span></span><br><span class="line">        image.src = srcUrl</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监听目标图片加载的情况，完成时再将DOM上的img节点的src属性设置为目标图片的url</span></span><br><span class="line">        image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.imgNode.src = targetUrl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们试着将两者进行分离，分离之后，需要借助一个代理器将它们进行连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreLoadImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(imgNode) &#123;</span><br><span class="line">        <span class="comment">// 获取真实的DOM节点</span></span><br><span class="line">        <span class="keyword">this</span>.imgNode = imgNode</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 操作img节点的src属性</span></span><br><span class="line">    setSrc(imgUrl) &#123;</span><br><span class="line">        <span class="keyword">this</span>.imgNode.src = imgUrl</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占位图的url地址</span></span><br><span class="line">    <span class="keyword">static</span> LOADING_URL = <span class="string">'xxxxxx'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(targetImage) &#123;</span><br><span class="line">        <span class="comment">// 目标Image，即PreLoadImage实例</span></span><br><span class="line">        <span class="keyword">this</span>.targetImage = targetImage</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法主要操作虚拟Image，完成加载</span></span><br><span class="line">    setSrc(targetUrl) &#123;</span><br><span class="line">       <span class="comment">// 真实img节点初始化时展示的是一个占位图</span></span><br><span class="line">        <span class="keyword">this</span>.targetImage.setSrc(ProxyImage.LOADING_URL)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个帮我们加载图片的虚拟Image实例</span></span><br><span class="line">        <span class="keyword">const</span> virtualImage = <span class="keyword">new</span> Image()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置src属性，虚拟Image实例开始加载图片</span></span><br><span class="line">        virtualImage.src = targetUrl</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监听目标图片加载的情况，完成时再将DOM上的真实img节点的src属性设置为目标图片的url</span></span><br><span class="line">        virtualImage.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetImage.setSrc(targetUrl)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实例中，<code>virtualImage</code> 这个对象它始终存在于 JavaScript 世界中、代替真实 DOM 发起了图片加载请求、完成了图片加载工作，却从未在渲染层面抛头露面。因此这种模式被称为“虚拟代理”模式。</p><h3 id="四、缓存代理"><a href="#四、缓存代理" class="headerlink" title="四、缓存代理"></a>四、缓存代理</h3><p>在一些大的计算场景，用到“空间换时间”的思想，当我们需要用到某个计算值的时候，每次都不用去计算，而是计算一次就放入到缓存中，下次直接在缓存中取出使用即可，大大增加了系统的性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addAll方法会对你传入的所有参数做求和操作</span></span><br><span class="line"><span class="keyword">const</span> addAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进行了一次新计算'</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        result += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为求和方法创建代理</span></span><br><span class="line"><span class="keyword">const</span> proxyAddAll = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 求和结果的缓存池</span></span><br><span class="line">    <span class="keyword">const</span> resultCache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将入参转化为一个唯一的入参字符串</span></span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查本次入参是否有对应的计算结果</span></span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> resultCache) &#123;</span><br><span class="line">            <span class="comment">// 如果有，则返回缓存池里现成的结果</span></span><br><span class="line">            <span class="keyword">return</span> resultCache[args]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultCache[args] = addAll(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="五、保护代理"><a href="#五、保护代理" class="headerlink" title="五、保护代理"></a>五、保护代理</h3><blockquote><p>在 ES6 中的 Proxy。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端设计模式之代理模式！&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端打包工具之 Webpack【01基本认识】</title>
    <link href="http://yoursite.com/2019/11/27/%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%B9%8B%20Webpack%E3%80%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%A4%E8%AF%86%E3%80%91/"/>
    <id>http://yoursite.com/2019/11/27/前端打包工具之 Webpack【基本概念和认识】/</id>
    <published>2019-11-27T06:31:14.479Z</published>
    <updated>2019-12-09T05:05:42.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端打包工具 Webpack 的基本认识。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h3 id="一、安装和使用"><a href="#一、安装和使用" class="headerlink" title="一、安装和使用"></a>一、安装和使用</h3><h4 id="1、安装-webpack-和-webpack-cli"><a href="#1、安装-webpack-和-webpack-cli" class="headerlink" title="1、安装 webpack 和 webpack-cli"></a>1、安装 webpack 和 webpack-cli</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -g</span><br></pre></td></tr></table></figure><h4 id="2、项目生成依赖配置文件"><a href="#2、项目生成依赖配置文件" class="headerlink" title="2、项目生成依赖配置文件"></a>2、项目生成依赖配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h3 id="二、基本认识"><a href="#二、基本认识" class="headerlink" title="二、基本认识"></a>二、基本认识</h3><p><code>webpack</code> 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包。主要将不同类型的文件打包成几个几个必需的静态文件。<code>webpack</code> 有非常灵活的<strong>配置项</strong>和强大的<strong>扩展能力</strong>，所以使得前端打包变的十分的方便。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623bfac4a1e0945?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="webpack as a bundler"></p><h4 id="1、入口"><a href="#1、入口" class="headerlink" title="1、入口"></a>1、入口</h4><p>在多个代码块中都会有一个 <code>.js</code> 文件，其实这就是 webpack 打包的一个入口文件，打包的时候先读取这个文件，然后再开始解析这个文件所有的依赖。一般默认的入口文件路径为 <code>./src/index.js</code>。</p><p>对于单页应用来说，可能入口只有一个；如果多个页面的项目，就会对应多个构建入口。</p><blockquote><p>单页应用和多页应用的区别？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述配置等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者配置多个入口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/page-foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/page-bar.js'</span>, </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组来对多个文件进行打包</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      <span class="string">'./src/foo.js'</span>,</span><br><span class="line">      <span class="string">'./src/bar.js'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、loader"><a href="#2、loader" class="headerlink" title="2、loader"></a>2、loader</h4><p><code>loader</code> 是一种处理多种文件格式的机制。可以理解为将不同文件格式的内容转化为 weboack 可以打包的模块（也就是 js 模块）。通过不同的<code>loader</code> 来处理不同的文件格式，比如需要 <code>css-loader</code> 、<code>style-loader</code> 来处理 <code>.css</code> 文件，最终都将转化为 js 代码，因为 JS 代码可以在浏览器中运行。</p><p>我们主要在 <code>module.rules</code> 进行相关配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span></span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>) <span class="comment">// 指定哪些路径下的文件需要经过 loader 处理</span></span><br><span class="line">      ],</span><br><span class="line">      use: <span class="string">'babel-loader'</span>, <span class="comment">// 指定使用的 loader</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS:loader 在 webpack 中相对于比较重要。</p></blockquote><h4 id="3、plugin"><a href="#3、plugin" class="headerlink" title="3、plugin"></a>3、plugin</h4><p>模块的代码转换需要 <code>loader</code> 来完成，而其他的任务，比如 <code>js</code> 的压缩，是通过 <code>uglifyjs-webpack-plugin</code> 插件来完成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS: 开发者可以根据需求自己开发 plugins 插件。</p></blockquote><h4 id="4、输出"><a href="#4、输出" class="headerlink" title="4、输出"></a>4、输出</h4><p>输出则是指的是 webpack 打包之后输出的静态文件，我们可以配置<strong>输出的路径和文件名</strong>，最终通过 <code>out</code>字段来配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者多个入口生成不同文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/bar.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist/[hash]'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、相关配置"><a href="#三、相关配置" class="headerlink" title="三、相关配置"></a>三、相关配置</h3><blockquote><p>一般我们会在项目下的 <code>webpack.config.js</code> 相关的 webpack 运行配置。</p></blockquote><p>因为 <code>webpack.config.js</code> 是一个 <code>Node.js</code> 脚本，扩展性非常高，因为可以引入第三方模块使用。该配置文件通过暴露出一个配置对象，<code>webpack</code>在运行的时候会读取该对象的相关配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">        ],</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码模块路径解析的配置</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [</span><br><span class="line">      <span class="string">"node_modules"</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    extensions: [<span class="string">".wasm"</span>, <span class="string">".mjs"</span>, <span class="string">".js"</span>, <span class="string">".json"</span>, <span class="string">".jsx"</span>],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyPlugin(), </span><br><span class="line">    <span class="comment">// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span></span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理之外，我们很少从零开始配置 <code>webpack</code>，而是通过已有的脚手架提供。</p><h3 id="四、搭建基本的前端开发环境"><a href="#四、搭建基本的前端开发环境" class="headerlink" title="四、搭建基本的前端开发环境"></a>四、搭建基本的前端开发环境</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端打包工具 Webpack 的基本认识。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式之【适配器模式】</title>
    <link href="http://yoursite.com/2019/11/27/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/11/27/前端设计模式之【适配器模式】/</id>
    <published>2019-11-27T05:08:57.452Z</published>
    <updated>2019-11-27T05:52:02.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>设计模式之适配器模式。</p><a id="more"></a><h3 id="一、什么是适配器模式？"><a href="#一、什么是适配器模式？" class="headerlink" title="一、什么是适配器模式？"></a>一、什么是适配器模式？</h3><blockquote><p>适配器模式通过<strong>把一个类的接口变换成客户端所期待的另一种接口</strong>，可以帮我们解决<strong>不兼容</strong>的问题。</p></blockquote><h3 id="二、适配器模式应用"><a href="#二、适配器模式应用" class="headerlink" title="二、适配器模式应用"></a>二、适配器模式应用</h3><blockquote><p>比如一些公司老项目和新项目的封装机制不同，比如：函数调用名称和参数。我们应该使用适配器模式来抹平两者之间的差异。</p></blockquote><p>十年前的老代码封装的数据请求库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">type, url, data, success, failed</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建ajax对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...请求逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送get请求</span></span><br><span class="line">Ajax(<span class="string">'get'</span>, url地址, post入参, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 成功的回调逻辑</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 失败的回调逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在新封装的数据请求库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get 方法</span></span><br><span class="line">    <span class="keyword">static</span> get()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// post 方法</span></span><br><span class="line">    <span class="keyword">static</span> get()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 发起post请求</span></span><br><span class="line"> <span class="keyword">const</span> postResponse = <span class="keyword">await</span> HttpUtils.post(URL,params) || &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 发起get请求</span></span><br><span class="line"> <span class="keyword">const</span> getResponse = <span class="keyword">await</span> HttpUtils.get(URL)</span><br></pre></td></tr></table></figure><p>我们要用适配器模式来磨平差异，从而通过老代码的<strong>函数名和参数</strong>进行请求的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ajax适配器函数，入参与旧接口保持一致</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">AjaxAdapter</span>(<span class="params">type, url, data, success, failed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = type.toUpperCase()</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 实际的请求全部由新接口发起</span></span><br><span class="line">         <span class="keyword">if</span>(type === <span class="string">'GET'</span>) &#123;</span><br><span class="line">            result = <span class="keyword">await</span> HttpUtils.get(url) || &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">'POST'</span>) &#123;</span><br><span class="line">            result = <span class="keyword">await</span> HttpUtils.post(url, data) || &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设请求成功对应的状态码是1</span></span><br><span class="line">        result.statusCode === <span class="number">1</span> &amp;&amp; success ? success(result) : failed(result.statusCode)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 捕捉网络错误</span></span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;</span><br><span class="line">            failed(error.statusCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用适配器适配旧的Ajax方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">type, url, data, success, failed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> AjaxAdapter(type, url, data, success, failed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、适配器模式的实践-——-axios"><a href="#三、适配器模式的实践-——-axios" class="headerlink" title="三、适配器模式的实践 —— axios"></a>三、适配器模式的实践 —— axios</h3><blockquote><p>axios 本身就用到了适配器模式，它不仅在浏览器环境下进行使用，而且在 Node 环境下同样可以使用，正式通过这种适配器模式磨平了两种平台的差异。进而能够轻松发起网路请求从而不必在乎底层的实现。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adapter;</span><br><span class="line">  <span class="comment">// 判断当前是否是node环境</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(process) === <span class="string">'[object process]'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是node环境，调用node专属的http适配器</span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">'./adapters/http'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是浏览器环境，调用基于xhr的适配器</span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">'./adapters/xhr'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>http 适配器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">httpAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchHttpRequest</span>(<span class="params">resolvePromise, rejectPromise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 具体逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xhr 适配器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 具体逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两个适配器的入参都是 config；</li><li>两个适配器的出参都是一个 Promise。</li></ul><p>PS：详情就读 <a href="https://github.com/axios/axios/tree/master/lib/adapters" target="_blank" rel="noopener">axios 源码</a>。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><h4 id="1、有差异，就有适配器"><a href="#1、有差异，就有适配器" class="headerlink" title="1、有差异，就有适配器"></a>1、有差异，就有适配器</h4><h4 id="2、统一的接口，统一的入参，统一的出参，统一的规则。"><a href="#2、统一的接口，统一的入参，统一的出参，统一的规则。" class="headerlink" title="2、统一的接口，统一的入参，统一的出参，统一的规则。"></a>2、统一的接口，统一的入参，统一的出参，统一的规则。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式之适配器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
